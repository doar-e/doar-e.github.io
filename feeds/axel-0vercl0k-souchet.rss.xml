<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Diary of a reverse-engineer - Axel "0vercl0k" Souchet</title><link>https://doar-e.github.io/</link><description></description><lastBuildDate>Mon, 19 Nov 2018 08:25:00 -0800</lastBuildDate><item><title>Introduction to SpiderMonkey exploitation.</title><link>https://doar-e.github.io%5Cblog/2018/11/19/introduction-to-spidermonkey-exploitation/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;This blogpost covers the development of three exploits targeting SpiderMonkey JavaScript Shell interpreter and Mozilla Firefox on Windows 10 RS5 64-bit from the perspective of somebody that has never written a browser exploit nor looked closely at any JavaScript engine codebase.&lt;/p&gt;
&lt;p&gt;As you have probably noticed, there has been …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Mon, 19 Nov 2018 08:25:00 -0800</pubDate><guid isPermaLink="false">tag:doar-e.github.io\blog,2018-11-19:/2018/11/19/introduction-to-spidermonkey-exploitation/</guid><category>spidermonkey</category><category>blazefox</category><category>exploitation</category><category>windows</category><category>ttd</category></item><item><title>Breaking ledgerctf's AES white-box challenge</title><link>https://doar-e.github.io%5Cblog/2018/05/17/breaking-ledgerctfs-aes-white-box-challenge/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;About a month ago, my mate &lt;a href="https://twitter.com/b0n0n"&gt;b0n0n&lt;/a&gt; was working on the &lt;a href="https://www.ledger.fr/ctf2018/"&gt;ledgerctf&lt;/a&gt; puzzles and challenged me to have a look at the &lt;em&gt;ctf2&lt;/em&gt; binary. I eventually did and this blogpost discusses the protection scheme and how I broke it. Before diving in though, here is a bit of background …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Thu, 17 May 2018 11:52:00 -0700</pubDate><guid isPermaLink="false">tag:doar-e.github.io\blog,2018-05-17:/2018/05/17/breaking-ledgerctfs-aes-white-box-challenge/</guid><category>reverse-engineering</category><category>ledgerctf</category><category>whitebox</category></item><item><title>beVX challenge on the operation table</title><link>https://doar-e.github.io%5Cblog/2018/03/11/bevx-challenge-on-the-operation-table/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;About two weeks ago, my friend &lt;a href="https://twitter.com/mongobug"&gt;mongo&lt;/a&gt; challenged me to solve a reverse-engineering puzzle put up by the &lt;a href="https://blogs.securiteam.com/"&gt;SSD&lt;/a&gt; team for &lt;a href="https://www.offensivecon.org/"&gt;OffensiveCon2018&lt;/a&gt; (which is a security conference that took place in Berlin in February). The challenge binary is available for download &lt;a href="https://www.beyondsecurity.com/bevxcon/bevx-challenge-1"&gt;here&lt;/a&gt; and &lt;a href="https://twitter.com/SecuriTeam_SSD/status/964459126960066560"&gt;here is one of the original …&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Sun, 11 Mar 2018 17:22:00 -0700</pubDate><guid isPermaLink="false">tag:doar-e.github.io\blog,2018-03-11:/2018/03/11/bevx-challenge-on-the-operation-table/</guid><category>reverse-engineering</category><category>beVX</category></item><item><title>Debugger data model, Javascript &amp; x64 exception handling</title><link>https://doar-e.github.io%5Cblog/2017/12/01/debugger-data-model/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;The main goal of today's post is to show a bit more of what is now possible with the latest Windbg (currently branded &lt;a href="https://blogs.windows.com/buildingapps/2017/08/28/new-windbg-available-preview/"&gt;"WinDbg Preview"&lt;/a&gt; in the Microsoft store) and the time travel debugging tools that Microsoft released a few months ago. When these finally got released, a bit …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Fri, 01 Dec 2017 06:59:00 -0800</pubDate><guid isPermaLink="false">tag:doar-e.github.io\blog,2017-12-01:/2017/12/01/debugger-data-model/</guid><category>debugging</category><category>javascript</category><category>windbg</category><category>exception handling</category><category>seh</category><category>time-travel debugging</category><category>ttd</category></item><item><title>Binary rewriting with syzygy, Pt. I</title><link>https://doar-e.github.io%5Cblog/2017/08/05/binary-rewriting-with-syzygy/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Binary instrumentation and analysis have been subjects that I have always found fascinating. At compile time via &lt;a href="http://doar-e.github.io/blog/2016/11/27/clang-and-passes/"&gt;clang&lt;/a&gt;, or at runtime with dynamic binary instrumentation frameworks like &lt;a href="https://software.intel.com/en-us/articles/pin-a-dynamic-binary-instrumentation-tool"&gt;Pin&lt;/a&gt; or &lt;a href="http://www.dynamorio.org/"&gt;DynamoRIO&lt;/a&gt;. One thing I have always looked for though, is a framework able to statically instrument a PE image. A …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Sat, 05 Aug 2017 16:08:00 -0700</pubDate><guid isPermaLink="false">tag:doar-e.github.io\blog,2017-08-05:/2017/08/05/binary-rewriting-with-syzygy/</guid><category>binary rewriting</category><category>syzygy</category><category>program analysis</category></item><item><title>Token capture via an llvm-based analysis pass</title><link>https://doar-e.github.io%5Cblog/2016/11/27/clang-and-passes/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;About three years ago, the LLVM framework started to pique my interest for a lot of different reasons. This collection of industrial strength compiler technology, as &lt;a href="http://llvm.org/pubs/2008-10-04-ACAT-LLVM-Intro.pdf"&gt;Latner&lt;/a&gt; said in 2008, was designed in a very modular way. It also looked like it had a lot of interesting features that …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Sun, 27 Nov 2016 20:43:00 -0800</pubDate><guid isPermaLink="false">tag:doar-e.github.io\blog,2016-11-27:/2016/11/27/clang-and-passes/</guid><category>fuzzing</category><category>clang</category><category>llvm</category><category>analysis pass</category><category>pass</category></item><item><title>Spotlight on an unprotected AES128 white-box implementation</title><link>https://doar-e.github.io%5Cblog/2015/02/08/spotlight-on-an-unprotected-aes128-whitebox-implementation/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;I think it all began when I've worked on the &lt;a href="https://github.com/0vercl0k/stuffz/tree/master/NoSuchCon2013"&gt;NSC2013&lt;/a&gt; crackme made by &lt;a href="https://twitter.com/elvanderb"&gt;@elvanderb&lt;/a&gt;, long story short you had an AES128 heavily obfuscated white-box implementation to break. The thing was you could actually solve the challenge in different ways: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;the first one was the easiest one: you didn't …&lt;/li&gt;&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Sun, 08 Feb 2015 22:59:00 -0800</pubDate><guid isPermaLink="false">tag:doar-e.github.io\blog,2015-02-08:/2015/02/08/spotlight-on-an-unprotected-aes128-whitebox-implementation/</guid><category>obfuscation</category><category>white-box</category><category>practical cryptography</category><category>aes128</category><category>encryption</category></item><item><title>Dissection of Quarkslab's 2014 security challenge</title><link>https://doar-e.github.io%5Cblog/2014/09/06/dissection-of-quarkslabs-2014-security-challenge/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;As the blog was a bit silent for quite some time, I figured it would be cool to put together a post ; so here it is folks, dig in!&lt;/p&gt;
&lt;p&gt;The French company &lt;a href="http://blog.quarkslab.com/you-like-python-security-challenge-and-traveling-win-a-free-ticket-to-hitb-kul.html"&gt;Quarkslab&lt;/a&gt; &lt;a href="https://twitter.com/quarkslab/status/507457671386394624"&gt;recently&lt;/a&gt; &lt;a href="https://twitter.com/HITBSecConf/status/507458788522094592"&gt;released&lt;/a&gt; a security challenge to win a free entrance to attend the upcoming &lt;a href="https://conference.hitb.org/hitbsecconf2014kul/"&gt;HITBSecConf&lt;/a&gt; conference …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Sat, 06 Sep 2014 20:37:00 -0700</pubDate><guid isPermaLink="false">tag:doar-e.github.io\blog,2014-09-06:/2014/09/06/dissection-of-quarkslabs-2014-security-challenge/</guid><category>python</category><category>virtual machine</category><category>reverse-engineering</category></item><item><title>Deep dive into Python's VM: Story of LOAD_CONST bug</title><link>https://doar-e.github.io%5Cblog/2014/04/17/deep-dive-into-pythons-vm-story-of-load_const-bug/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;A year ago, I've written a Python script to leverage a bug in Python's virtual machine: the idea was to fully control the Python virtual processor and after that to instrument the VM to execute native codes. The &lt;a href="https://github.com/0vercl0k/stuffz/blob/master/Python's%20internals/python27_abuse_vm_to_execute_x86_code.py"&gt;python27_abuse_vm_to_execute_x86_code.py&lt;/a&gt; script wasn't really self-explanatory, so I believe only a …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Thu, 17 Apr 2014 23:22:00 -0700</pubDate><guid isPermaLink="false">tag:doar-e.github.io\blog,2014-04-17:/2014/04/17/deep-dive-into-pythons-vm-story-of-load_const-bug/</guid><category>python</category><category>virtual machine</category></item><item><title>Having a look at the Windows' User/Kernel exceptions dispatcher</title><link>https://doar-e.github.io%5Cblog/2013/10/12/having-a-look-at-the-windows-userkernel-exceptions-dispatcher/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;The purpose of this little post is to create a piece of code able to monitor exceptions raised in a process (a bit like &lt;a href="http://gynvael.coldwind.pl/"&gt;gynvael&lt;/a&gt;'s &lt;a href="http://gynvael.coldwind.pl/?id=148"&gt;ExcpHook&lt;/a&gt; but in userland), and to generate a report with information related to the exception. The other purpose is to have a look …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Sat, 12 Oct 2013 14:03:00 -0700</pubDate><guid isPermaLink="false">tag:doar-e.github.io\blog,2013-10-12:/2013/10/12/having-a-look-at-the-windows-userkernel-exceptions-dispatcher/</guid><category>coding</category><category>hooking</category><category>windows internals</category></item><item><title>Breaking Kryptonite's obfuscation: a static analysis approach relying on symbolic execution</title><link>https://doar-e.github.io%5Cblog/2013/09/16/breaking-kryptonites-obfuscation-with-symbolic-execution/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Kryptonite&lt;/em&gt; was a proof-of-concept I built to obfuscate codes at the LLVM intermediate representation level. The idea was to use semantic-preserving transformations in order to not break the original program. One of the main idea was for example to build a home-made 32 bits adder to replace the &lt;em&gt;add …&lt;/em&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Mon, 16 Sep 2013 11:47:00 -0700</pubDate><guid isPermaLink="false">tag:doar-e.github.io\blog,2013-09-16:/2013/09/16/breaking-kryptonites-obfuscation-with-symbolic-execution/</guid><category>reverse-engineering</category></item><item><title>Pinpointing heap-related issues: OllyDbg2 off-by-one story</title><link>https://doar-e.github.io%5Cblog/2013/09/09/pinpointing-heap-related-issues-ollydbg2-off-by-one-story/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Yesterday afternoon, I was peacefully coding some stuff you know but I couldn't make my code working.
As usual, in those type of situations you fire up your debugger in order to understand what is going on under the hood.
That was a bit weird, to give you a …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Mon, 09 Sep 2013 09:53:00 -0700</pubDate><guid isPermaLink="false">tag:doar-e.github.io\blog,2013-09-09:/2013/09/09/pinpointing-heap-related-issues-ollydbg2-off-by-one-story/</guid><category>reverse-engineering</category><category>debugging</category></item><item><title>Some thoughts about code-coverage measurement with Pin</title><link>https://doar-e.github.io%5Cblog/2013/08/31/some-thoughts-about-code-coverage-measurement-with-pin/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Sometimes, when you are reverse-engineering binaries you need somehow to measure, or just to have an idea about how much "that" execution is covering the code of your target. It can be for fuzzing purpose, maybe you have a huge set of inputs (it can be files, network traffic …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Sat, 31 Aug 2013 18:57:00 -0700</pubDate><guid isPermaLink="false">tag:doar-e.github.io\blog,2013-08-31:/2013/08/31/some-thoughts-about-code-coverage-measurement-with-pin/</guid><category>reverse-engineering</category><category>dynamic-binary-instrumentation</category></item><item><title>Regular expressions obfuscation under the microscope</title><link>https://doar-e.github.io%5Cblog/2013/08/24/regular-expressions-obfuscation-under-the-microscope/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Some months ago I came across a strange couple of functions that was kind of playing with a &lt;a href="http://en.wikipedia.org/wiki/Finite-state_machine"&gt;finite-state automaton&lt;/a&gt; to validate an input. At first glance, I didn't really notice it was in fact a regex being processed, that's exactly why I spent quite some time to understand …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Sat, 24 Aug 2013 12:35:00 -0700</pubDate><guid isPermaLink="false">tag:doar-e.github.io\blog,2013-08-24:/2013/08/24/regular-expressions-obfuscation-under-the-microscope/</guid><category>reverse-engineering</category><category>obfuscation</category></item></channel></rss>