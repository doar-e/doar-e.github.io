import abc
from keystone import Ks, KS_ARCH_ARM, KS_MODE_THUMB

import fw_version


class BJNPPayload(abc.ABC):
    def __init__(self, version="10.02"):
        self.ks = Ks(KS_ARCH_ARM, KS_MODE_THUMB)

        # Generate list of addresses for our version
        addresses = fw_version.get_address_dict(version)
        self.addresses = {}
        for func, addr in addresses.items():
            self.addresses[func + "_l"] = addr & 0xFFFF
            self.addresses[func + "_h"] = (addr >> 16) & 0xFFFF

    def get_addr(self, key):
        return hex(self.addresses[key])

    @property
    @abc.abstractmethod
    def body(self):
        raise NotImplementedError()

    @property
    def suffix(self):
        return """
        ; Restore stack
        mov r0, #0
        mov r1, #{ntpv_procRegister_l}
        movt r1, #{ntpv_procRegister_h}
        mov lr, r1
        bx lr
        """

    def get_payload(self):
        asm_body = str(self)
        body = ""
        for line in asm_body.splitlines():
            # Remove comments
            line = line.split(";")[0].strip()
            if line:
                body += line + "\n"

        bytecode, _ = self.ks.asm(body.strip())
        return bytes(bytecode or b"")

    def __str__(self):
        # Merge all asm code into one buffer
        body = self.body.strip() + "\n\n" + self.suffix.strip()
        out = ""
        for line in body.splitlines():
            out += line.strip() + "\n"

        # Replace placeholder addresses
        addr_map = {
            key: self.get_addr(key) for key in self.addresses.keys()
        }
        out = out.format(**addr_map)
        return out.strip()

    def __bytes__(self):
        return self.get_payload()


class ChainedPayload(BJNPPayload):
    def __init__(self, payloads, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.payloads = payloads

    @property
    def body(self):
        out = ""
        for payload in self.payloads:
            out += payload.body
        return out


class EnableFtpdPayload(BJNPPayload):
    @property
    def body(self):
        return """
        ; Enable ftpd
        mov r0, #0x3       ; Max clients
        mov r1, #0x0       ; Timeout
        mov r2, #21        ; Command port
        mov r3, #20        ; Data port
        mov r12, #{enable_ftpd_l}
        movt r12, #{enable_ftpd_h}
        blx r12
        """


class FtpdChangeDirectoryPayload(BJNPPayload):
    def __init__(self, path, *args, **kwargs):
        super().__init__(*args, **kwargs)
        path = str(path) + "\0"
        self.path = path + "\0" * (4 - (len(path) % 4))

    @property
    def body(self):
        # Generate code moving path onto stack
        path_store_code = ""
        for i, c in enumerate(self.path):
            path_store_code += """
            mov r0, #{}
            strb r0, [sp, #{}]
            """.format(ord(c), i).rstrip()

        return """
        ; Store ftpd path on stack
        sub sp, #{path_len}
        {path_store_code}

        ; Change ftpd directory to given path
        mov r0, sp
        mov r12, #{{ftpd_cd_l}}
        movt r12, #{{ftpd_cd_h}}
        blx r12

        ; Restore stack
        add sp, #{path_len}
        """.format(
            path_len=len(self.path),
            path_store_code=path_store_code.strip(),
        )


class SetEnergySave(BJNPPayload):
    def __init__(self, enable, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.enable = int(enable)

    @property
    def body(self):
        return """
        ; Enable or disable energy save
        mov r0, #{}
        mov r12, #{{set_energy_save_l}}
        movt r12, #{{set_energy_save_h}}
        blx r12
        """.format(
            self.enable
        )


class SleepPayload(BJNPPayload):
    def __init__(self, milliseconds, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.milliseconds = int(milliseconds)

    @property
    def body(self):
        return """
        ; Sleep the requested number of seconds
        mov r12, #{{sleep_l}}
        movt r12, #{{sleep_h}}
        mov r0, #{}
        mov r1, #1000
        mul r0, r0, r1
        blx r12
        """.format(
            self.milliseconds
        )


class ColorFillScreen(BJNPPayload):
    def __init__(self, color=255, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.color = (color << 8) + color

    @property
    def body(self):
        return """
        ; Alloc space for LCD info struct and fill it in
        sub sp, #8
        mov r0, #100
        strh r0, [sp, #4]  ; width
        mov r0, #60
        strh r0, [sp, #6]  ; height

        ; Get address of image buffer
        mov r10, #{{image_buffer_l}}
        movt r10, #{{image_buffer_h}}

        ; Fill buffer with color
        mov r5, #{color}
        movt r5, #{color}
        mov r3, #0         ; Bytes written

.color_loop:
        str r5, [r10, r3]  ; Write color to buffer
        add r3, r3, 4
        cmp r3, #0x38400    ; 320 * 240 * 3
        blt .color_loop

        ; Fill whole screen with color
        mov r5, 0          ; x
        mov r6, 0          ; y

.display_loop:
        ; Update LCD info struct coordinates
        strh r5, [sp]      ; x
        strh r6, [sp, #2]  ; y

        ; Display frame buffer
        mov r1, r10        ; Image buffer
        mov r0, sp         ; Frame buffer struct
        mov r12, #{{display_frame_buffer_l}}
        movt r12, #{{display_frame_buffer_h}}
        blx r12

        add r5, #100
        cmp r5, #800       ; Screen width
        blt .display_loop

        mov r5, #0
        add r6, #60

        cmp r6, #480       ; Screen height
        blt .display_loop

        ; Cleanup stack
        add sp, #8
        """.format(
            color=self.color,
        )


class DisplayBMP(BJNPPayload):
    def __init__(self, path, x=0, y=0, width=320, height=240, depth=3, *args, **kwargs):
        super().__init__(*args, **kwargs)
        path = str(path) + "\0"
        self.path = path + "\0" * (4 - (len(path) % 4))
        self.x = x
        self.y = y
        self.width = width
        self.height = height
        self.depth = depth

    @property
    def body(self):
        # Generate code moving path onto stack
        path_store_code = ""
        for i, c in enumerate(self.path):
            path_store_code += """
            mov r0, #{}
            strb r0, [sp, #{}]
            """.format(ord(c), i).rstrip()

        return """
        ; Compute image size
        mov r2, #{width}
        mov r3, #{height}
        mov r6, #{depth}
        mul r6, r6, r2
        mul r6, r6, r3

        ; Store image path on stack
        sub sp, #{path_len}
        {path_store_code}

        ; Alloc space for LCD info struct and fill it in
        sub sp, #8
        mov r0, #{width}
        strh r0, [sp, #4]  ; width
        mov r0, #{height}
        strh r0, [sp, #6]  ; height
        mov r0, #{x}
        strh r0, [sp]      ; x
        mov r0, #{y}
        strh r0, [sp, #2]  ; y

        ; Open image file
        mov r2, #0x1C0
        mov r1, #0
        add r0, sp, #8     ; Image path
        mov r12, #{{open_l}}
        movt r12, #{{open_h}}
        blx r12
        mov r5, r0

        ; Exit if there was an error opening the file
        cmp r5, #0
        ble .end

        ; Get address of image buffer
        mov r10, #{{image_buffer_l}}
        movt r10, #{{image_buffer_h}}

        ; Read content of file in buffer
        mov r3, #0         ; Bytes read
        mov r4, r6         ; Bytes left to read
.loop:
        mov r2, r4         ; Number of bytes to read
        add r1, r10, r3    ; Buffer position
        mov r0, r5         ; File handle
        mov r12, #{{read_l}}
        movt r12, #{{read_h}}
        blx r12
        cmp r0, #0
        ble .end_read      ; Exit in case of an error
        add r3, r3, r0
        sub r4, r4, r0
        cmp r4, #0
        bgt .loop

.end_read:
        ; Display frame buffer
        mov r1, r10        ; Image buffer
        mov r0, sp         ; Frame buffer struct
        mov r12, #{{display_frame_buffer_l}}
        movt r12, #{{display_frame_buffer_h}}
        blx r12

        ; Close file
        mov r0, r5
        mov r12, #{{close_l}}
        movt r12, #{{close_h}}
        blx r12

.end:
        ; Cleanup stack
        add sp, #8
        add sp, #{path_len}
        """.format(
            x=self.x,
            y=self.y,
            width=self.width,
            height=self.height,
            depth=self.depth,
            path_len=len(self.path),
            path_store_code=path_store_code.strip(),
        )
