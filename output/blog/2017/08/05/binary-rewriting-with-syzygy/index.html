<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Binary rewriting with syzygy, Pt. I</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="Axel '0vercl0k' Souchet">
    <link rel="stylesheet" href="/theme/css/bootstrap.min.css" type="text/css" />
    <style type="text/css">
      body {
        padding-top: 60px;
        padding-bottom: 40px;
      }
      .sidebar-nav {
        padding: 9px 0;
      }
      .tag-1 {
        font-size: 13pt;
      }
      .tag-2 {
        font-size: 10pt;
      }
      .tag-2 {
        font-size: 8pt;
      }
      .tag-4 {
        font-size: 6pt;
     }
    </style>
    <link href="/theme/css/bootstrap-responsive.min.css" rel="stylesheet" />
    <link href="/theme/css/font-awesome.css" rel="stylesheet" />
    <link href="/theme/css/pygments.css" rel="stylesheet" />

    <!--[if lt IE 9]>
      <script src="//html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link href="/feeds/atom.xml" type="application/atom+xml" rel="alternate" title="Diary of a reverse-engineer ATOM Feed" />
    <link href="/feeds/rss.xml" type="application/atom+xml" rel="alternate" title="Diary of a reverse-engineer RSS Feed" />

  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/index.html">Diary of a reverse-engineer </a>
          <div class="nav-collapse">
            <ul class="nav">
              <ul class="nav">
                    <li><a href="/archives.html"><i class="icon-th-list"></i>Archives</a></li>
              </ul>

                <li >
                    <a href="/category/debugging.html">
                      <i class="icon-folder-open icon-large"></i>debugging
                    </a>
                </li>
                <li >
                    <a href="/category/exploitation.html">
                      <i class="icon-folder-open icon-large"></i>exploitation
                    </a>
                </li>
                <li class="active">
                    <a href="/category/misc.html">
                      <i class="icon-folder-open icon-large"></i>misc
                    </a>
                </li>
                <li >
                    <a href="/category/obfuscation.html">
                      <i class="icon-folder-open icon-large"></i>obfuscation
                    </a>
                </li>
                <li >
                    <a href="/category/reverse-engineering.html">
                      <i class="icon-folder-open icon-large"></i>reverse-engineering
                    </a>
                </li>

                <li><a href="/pages/about.html">About</a></li>
                <li><a href="/pages/presentations.html">Presentations</a></li>

            </ul>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row">
        <div class="span9" id="content">
<section id="content">
        <article>
                <header>
                        <h1>
                                <a href=""
                                        rel="bookmark"
                                        title="Permalink to Binary rewriting with syzygy, Pt. I">
                                        Binary rewriting with syzygy, Pt. I
                                </a>
                        </h1>
                </header>
                <div class="entry-content">
                <div class="well">
<footer class="post-info">
<span class="label">Date</span>
<abbr class="published" title="2017-08-05T16:08:00-07:00">
        <i class="icon-calendar"></i>Sat 05 August 2017
</abbr>
<span class="label">By</span>
<a href="/author/axel-0vercl0k-souchet.html"><i class="icon-user"></i>Axel "0vercl0k" Souchet</a>
<span class="label">Category</span>
<a href="/category/misc.html"><i class="icon-folder-open"></i>misc</a>


<span class="label">Tags</span>
	<a href="/tag/binary-rewriting.html"><i class="icon-tag"></i>binary rewriting</a>
	<a href="/tag/syzygy.html"><i class="icon-tag"></i>syzygy</a>
	<a href="/tag/program-analysis.html"><i class="icon-tag"></i>program analysis</a>
</footer><!-- /.post-info -->                </div>
                <h1 id="introduction">Introduction</h1>
<p>Binary instrumentation and analysis have been subjects that I have always found fascinating. At compile time via <a href="http://doar-e.github.io/blog/2016/11/27/clang-and-passes/">clang</a>, or at runtime with dynamic binary instrumentation frameworks like <a href="https://software.intel.com/en-us/articles/pin-a-dynamic-binary-instrumentation-tool">Pin</a> or <a href="http://www.dynamorio.org/">DynamoRIO</a>. One thing I have always looked for though, is a framework able to statically instrument a PE image. A framework designed a bit like <a href="https://clang.llvm.org/">clang</a> where you can write 'passes' doing various things: transformation of the image, analysis of code blocks, etc. Until a couple of months ago, I wasn't aware of any public and robust projects providing this capability (as in, able to instrument real-world scale programs like Chrome or similar).</p>
<p>In this post (it's been a while I know!), I'll introduce the <a href="https://github.com/google/syzygy">syzygy</a> transformation tool chain with a focus on its <a href="https://github.com/google/syzygy/tree/master/syzygy/instrument">instrumenter</a>, and give an overview of the framework, its capabilities, its limitations, and how you can write transformations yourself. As examples, I'll walk through two simple examples: an analysis pass generating a call-graph, and a transformation pass rewriting the function <code>__report_gsfailure</code> in <a href="https://msdn.microsoft.com/en-us/library/8dbf701c.aspx">/GS</a> protected binaries.</p>


<div class="toc"><span class="toctitle">Table of contents:</span><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#syzygy">Syzygy</a><ul>
<li><a href="#introduction-and-a-little-bit-of-history">Introduction and a little bit of History</a></li>
<li><a href="#compiling">Compiling</a></li>
<li><a href="#terminology">Terminology</a></li>
<li><a href="#debugging-session">Debugging session</a></li>
<li><a href="#callgraphanalysis">CallGraphAnalysis</a><ul>
<li><a href="#the-plan">The plan</a></li>
<li><a href="#implementation">Implementation</a></li>
<li><a href="#visualize-it">Visualize it?</a></li>
</ul>
</li>
<li><a href="#securitycookiecheckhooktransform">SecurityCookieCheckHookTransform</a><ul>
<li><a href="#the-problem">The problem</a></li>
<li><a href="#the-solution">The solution</a></li>
<li><a href="#one-does-not-simply-binary-rewrite">One does not simply binary rewrite</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#last-words">Last words</a></li>
</ul>
</div>
<h1 id="syzygy">Syzygy</h1>
<h2 id="introduction-and-a-little-bit-of-history">Introduction and a little bit of History</h2>
<p><a href="https://github.com/google/syzygy/wiki">syzygy</a> is a project written by Google labeled as a "transformation tool chain". It encompasses a suite of various utilities: <a href="https://github.com/google/syzygy/blob/master/syzygy/instrument/instrument_app.cc">instrument.exe</a> is the application invoking the various transformation passes and apply them on a binary, <a href="https://github.com/google/syzygy/blob/master/syzygy/grinder/grinder_app.cc">grinder.exe</a>, <a href="https://github.com/google/syzygy/blob/master/syzygy/reorder/reorder_app.cc">reorder.exe</a>, etc. In a nutshell, the framework is able to (non exhaustive list):</p>
<ul>
<li>Read and write PDB files,</li>
<li>'Decompose' PE32 binaries built with MSVC (with the help of full PDB symbol),</li>
<li>Assemble Intel x86 32 bits code,</li>
<li>Disassemble Intel x86 32 bits code (via <a href="https://github.com/google/syzygy/tree/master/third_party/distorm">Distorm</a>),</li>
<li>'Relink' an instrumented binary.</li>
</ul>
<p>You also may have briefly heard about the project a while back in this post from May 2013 on Chromium's blog: <a href="https://blog.chromium.org/2013/05/testing-chromium-syzyasan-lightweight.html">Testing Chromium: SyzyASAN, a lightweight heap error detector</a>. As I am sure you all know, <a href="https://github.com/google/sanitizers/wiki/AddressSanitizer">AddressSanitizer</a> is a compile-time instrumentation whose purpose is to <a href="https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm">detect memory errors</a> in C/C++ programs. Long story short, AddressSanitizer tracks the state of your program's memory and instrument memory operations (read / write / heap allocation / heap free) at runtime to make sure that they are 'safe'. For example, in a normal situation reading off by one out-of-bounds on a static sized stack buffer will most likely not result in a crash. AddressSanitizer's job is to detect this issue and to report it to the user.</p>
<p>Currently there is no real equivalent on Windows platforms. The only supported available technology that could help with detecting memory errors is the <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/gflags-and-pageheap">Page Heap</a>. Even though today, clang for Windows is working (<a href="https://groups.google.com/a/chromium.org/forum/#!topic/chromium-dev/Y3OEIKkdlu0">Chrome</a> announced that <a href="https://chromium.googlesource.com/chromium/src/+/d2c91228a51bdf37ae3b2e501fb53c0528f1629c">Windows builds of Chrome now use clang</a>), this was not the case back in 2013. As a result, Google built <a href="https://github.com/google/syzygy/wiki/SyzyASanDesignDocument">SyzyASAN</a>, which is the name of a <a href="https://github.com/google/syzygy/blob/master/syzygy/instrument/transforms/asan_transform.h">transformation</a> aiming at detecting memory errors in PE32 binaries. This transform is built on top of the syzygy framework, and you can instrument your binary with it via the <a href="https://github.com/google/syzygy/blob/master/syzygy/instrument/instrument_app.cc#L94">instrument.exe</a> tool. One consequence of the above, is that the framework has to be robust and accurate enough to instrument Chrome; as a result the code is heavily tested which is awesome for us (it is also nearly the only documentation available too 0:-))!</p>
<h2 id="compiling">Compiling</h2>
<p>In order to get a development environment setup you need to follow specific steps to get all the chromium build/dev tools installed. <a href="https://dev.chromium.org/developers/how-tos/install-depot-tools">depot_tools</a> is the name of the package containing everything you need to properly build the various chromium projects; it includes things like Python, <a href="https://gyp.gsrc.io/">GYP</a>, <a href="https://ninja-build.org/">Ninja</a>, git, etc.</p>
<p>Once depot_tools is installed, it is just a matter of executing the below commands for getting the code and compiling it:</p>
<div class="highlight"><pre><span></span>    &gt; set PATH=D:\Codes\depot_tools;%PATH%
    &gt; mkdir syzygy
    &gt; cd syzygy
    &gt; fetch syzygy
    &gt; cd syzygy\src
    &gt; ninja -C out\Release instrument
</pre></div>


<p>If you would like more information on the matter, I suggest you read this wiki page: <a href="https://github.com/google/syzygy/wiki/SyzygyDevelopmentGuide">SyzygyDevelopmentGuide</a>.</p>
<h2 id="terminology">Terminology</h2>
<p>The terminology used across the project can be a bit misleading or confusing at first, so it is a good time to describe the key terms and their meanings: a <a href="https://github.com/google/syzygy/blob/master/syzygy/block_graph/block_graph.h">BlockGraph</a> is a basically a container of blocks. A <a href="https://github.com/google/syzygy/blob/master/syzygy/block_graph/block_graph.h#L542">BlockGraph::Block</a> can be either a code block, or a data block (the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms680336(v=vs.85).aspx) of your binary would be a data block for example">IMAGE_NT_HEADERS</a>. Every block has various properties like an identifier, a name, etc. and belongs to a section (as in PE sections). Most of those properties are mutable, and you are free to play with them and they will get picked-up by the back-end when relinking the output image. In addition to being a top-level container of blocks, the BlockGraph also keeps track of the sections in your executable. Blocks also have a concept of referrers and references. A reference is basically a link from Block <code>foo</code> to Block <code>bar</code>; where <code>bar</code> is the referent. A referrer can be seen as a cross-reference (in the IDA sense): <code>foo</code> would be a referrer of <code>bar</code>. These two key concepts are very important when building transforms as they also allow you to walk the graph faster. Transferring referrers to another Block is also a very easy operation for example (and is super powerful).</p>
<p>Something that also got me confused at first is their name for a Block is not a basic-block as we know them. Instead, it is a function; a set of basic-blocks. Another key concept being used is called <a href="https://github.com/google/syzygy/blob/master/syzygy/block_graph/block_graph.h#L574">SourceRanges</a>. As Blocks can be combined together or split, they are made so that they look after their own address-space mapping bytes from the original image to bytes in the block.</p>
<p>Finally, the container of basic-blocks as we know them is a <a href="https://github.com/google/syzygy/blob/master/syzygy/block_graph/basic_block_subgraph.h#L38">BasicBlockSubGraph</a> (I briefly mention it a bit later in the post).</p>
<p>Oh, one last thing: the instrumenter is basically the application that decomposes an input binary (comparable to a front-end), present the deconstructed binary (functions, blocks, instructions) to transforms (comparable to a mid-end) that modifies, and finally the back-end part that reconstruct your instrumented binary.</p>
<h2 id="debugging-session">Debugging session</h2>
<p>To make things clearer - and because I like debugging sessions - I think it is worthwhile to spend a bit of time in a debugger actually seeing the various structures and how they map to some code we know. Let's take the following C program and compile it in debug mode (don't forget to enable the full PDB generation with the following linker flag: <code>/PROFILE</code>):</p>
<div class="highlight"><pre><span></span>    <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

    <span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Binary rewriting with syzygy</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello doar-e.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="n">foo</span><span class="p">(</span><span class="n">argc</span><span class="p">);</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p>Throw it to your favorite debugger with the following command - we will use the afl transformation as an example transform to analyze the data we have available to us:</p>
<div class="highlight"><pre><span></span>    instrument.exe --mode=afl --input-image=test.exe --output-image=test.instr.exe
</pre></div>


<p>And let's place this breakpoint:</p>
<div class="highlight"><pre><span></span>    bm instrument!*AFLTransform::OnBlock &quot;.if(@@c++(block-&gt;type_ == 0)){ }.else{ g }&quot;
</pre></div>


<p>Now it's time to inspect the Block associated with our function <code>foo</code> from above:</p>
<div class="highlight"><pre><span></span>    0:000&gt; g
    eax=002dcf80 ebx=00000051 ecx=00482da8 edx=004eaba0 esi=004bd398 edi=004bd318
    eip=002dcf80 esp=0113f4b8 ebp=0113f4c8 iopl=0         nv up ei pl nz na po nc
    cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
    instrument!instrument::transforms::AFLTransform::OnBlock:
    002dcf80 55              push    ebp
    0:000&gt; dx block
      [+0x000] id_              : 0x51
      [+0x004] type_            : CODE_BLOCK (0)
      [+0x008] size_            : 0x5b
      [+0x00c] alignment_       : 0x1
      [+0x010] alignment_offset_ : 0
      [+0x014] padding_before_  : 0x0
      [+0x018] name_            : 0x4ffc70 : &quot;foo&quot;
      [+0x01c] compiland_name_  : 0x4c50b0 : &quot;D:\tmp\test\Debug\main.obj&quot;
      [+0x020] addr_            [Type: core::detail::AddressImpl&lt;0&gt;]
      [+0x024] block_graph_     : 0x48d10c
      [+0x028] section_         : 0x0
      [+0x02c] attributes_      : 0x8
      [+0x030] references_      : { size=0x3 }
      [+0x038] referrers_       : { size=0x1 }
      [+0x040] source_ranges_   [Type: core::AddressRangeMap&lt;core::AddressRange&lt;int,unsigned int&gt;,core::AddressRange&lt;core::detail::AddressImpl&lt;0&gt;,unsigned int&gt; &gt;]
      [+0x04c] labels_          : { size=0x3 }
      [+0x054] owns_data_       : false
      [+0x058] data_            : 0x49ef50 : 0x55
      [+0x05c] data_size_       : 0x5b
</pre></div>


<p>The above shows us every the different properties available in a Block; we can see it is named <code>foo</code>, has the identifier 0x51 and has a size of 0x5B bytes.</p>
<p><center><img alt="foo_idaview.png" src="/images/binary_rewriting_with_syzygy/foo_idaview.png"></center>
It also has one referrer and 3 references, what could they be? With the explanation I gave above, we can guess that the referrer (or cross-ref) must be the <code>main</code> function as it calls into <code>foo</code>.</p>
<div class="highlight"><pre><span></span>    0:000&gt; dx -r1 (*((instrument!std::pair&lt;block_graph::BlockGraph::Block *,int&gt; *)0x4f87c0))
      first            : 0x4bd3ac
      second           : 48
    0:000&gt; dx -r1 (*((instrument!block_graph::BlockGraph::Block *)0x4bd3ac))
        [+0x000] id_              : 0x52
        [+0x004] type_            : CODE_BLOCK (0)
        [+0x008] size_            : 0x4d
        [+0x00c] alignment_       : 0x1
        [+0x010] alignment_offset_ : 0
        [+0x014] padding_before_  : 0x0
        [+0x018] name_            : 0x4c51a0 : &quot;main&quot;
        [+0x01c] compiland_name_  : 0x4c50b0 : &quot;D:\tmp\test\Debug\main.obj&quot;
        [+0x020] addr_            [Type: core::detail::AddressImpl&lt;0&gt;]
        [+0x024] block_graph_     : 0x48d10c
        [+0x028] section_         : 0x0
        [+0x02c] attributes_      : 0x8
        [+0x030] references_      : { size=0x4 }
        [+0x038] referrers_       : { size=0x1 }
        [+0x040] source_ranges_   [Type: core::AddressRangeMap&lt;core::AddressRange&lt;int,unsigned int&gt;,core::AddressRange&lt;core::detail::AddressImpl&lt;0&gt;,unsigned int&gt; &gt;]
        [+0x04c] labels_          : { size=0x3 }
        [+0x054] owns_data_       : false
        [+0x058] data_            : 0x49efb0 : 0x55
        [+0x05c] data_size_       : 0x4d
</pre></div>


<p>Something to keep in mind when it comes to <a href="https://github.com/google/syzygy/blob/master/syzygy/block_graph/block_graph.h#L1046">references</a> is that they are not simply a pointer to a block. A reference does indeed reference a block (duh), but it also has an offset associated to this block to point exactly at where the data is being referenced from.</p>
<div class="highlight"><pre><span></span>    <span class="c1">// Represents a reference from one block to another. References may be offset.</span>
    <span class="c1">// That is, they may refer to an object at a given location, but actually point</span>
    <span class="c1">// to a location that is some fixed distance away from that object. This allows,</span>
    <span class="c1">// for example, non-zero based indexing into a table. The object that is</span>
    <span class="c1">// intended to be dereferenced is called the &#39;base&#39; of the offset.</span>
    <span class="c1">//</span>
    <span class="c1">// BlockGraph references are from a location (offset) in one block, to some</span>
    <span class="c1">// location in another block. The referenced block itself plays the role of the</span>
    <span class="c1">// &#39;base&#39; of the reference, with the offset of the reference being stored as</span>
    <span class="c1">// an integer from the beginning of the block. However, basic block</span>
    <span class="c1">// decomposition requires breaking the block into smaller pieces and thus we</span>
    <span class="c1">// need to carry around an explicit base value, indicating which byte in the</span>
    <span class="c1">// block is intended to be referenced.</span>
    <span class="c1">//</span>
    <span class="c1">// A direct reference to a location will have the same value for &#39;base&#39; and</span>
    <span class="c1">// &#39;offset&#39;.</span>
    <span class="c1">//</span>
    <span class="c1">// Here is an example:</span>
    <span class="c1">//</span>
    <span class="c1">//        /----------\</span>
<span class="c1">    //        +---------------------------+</span>
    <span class="c1">//  O     |          B                | &lt;--- Referenced block</span>
    <span class="c1">//        +---------------------------+      B = base</span>
    <span class="c1">//  \-----/                                  O = offset</span>
    <span class="c1">//</span>
</pre></div>


<p>Let's have a look at the references associated with the <code>foo</code> block now. If you look closely at the block, the set of references is of size 3... what could they be?</p>
<p>One for the <code>printf</code> function, one for the data Block for the string passed to <code>printf</code> maybe?</p>
<div class="highlight"><pre><span></span>    First reference:
    ----------------

    0:000&gt; dx -r1 (*((instrument!std::pair&lt;int const ,block_graph::BlockGraph::Reference&gt; *)0x4f5640))
        first            : 57
        second           [Type: block_graph::BlockGraph::Reference]
    0:000&gt; dx -r1 (*((instrument!block_graph::BlockGraph::Reference *)0x4f5644))
        [+0x000] type_            : ABSOLUTE_REF (1) [Type: block_graph::BlockGraph::ReferenceType]
        [+0x004] size_            : 0x4
        [+0x008] referenced_      : 0x4ce334
        [+0x00c] offset_          : 0
        [+0x010] base_            : 0
    0:000&gt; dx -r1 (*((instrument!block_graph::BlockGraph::Block *)0x4ce334))
        [+0x000] id_              : 0xbc
        [+0x004] type_            : DATA_BLOCK (1)
    [...]
        [+0x018] name_            : 0xbb90f8 : &quot;??_C@_0BO@LBGMPKED@Binary?5rewriting?5with?5syzygy?6?$AA@&quot;
        [+0x01c] compiland_name_  : 0x4c50b0 : &quot;D:\tmp\test\Debug\main.obj&quot;
    [...]
        [+0x058] data_            : 0x4a11e0 : 0x42
        [+0x05c] data_size_       : 0x1e
    0:000&gt; da 0x4a11e0
    004a11e0  &quot;Binary rewriting with syzygy.&quot;

    Second reference:
    -----------------

    0:000&gt; dx -r1 (*((instrument!std::pair&lt;int const ,block_graph::BlockGraph::Reference&gt; *)0x4f56a0))
        first            : 62
        second           [Type: block_graph::BlockGraph::Reference]
    0:000&gt; dx -r1 (*((instrument!block_graph::BlockGraph::Reference *)0x4f56a4))
        [+0x000] type_            : PC_RELATIVE_REF (0) [Type: block_graph::BlockGraph::ReferenceType]
        [+0x004] size_            : 0x4
        [+0x008] referenced_      : 0x4bd42c
        [+0x00c] offset_          : 0
        [+0x010] base_            : 0
    0:000&gt; dx -r1 (*((instrument!block_graph::BlockGraph::Block *)0x4bd42c))
        [+0x000] id_              : 0x53
        [+0x004] type_            : CODE_BLOCK (0)
    [...]
        [+0x018] name_            : 0x4ffd60 : &quot;printf&quot;
        [+0x01c] compiland_name_  : 0x4c50b0 : &quot;D:\tmp\test\Debug\main.obj&quot;
    [...]

    Third reference:
    ----------------

    0:000&gt; dx -r1 (*((instrument!std::pair&lt;int const ,block_graph::BlockGraph::Reference&gt; *)0x4f5a90))
        first            : 83
        second           [Type: block_graph::BlockGraph::Reference]
    0:000&gt; dx -r1 (*((instrument!block_graph::BlockGraph::Reference *)0x4f5a94))
        [+0x000] type_            : PC_RELATIVE_REF (0) [Type: block_graph::BlockGraph::ReferenceType]
        [+0x004] size_            : 0x4
        [+0x008] referenced_      : 0x4bd52c
        [+0x00c] offset_          : 0
        [+0x010] base_            : 0
    0:000&gt; dx -r1 (*((instrument!block_graph::BlockGraph::Block *)0x4bd52c))
        [+0x000] id_              : 0x54
        [+0x004] type_            : CODE_BLOCK (0)
    [...]
        [+0x018] name_            : 0xbb96c8 : &quot;_RTC_CheckEsp&quot;
        [+0x01c] compiland_name_  : 0x4c5260 : &quot;f:\binaries\Intermediate\vctools\msvcrt.nativeproj_607447030\objd\x86\_stack_.obj&quot;
    [...]
</pre></div>


<p>Perfect - that's what we sort of guessed! The last one is just the compiler adding <a href="https://msdn.microsoft.com/en-us/library/8wtf2dfz.aspx">Run-Time Error Checks</a> on us.</p>
<p>Let's have a closer look to the first reference. The <code>references_</code> member is a hash table of offsets and instances of reference.</p>
<div class="highlight"><pre><span></span>    <span class="c1">// Map of references that this block makes to other blocks.</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Offset</span><span class="p">,</span> <span class="n">Reference</span><span class="o">&gt;</span> <span class="n">ReferenceMap</span><span class="p">;</span>
</pre></div>


<p>The offset tells you where exactly in the <code>foo</code> block there is a reference; in our case we can see that the first reference is at offset 57 from the base of the block. If you start IDA real quick and browse at this address, you will see that it points one byte after the PUSH opcode (pointing exactly on the reference to the <code>_Format</code> string):</p>
<div class="highlight"><pre><span></span>    .text:004010C8 68 20 41 40 00 push    offset _Format  ; &quot;Binary rewriting with syzygy\n&quot;
</pre></div>


<p>Another interesting bit I didn't mention earlier is that naturally the <code>data_</code> field backs the actual content of the Block:</p>
<div class="highlight"><pre><span></span>    0:000&gt; u @@c++(block-&gt;data_)
    0049ef50 55              push    ebp
    0049ef51 8bec            mov     ebp,esp
    0049ef53 81eccc000000    sub     esp,0CCh
    0049ef59 53              push    ebx
    0049ef5a 56              push    esi
    0049ef5b 57              push    edi
    0049ef5c 8dbd34ffffff    lea     edi,[ebp-0CCh]
    0049ef62 b933000000      mov     ecx,33h
</pre></div>


<p><center><img alt="foo_disassview.png" src="/images/binary_rewriting_with_syzygy/foo_disassview.png"></center>
Last but not least, I mentioned SourceRanges (you can see it as a vector of pairs describing data ranges from the binary to the content in memory) before, so let's dump it to see what it looks like:</p>
<div class="highlight"><pre><span></span>    0:000&gt; dx -r1 (*((instrument!core::AddressRangeMap&lt;core::AddressRange&lt;int,unsigned int&gt;,core::AddressRange&lt;core::detail::AddressImpl&lt;0&gt;,unsigned int&gt; &gt; *)0x4bd36c))
        [+0x000] range_pairs_     : { size=1 }
    0:000&gt; dx -r1 (*((instrument!std::vector&lt;std::pair&lt;core::AddressRange&lt;int,unsigned int&gt;,core::AddressRange&lt;core::detail::AddressImpl&lt;0&gt;,unsigned int&gt; &gt;,std::allocator&lt;std::pair&lt;core::AddressRange&lt;int,unsigned int&gt;,core::AddressRange&lt;core::detail::AddressImpl&lt;0&gt;,unsigned int&gt; &gt; &gt; &gt; *)0x4bd36c))
        [0]              : {...}, {...}
    0:000&gt; dx -r1 (*((instrument!std::pair&lt;core::AddressRange&lt;int,unsigned int&gt;,core::AddressRange&lt;core::detail::AddressImpl&lt;0&gt;,unsigned int&gt; &gt; *)0x4da1c8))
        first            [Type: core::AddressRange&lt;int,unsigned int&gt;]
        second           [Type: core::AddressRange&lt;core::detail::AddressImpl&lt;0&gt;,unsigned int&gt;]
    0:000&gt; dx -r1 (*((instrument!core::AddressRange&lt;int,unsigned int&gt; *)0x4da1c8))
        [+0x000] start_           : 0
        [+0x004] size_            : 0x5b
    0:000&gt; dx -r1 (*((instrument!core::AddressRange&lt;core::detail::AddressImpl&lt;0&gt;,unsigned int&gt; *)0x4da1d0))
        [+0x000] start_           [Type: core::detail::AddressImpl&lt;0&gt;]
        [+0x004] size_            : 0x5b
    0:000&gt; dx -r1 (*((instrument!core::detail::AddressImpl&lt;0&gt; *)0x4da1d0))
        [+0x000] value_           : 0x1090 [Type: unsigned int]
</pre></div>


<p>In this SourceRanges, we have a mapping from the <a href="https://github.com/google/syzygy/blob/master/syzygy/block_graph/block_graph.h#L568">DataRange</a> (RVA 0, size 0x5B), to the <a href="https://github.com/google/syzygy/blob/master/syzygy/block_graph/block_graph.h#L571">SourceRange</a> (RVA 0x1090, size 0x5B - which matches the previous IDA screen shot, obviously). We will come back to those once we have actually modified / rewritten the blocks to see what happens to the SourceRanges.</p>
<div class="highlight"><pre><span></span>    <span class="k">enum</span> <span class="nl">AddressType</span> <span class="p">:</span> <span class="kt">uint8_t</span> <span class="p">{</span>
      <span class="n">kRelativeAddressType</span><span class="p">,</span>
      <span class="n">kAbsoluteAddressType</span><span class="p">,</span>
      <span class="n">kFileOffsetAddressType</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="c1">// This class implements an address in a PE image file.</span>
    <span class="c1">// Addresses are of three varieties:</span>
    <span class="c1">// - Relative addresses are relative to the base of the image, and thus do not</span>
    <span class="c1">//   change when the image is relocated. Bulk of the addresses in the PE image</span>
    <span class="c1">//   format itself are of this variety, and that&#39;s where relative addresses</span>
    <span class="c1">//   crop up most frequently.</span>
    <span class="c1">// This class is a lightweight wrapper for an integer, which can be freely</span>
    <span class="c1">// copied. The different address types are deliberately assignment</span>
    <span class="c1">// incompatible, which helps to avoid confusion when handling different</span>
    <span class="c1">// types of addresses in implementation.</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="n">AddressType</span> <span class="n">kType</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">AddressImpl</span> <span class="p">{};</span>

    <span class="c1">// A virtual address relative to the image base, often termed RVA in</span>
    <span class="c1">// documentation and in data structure comments.</span>
    <span class="k">using</span> <span class="n">RelativeAddress</span> <span class="o">=</span> <span class="n">detail</span><span class="o">::</span><span class="n">AddressImpl</span><span class="o">&lt;</span><span class="n">kRelativeAddressType</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>


<p>Now that you have been introduced to the main concepts, it is time for me to walk you through two small applications.</p>
<h2 id="callgraphanalysis">CallGraphAnalysis</h2>
<h3 id="the-plan">The plan</h3>
<p>As the framework exposes all the information you need to rewrite and analyze binary, you are also free to <em>just</em> analyze a binary and not modify a single bit. In this example let's make a Block transform and generate a graph of the relationship between code Blocks (functions). As we are interested in exploring the whole binary and every single code Block, we subclass <code>IterativeTransformImpl</code>:</p>
<div class="highlight"><pre><span></span>    <span class="c1">// Declares a BlockGraphTransform implementation wrapping the common transform</span>
    <span class="c1">// that iterates over each block in the image.</span>


    <span class="c1">// An implementation of a BlockGraph transform encapsulating the simple pattern</span>
    <span class="c1">// of Pre, per-block, and Post functions. The derived class is responsible for</span>
    <span class="c1">// implementing &#39;OnBlock&#39; and &#39;name&#39;, and may optionally override Pre and</span>
    <span class="c1">// Post. The derived type needs to also define the static public member</span>
    <span class="c1">// variable:</span>
    <span class="c1">//</span>
    <span class="c1">//   static const char DerivedType::kTransformName[];</span>
    <span class="c1">//</span>
    <span class="c1">// @tparam DerivedType the type of the derived class.</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">DerivedType</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">IterativeTransformImpl</span>
        <span class="o">:</span> <span class="k">public</span> <span class="n">NamedBlockGraphTransformImpl</span><span class="o">&lt;</span><span class="n">DerivedType</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">};</span>
</pre></div>


<p>Doing so allows us define <code>Pre</code> / <code>Post</code> functions, and an <code>OnBlock</code> function that gets called for every Block encountered in the image. This is pretty handy as I can define an <code>OnBlock</code> callback to mine the information we want for every Block, and define <code>Post</code> to process the data I have accumulated if necessary.</p>
<p>The <code>OnBlock</code> function should be pretty light as we only want to achieve a couple of things:</p>
<ol>
<li>Make sure we are dealing with a code Block (and not data),</li>
<li>Walk every referrers and store pairs of [<code>ReferrerBlock</code>, <code>CurrentBlock</code>] in a container.</li>
</ol>
<h3 id="implementation">Implementation</h3>
<p>The first thing to do is to create a C++ class named <code>CallGraphAnalysis</code>, declared in <code>doare_transform.h</code> and defined in <code>doare_transform.cc</code>. Those files are put in the <code>syzygy/instrument/transforms</code> directory where all others transforms live in:</p>
<div class="highlight"><pre><span></span>    D:\syzygy\src&gt;git status
    On branch dev-doare1
    Changes to be committed:
      (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

            new file:   syzygy/instrument/transforms/doare_transforms.cc
            new file:   syzygy/instrument/transforms/doare_transforms.h
</pre></div>


<p>In order to get it compiled we also need to modify the <code>instrument.gyp</code> project file:</p>
<div class="highlight"><pre><span></span>    D:\syzygy\src&gt;git diff syzygy/instrument/instrument.gyp
    diff --git a/syzygy/instrument/instrument.gyp b/syzygy/instrument/instrument.gyp
    index 464c5566..c0eceb87 100644
    --- a/syzygy/instrument/instrument.gyp
    +++ b/syzygy/instrument/instrument.gyp
    @@ -68,6 +70,8 @@
             &#39;transforms/branch_hook_transform.h&#39;,
             &#39;transforms/coverage_transform.cc&#39;,
             &#39;transforms/coverage_transform.h&#39;,
    +        &#39;transforms/doare_transforms.cc&#39;,
    +        &#39;transforms/doare_transforms.h&#39;,
             &#39;transforms/entry_call_transform.cc&#39;,
             &#39;transforms/entry_call_transform.h&#39;,
             &#39;transforms/entry_thunk_transform.cc&#39;,
</pre></div>


<p>The gyp file is basically used to generate Ninja project files - which means that if you don't regenerate the Ninja files from the updated version of this gyp file, you will not be compiling your new code. In order to force a regeneration, you can invoke the <code>depot_tools</code> command: <code>gclient runhooks</code>.</p>
<p>At this point we are ready to get our class coded up; here is the class declaration I have:</p>
<div class="highlight"><pre><span></span>    <span class="c1">// Axel &#39;0vercl0k&#39; Souchet - 26 Aug 2017</span>

    <span class="cp">#ifndef SYZYGY_INSTRUMENT_TRANSFORMS_DOARE_TRANSFORMS_H_</span>
    <span class="cp">#define SYZYGY_INSTRUMENT_TRANSFORMS_DOARE_TRANSFORMS_H_</span>

    <span class="cp">#include</span> <span class="cpf">&quot;base/logging.h&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;syzygy/block_graph/transform_policy.h&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;syzygy/block_graph/transforms/iterative_transform.h&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;syzygy/block_graph/transforms/named_transform.h&quot;</span><span class="cp"></span>

    <span class="k">namespace</span> <span class="n">instrument</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">transforms</span> <span class="p">{</span>

    <span class="k">typedef</span> <span class="n">block_graph</span><span class="o">::</span><span class="n">BlockGraph</span> <span class="n">BlockGraph</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">block_graph</span><span class="o">::</span><span class="n">BlockGraph</span><span class="o">::</span><span class="n">Block</span> <span class="n">Block</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">block_graph</span><span class="o">::</span><span class="n">TransformPolicyInterface</span> <span class="n">TransformPolicyInterface</span><span class="p">;</span>

    <span class="k">class</span> <span class="nc">CallGraphAnalysis</span>
        <span class="o">:</span> <span class="k">public</span> <span class="n">block_graph</span><span class="o">::</span><span class="n">transforms</span><span class="o">::</span><span class="n">IterativeTransformImpl</span><span class="o">&lt;</span>
              <span class="n">CallGraphAnalysis</span><span class="o">&gt;</span> <span class="p">{</span>
     <span class="k">public</span><span class="o">:</span>
      <span class="n">CallGraphAnalysis</span><span class="p">()</span>
          <span class="o">:</span> <span class="n">edges_</span><span class="p">(),</span>
            <span class="n">main_block_</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span>
            <span class="n">total_blocks_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">total_code_blocks_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

      <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">kTransformName</span><span class="p">[];</span>

      <span class="c1">// Functions needed for IterativeTransform.</span>
      <span class="kt">bool</span> <span class="nf">OnBlock</span><span class="p">(</span><span class="k">const</span> <span class="n">TransformPolicyInterface</span><span class="o">*</span> <span class="n">policy</span><span class="p">,</span>
                   <span class="n">BlockGraph</span><span class="o">*</span> <span class="n">block_graph</span><span class="p">,</span>
                   <span class="n">Block</span><span class="o">*</span> <span class="n">block</span><span class="p">);</span>

     <span class="k">private</span><span class="o">:</span>
      <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Block</span><span class="o">*</span><span class="p">,</span> <span class="n">Block</span><span class="o">*&gt;&gt;</span> <span class="n">edges_</span><span class="p">;</span>
      <span class="n">Block</span><span class="o">*</span> <span class="n">main_block_</span><span class="p">;</span>

      <span class="c1">// Stats.</span>
      <span class="kt">size_t</span> <span class="n">total_blocks_</span><span class="p">;</span>
      <span class="kt">size_t</span> <span class="n">total_code_blocks_</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="p">}</span>  <span class="c1">// namespace transforms</span>
    <span class="p">}</span>  <span class="c1">// namespace instrument</span>

    <span class="cp">#endif  </span><span class="c1">// SYZYGY_INSTRUMENT_TRANSFORMS_DOARE_TRANSFORMS_H_</span>
</pre></div>


<p>After declaring it, the interesting part for us is to have a look at the <code>OnBlock</code> method:</p>
<div class="highlight"><pre><span></span>    <span class="kt">bool</span> <span class="n">CallGraphAnalysis</span><span class="o">::</span><span class="n">OnBlock</span><span class="p">(</span><span class="k">const</span> <span class="n">TransformPolicyInterface</span><span class="o">*</span> <span class="n">policy</span><span class="p">,</span>
                                    <span class="n">BlockGraph</span><span class="o">*</span> <span class="n">block_graph</span><span class="p">,</span>
                                    <span class="n">Block</span><span class="o">*</span> <span class="n">block</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">total_blocks_</span><span class="o">++</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">BlockGraph</span><span class="o">::</span><span class="n">CODE_BLOCK</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">attributes</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">BlockGraph</span><span class="o">::</span><span class="n">GAP_BLOCK</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

      <span class="n">VLOG</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">__FUNCTION__</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;main&quot;</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">main_block_</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="c1">// Walk the referrers of this block.</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">referrer</span> <span class="p">:</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">referrers</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">Block</span><span class="o">*</span> <span class="n">referrer_block</span><span class="p">(</span><span class="n">referrer</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>

        <span class="c1">// We are not interested in non-code referrers.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">referrer_block</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">BlockGraph</span><span class="o">::</span><span class="n">CODE_BLOCK</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">VLOG</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">referrer_block</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; -&gt; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">();</span>

        <span class="c1">// Keep track of the relation between the block &amp; its referrer.</span>
        <span class="n">edges_</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">referrer_block</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="n">total_code_blocks_</span><span class="o">++</span><span class="p">;</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p>The first step of the method is to make sure that the Block we are dealing with is a block we want to analyze. As I have explained before, Blocks are not exclusive code Blocks. That is the reason why we check the type of the block to only accepts code Blocks. Another type of Block that syzygy artificially creates (it has no existence in the image being analyzed) is called a <code>GAP_BLOCK</code>; which is basically a block that fills a gap in the address space. For that reason we also skip those blocks.</p>
<p>At this point we have a code Block and we can start to mine whatever information needed: name, size, referrers, etc. As the thing we are mostly interested about is the relationships between the code Blocks, we have to walk the referrers. The only thing to be wary about is to also exclude data Blocks (a function pointer table would be a data Block referencing a code Block for example) there. After this minor filtering we can just add the two pointers into the container.</p>
<p>I am sure at this stage you are interested in compiling it, and get it to run on a binary. To do that we need to add the <em>plumbing</em> necessary to surface it to <code>instrument.exe</code> tool. First thing you need is an <code>instrumenter</code>, we declare it in <code>doare_instrumenter.h</code> and define it in <code>doare_instrumenter.cc</code> in the <code>syzygy/instrument/instrumenters</code> directory:</p>
<div class="highlight"><pre><span></span>    D:\syzygy\src&gt;git status
    On branch dev-doare1
    Changes to be committed:
      (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

            new file:   syzygy/instrument/instrumenters/doare_instrumenter.cc
            new file:   syzygy/instrument/instrumenters/doare_instrumenter.h
</pre></div>


<p>An instrumenter is basically a class that encapsulate the configuration and the invocation of one or several transforms. The instrumenter can receive options passed by the application, thus can set configuration flags when invoking the transforms, etc. You could imagine parsing a configuration file here, or doing any preparation needed by your transform. Then, the instrumenter registers the transform against the <code>Relinker</code> object (a bit like the pass manager in LLVM if you want to think about it this way).</p>
<p>Anyway, as our transform is trivial we basically don't need any of this "preparation"; so let's settle for the least required:</p>
<div class="highlight"><pre><span></span>    <span class="c1">// Axel &#39;0vercl0k&#39; Souchet - 26 Aug 2017</span>

    <span class="cp">#ifndef SYZYGY_INSTRUMENT_INSTRUMENTERS_DOARE_INSTRUMENTER_H_</span>
    <span class="cp">#define SYZYGY_INSTRUMENT_INSTRUMENTERS_DOARE_INSTRUMENTER_H_</span>

    <span class="cp">#include</span> <span class="cpf">&quot;base/command_line.h&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;syzygy/instrument/instrumenters/instrumenter_with_agent.h&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;syzygy/instrument/transforms/doare_transforms.h&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;syzygy/pe/pe_relinker.h&quot;</span><span class="cp"></span>

    <span class="k">namespace</span> <span class="n">instrument</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">instrumenters</span> <span class="p">{</span>

    <span class="k">class</span> <span class="nc">DoareInstrumenter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">InstrumenterWithRelinker</span> <span class="p">{</span>
     <span class="k">public</span><span class="o">:</span>
      <span class="k">typedef</span> <span class="n">InstrumenterWithRelinker</span> <span class="n">Super</span><span class="p">;</span>

      <span class="n">DoareInstrumenter</span><span class="p">()</span> <span class="o">:</span> <span class="n">Super</span><span class="p">()</span> <span class="p">{}</span>

      <span class="c1">// From InstrumenterWithRelinker</span>
      <span class="kt">bool</span> <span class="n">InstrumentPrepare</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
      <span class="kt">bool</span> <span class="nf">InstrumentImpl</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
      <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">InstrumentationMode</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

     <span class="k">private</span><span class="o">:</span>
      <span class="c1">// The transform for this agent.</span>
      <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">instrument</span><span class="o">::</span><span class="n">transforms</span><span class="o">::</span><span class="n">CallGraphAnalysis</span><span class="o">&gt;</span>
          <span class="n">transformer_callgraph_</span><span class="p">;</span>

      <span class="n">DISALLOW_COPY_AND_ASSIGN</span><span class="p">(</span><span class="n">DoareInstrumenter</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="p">}</span>  <span class="c1">// namespace instrumenters</span>
    <span class="p">}</span>  <span class="c1">// namespace instrument</span>

    <span class="cp">#endif  </span><span class="c1">// SYZYGY_INSTRUMENT_INSTRUMENTERS_DOARE_INSTRUMENTER_H_</span>
</pre></div>


<p>The <code>InstrumentPrepare</code> method is where the instrumenter registers the transform against the relinker object:</p>
<div class="highlight"><pre><span></span>    <span class="c1">// Axel &#39;0vercl0k&#39; Souchet - 26 Aug 2017</span>

    <span class="cp">#include</span> <span class="cpf">&quot;syzygy/instrument/instrumenters/doare_instrumenter.h&quot;</span><span class="cp"></span>

    <span class="cp">#include</span> <span class="cpf">&quot;base/logging.h&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;base/values.h&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;syzygy/application/application.h&quot;</span><span class="cp"></span>

    <span class="k">namespace</span> <span class="n">instrument</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">instrumenters</span> <span class="p">{</span>

    <span class="kt">bool</span> <span class="n">DoareInstrumenter</span><span class="o">::</span><span class="n">InstrumentPrepare</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">DoareInstrumenter</span><span class="o">::</span><span class="n">InstrumentImpl</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">transformer_callgraph_</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">instrument</span><span class="o">::</span><span class="n">transforms</span><span class="o">::</span><span class="n">CallGraphAnalysis</span><span class="p">());</span>

      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">relinker_</span><span class="o">-&gt;</span><span class="n">AppendTransform</span><span class="p">(</span><span class="n">transformer_callgraph_</span><span class="p">.</span><span class="n">get</span><span class="p">()))</span> <span class="p">{</span>
        <span class="n">LOG</span><span class="p">(</span><span class="n">ERROR</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;AppendTransform failed.&quot;</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">DoareInstrumenter</span><span class="o">::</span><span class="n">InstrumentationMode</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="s">&quot;Diary of a reverse engineer&quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">}</span>  <span class="c1">// namespace instrumenters</span>
    <span class="p">}</span>  <span class="c1">// namespace instrument</span>
</pre></div>


<p>Like before, we also need to add those two files in the <code>instrument.gyp</code> file and regenerate the Ninja project files via the <code>gclient runhooks</code> command:</p>
<div class="highlight"><pre><span></span>    D:\syzygy\src&gt;git diff syzygy/instrument/instrument.gyp
    diff --git a/syzygy/instrument/instrument.gyp b/syzygy/instrument/instrument.gyp
    index 464c5566..c0eceb87 100644
    --- a/syzygy/instrument/instrument.gyp
    +++ b/syzygy/instrument/instrument.gyp
    @@ -36,6 +36,8 @@
             &#39;instrumenters/bbentry_instrumenter.h&#39;,
             &#39;instrumenters/coverage_instrumenter.cc&#39;,
             &#39;instrumenters/coverage_instrumenter.h&#39;,
    +        &#39;instrumenters/doare_instrumenter.h&#39;,
    +        &#39;instrumenters/doare_instrumenter.cc&#39;,
             &#39;instrumenters/entry_call_instrumenter.cc&#39;,
             &#39;instrumenters/entry_call_instrumenter.h&#39;,
             &#39;instrumenters/entry_thunk_instrumenter.cc&#39;,
    @@ -68,6 +70,8 @@
             &#39;transforms/branch_hook_transform.h&#39;,
             &#39;transforms/coverage_transform.cc&#39;,
             &#39;transforms/coverage_transform.h&#39;,
    +        &#39;transforms/doare_transforms.cc&#39;,
    +        &#39;transforms/doare_transforms.h&#39;,
             &#39;transforms/entry_call_transform.cc&#39;,
             &#39;transforms/entry_call_transform.h&#39;,
             &#39;transforms/entry_thunk_transform.cc&#39;,
</pre></div>


<p>The last step for us is to surface our instrumenter to the main of the application. I just add a mode called <code>doare</code> that you can set via the <code>--mode</code> switch, and if the flag is specified it instantiates the newly born <code>DoareInstrumenter</code>.</p>
<div class="highlight"><pre><span></span>    D:\syzygy\src&gt;git diff syzygy/instrument/instrument_app.cc
    diff --git a/syzygy/instrument/instrument_app.cc b/syzygy/instrument/instrument_app.cc
    index 72bb40b8..c54258d8 100644
    --- a/syzygy/instrument/instrument_app.cc
    +++ b/syzygy/instrument/instrument_app.cc
    @@ -29,6 +29,7 @@
     #include &quot;syzygy/instrument/instrumenters/bbentry_instrumenter.h&quot;
     #include &quot;syzygy/instrument/instrumenters/branch_instrumenter.h&quot;
     #include &quot;syzygy/instrument/instrumenters/coverage_instrumenter.h&quot;
    +#include &quot;syzygy/instrument/instrumenters/doare_instrumenter.h&quot;
     #include &quot;syzygy/instrument/instrumenters/entry_call_instrumenter.h&quot;
     #include &quot;syzygy/instrument/instrumenters/entry_thunk_instrumenter.h&quot;
     #include &quot;syzygy/instrument/instrumenters/flummox_instrumenter.h&quot;
    @@ -41,7 +42,7 @@ static const char kUsageFormatStr[] =
         &quot;Usage: %ls [options]\n&quot;
         &quot;  Required arguments:\n&quot;
         &quot;    --input-image=&lt;path&gt; The input image to instrument.\n&quot;
    -    &quot;    --mode=afl|asan|bbentry|branch|calltrace|coverage|flummox|profile\n&quot;
    +    &quot;    --mode=afl|asan|bbentry|branch|calltrace|coverage|doare|flummox|profile\n&quot;
         &quot;                            Specifies which instrumentation mode is to\n&quot;
         &quot;                            be used. If this is not specified it is\n&quot;
         &quot;                            equivalent to specifying --mode=calltrace\n&quot;
    @@ -192,6 +193,8 @@ bool InstrumentApp::ParseCommandLine(const base::CommandLine* cmd_line) {
               instrumenters::EntryThunkInstrumenter::CALL_TRACE));
         } else if (base::LowerCaseEqualsASCII(mode, &quot;coverage&quot;)) {
           instrumenter_.reset(new instrumenters::CoverageInstrumenter());
    +    } else if (base::LowerCaseEqualsASCII(mode, &quot;doare&quot;)) {
    +      instrumenter_.reset(new instrumenters::DoareInstrumenter());
         } else if (base::LowerCaseEqualsASCII(mode, &quot;flummox&quot;)) {
           instrumenter_.reset(new instrumenters::FlummoxInstrumenter());
         } else if (base::LowerCaseEqualsASCII(mode, &quot;profile&quot;)) {
</pre></div>


<p>This should be it! Recompiling the <code>instrument</code> project should be enough to be able to invoke the transform and see some of our debug messages:</p>
<div class="highlight"><pre><span></span>    D:\Downloads\syzygy\src&gt;ninja -C out\Release instrument
    ninja: Entering directory `out\Release&#39;
    [4/4] LINK_EMBED instrument.exe
    D:\Downloads\syzygy\src&gt;out\Release\instrument.exe --input-image=out\Release\instrument.exe --output-image=nul --mode=doare --verbose
    [...]
    [0902/120452:VERBOSE1:doare_transforms.cc(22)] instrument::transforms::CallGraphAnalysis::OnBlock: block_graph::BlockGraph::AddressSpace::GetBlockByAddress
    [0902/120452:VERBOSE1:doare_transforms.cc(36)] pe::`anonymous namespace&#39;::Decompose -&gt; block_graph::BlockGraph::AddressSpace::GetBlockByAddress
    [0902/120452:VERBOSE1:doare_transforms.cc(36)] pe::`anonymous namespace&#39;::Decompose -&gt; block_graph::BlockGraph::AddressSpace::GetBlockByAddress
    [...]
</pre></div>


<h3 id="visualize-it">Visualize it?</h3>
<p>As I was writing this I figured it might be worth to spend a bit of time trying to visualize this network to make it more attractive for the readers. So I decided to use <a href="http://visjs.org/network_examples.html">visjs</a> and the <code>Post</code> callback to output the call-graph in a way visjs would understand:</p>
<div class="highlight"><pre><span></span>    <span class="kt">bool</span> <span class="n">CallGraphAnalysis</span><span class="o">::</span><span class="n">PostBlockGraphIteration</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">TransformPolicyInterface</span><span class="o">*</span> <span class="n">policy</span><span class="p">,</span>
        <span class="n">BlockGraph</span><span class="o">*</span> <span class="n">block_graph</span><span class="p">,</span>
        <span class="n">Block</span><span class="o">*</span> <span class="n">header_block</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">VLOG</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;      Blocks found: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">total_blocks_</span><span class="p">;</span>
      <span class="n">VLOG</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; Code Blocks found: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">total_code_blocks_</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">main_block_</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">LOG</span><span class="p">(</span><span class="n">ERROR</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;A &#39;main&#39; block is mandatory.&quot;</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="c1">// Now we walk the graph from the &#39;main&#39; block, with a BFS algorithm.</span>
      <span class="kt">uint32_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Block</span><span class="o">*</span><span class="p">,</span> <span class="n">Block</span><span class="o">*&gt;&gt;</span> <span class="n">selected_edges</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Block</span><span class="o">*</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">selected_nodes</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Block</span><span class="o">*</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">selected_nodes_levels</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Block</span><span class="o">*&gt;</span> <span class="n">nodes_to_inspect</span><span class="p">{</span><span class="n">main_block_</span><span class="p">};</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">nodes_to_inspect</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Make a copy of the node to inspect so that we can iterate</span>
        <span class="c1">// over them.</span>
        <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Block</span><span class="o">*&gt;</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">nodes_to_inspect</span><span class="p">;</span>

        <span class="c1">// The node selected to be inspected in the next iteration of</span>
        <span class="c1">// the loop will be added in this set.</span>
        <span class="n">nodes_to_inspect</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>

        <span class="c1">// Go through every nodes to find to what nodes they are connected</span>
        <span class="c1">// to.</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">node_to_inspect</span> <span class="p">:</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// Assign an index and a level to the node.</span>
          <span class="n">selected_nodes</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">node_to_inspect</span><span class="p">,</span> <span class="n">idx</span><span class="o">++</span><span class="p">);</span>
          <span class="n">selected_nodes_levels</span><span class="p">[</span><span class="n">node_to_inspect</span><span class="p">]</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>

          <span class="c1">// Now let&#39;s iterate through the edges to find to what nodes, the current</span>
          <span class="c1">// one is connected to.</span>
          <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">edge</span> <span class="p">:</span> <span class="n">edges_</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// We are interested to find edges connected to the current node.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">first</span> <span class="o">!=</span> <span class="n">node_to_inspect</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// Get the connected node and make sure we haven&#39;t handled it already.</span>
            <span class="n">Block</span><span class="o">*</span> <span class="n">to_block</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">selected_nodes</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">to_block</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">selected_nodes</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">to_block</span><span class="p">,</span> <span class="n">idx</span><span class="o">++</span><span class="p">);</span>
            <span class="n">selected_nodes_levels</span><span class="p">[</span><span class="n">to_block</span><span class="p">]</span> <span class="o">=</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

            <span class="c1">// If it&#39;s a</span>
            <span class="n">selected_edges</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">node_to_inspect</span><span class="p">,</span> <span class="n">to_block</span><span class="p">);</span>

            <span class="c1">// We need to analyze this block at the next iteration (level + 1).</span>
            <span class="n">nodes_to_inspect</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">to_block</span><span class="p">);</span>
          <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// Bump the level as we finished analyzing the nodes we wanted to inspect.</span>
        <span class="n">level</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;var nodes = new vis.DataSet([&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">node</span> <span class="p">:</span> <span class="n">selected_nodes</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Block</span><span class="o">*</span> <span class="n">block</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
        <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">compiland_path</span> <span class="o">=</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">compiland_name</span><span class="p">().</span><span class="n">c_str</span><span class="p">();</span>
        <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">compiland_name</span> <span class="o">=</span> <span class="n">strrchr</span><span class="p">(</span><span class="n">compiland_path</span><span class="p">,</span> <span class="sc">&#39;\\&#39;</span><span class="p">);</span>
        <span class="kt">char</span> <span class="n">description</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">compiland_name</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">compiland_name</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">compiland_name</span> <span class="o">=</span> <span class="s">&quot;Unknown&quot;</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">uint32_t</span> <span class="n">level</span> <span class="o">=</span> <span class="n">selected_nodes_levels</span><span class="p">[</span><span class="n">block</span><span class="p">];</span>
        <span class="n">_snprintf_s</span><span class="p">(</span><span class="n">description</span><span class="p">,</span> <span class="n">ARRAYSIZE</span><span class="p">(</span><span class="n">description</span><span class="p">),</span> <span class="n">_TRUNCATE</span><span class="p">,</span>
                    <span class="s">&quot;RVA: %p&lt;br&gt;Size: %d&lt;br&gt;Level: %d&lt;br&gt;Compiland: %s&quot;</span><span class="p">,</span>
                    <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">().</span><span class="n">value</span><span class="p">(),</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">(),</span> <span class="n">level</span><span class="p">,</span>
                    <span class="n">compiland_name</span><span class="p">);</span>

        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  { id : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, label : </span><span class="se">\&quot;</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span>
                  <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">, &quot;</span>
                  <span class="o">&lt;&lt;</span> <span class="s">&quot;title : &#39;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">description</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&#39;, group : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">level</span>
                  <span class="o">&lt;&lt;</span> <span class="s">&quot;, value : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; },&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;]);&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span>
                <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;var edges = new vis.DataSet([&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">edge</span> <span class="p">:</span> <span class="n">selected_edges</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  { from : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">selected_nodes</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">first</span><span class="p">)</span>
                  <span class="o">&lt;&lt;</span> <span class="s">&quot;, to : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">selected_nodes</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; },&quot;</span>
                  <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;]);&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p>The above function basically starts to walk the network from the <code>main</code> function and do a BFS algorithm (that allows us to define <em>levels</em> for each Block). It then outputs two sets of data: the nodes, and the edges.</p>
<p>If you would like to check out the result I have uploaded an interactive network graph here: <a href="/images/binary_rewriting_with_syzygy/network.afl-fuzz.exe.html">network.afl-fuzz.exe.html</a>. Even though it sounds pretty useless, it looks pretty cool!</p>
<h2 id="securitycookiecheckhooktransform">SecurityCookieCheckHookTransform</h2>
<h3 id="the-problem">The problem</h3>
<p>The idea for this transform came back when I was playing around with <a href="https://github.com/ivanfratric/winafl">WinAFL</a>; I encountered a case where one of the test-case triggered a <a href="https://msdn.microsoft.com/en-us/library/8dbf701c.aspx">/GS</a> violation in a harness program I was fuzzing. Buffer security checks are a set of compiler and runtime instrumentation aiming at detecting and preventing the exploitation of stack-based buffer overflows. A cookie is placed on the stack by the prologue of the protected function in between the local variables of the stack-frame and the saved stack pointer / saved instruction pointer. The compiler instruments the code so that before the function returns, it invokes a check function (called <code>__security_check_cookie</code>) that ensure the integrity of the cookie.</p>
<div class="highlight"><pre><span></span>    ; void __fastcall __security_check_cookie(unsigned int cookie)
    @__security_check_cookie@4 proc near
    cookie= dword ptr -4
       cmp     ecx, ___security_cookie
       repne jnz short failure
       repne retn
    failure:
       repne jmp ___report_gsfailure
    @__security_check_cookie@4 endp
</pre></div>


<p>If the cookie matches the secret, everything is fine, the function returns and life goes on. If it does not, it means something overwrote it and as a result the process needs to be killed. The way the check function achieves this is by raising an exception that the process cannot even catch itself; which makes sense if you think about it as you don't want an attacker to be able to hijack the exception.</p>
<p>On recent version of Windows, this is achieved via a <a href="http://www.alex-ionescu.com/?p=69">fail-fast exception</a> or by invoking [UnhandledExceptionFilter](https://msdn.microsoft.com/en-us/library/windows/desktop/ms681401(v=vs.85).aspx) (after forcing the top level exception filter to 0) and terminating the process (done by <code>__raise_securityfailure</code>).</p>
<div class="highlight"><pre><span></span>    ; void __cdecl __raise_securityfailure(_EXCEPTION_POINTERS *const exception_pointers)
    ___raise_securityfailure proc near
    exception_pointers= dword ptr  8
       push    ebp
       mov     ebp, esp
       push    0
       call    ds:__imp__SetUnhandledExceptionFilter@4
       mov     eax, [ebp+exception_pointers]
       push    eax
       call    ds:__imp__UnhandledExceptionFilter@4
       push    0C0000409h
       call    ds:__imp__GetCurrentProcess@0
       push    eax
       call    ds:__imp__TerminateProcess@8
       pop     ebp
       retn
    ___raise_securityfailure endp
</pre></div>


<p>Funny enough - if this sounds familiar - turns out I have encountered this very problem a while back and you can read the story here: <a href="http://doar-e.github.io/blog/2013/10/12/having-a-look-at-the-windows-userkernel-exceptions-dispatcher/">Having a Look at the Windows' User/Kernel Exceptions Dispatcher</a>.</p>
<p>The thing is when you are fuzzing, this is exactly the type of thing you would like to be aware of. WinAFL uses an in-process exception handler to do the crash monitoring part which means that this type of crashes would not go through the crash monitoring. Bummer.</p>
<h3 id="the-solution">The solution</h3>
<p>I started evaluating syzygy with this simple task: making the program crash with a <em>regular</em> exception (that can get caught by an in-process exception handler). I figured it would be a walk in the park, as I basically needed to apply very little transformation to the binary to make this work.</p>
<p>First step is to define a transform as in the previous example. This time I subclass <code>NamedBlockGraphTransformImpl</code> which wants me to implement a <code>TransformBlockGraph</code> method that receives: a transform policy (used to make decision before applying transformation), the graph (block_graph) and a data Block that represents the PE header of our image (header_block):</p>
<div class="highlight"><pre><span></span>    <span class="k">class</span> <span class="nc">SecurityCookieCheckHookTransform</span>
        <span class="o">:</span> <span class="k">public</span> <span class="n">block_graph</span><span class="o">::</span><span class="n">transforms</span><span class="o">::</span><span class="n">NamedBlockGraphTransformImpl</span><span class="o">&lt;</span>
              <span class="n">SecurityCookieCheckHookTransform</span><span class="o">&gt;</span> <span class="p">{</span>
     <span class="k">public</span><span class="o">:</span>
      <span class="n">SecurityCookieCheckHookTransform</span><span class="p">()</span> <span class="p">{}</span>

      <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">kTransformName</span><span class="p">[];</span>
      <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">kReportGsFailure</span><span class="p">[];</span>
      <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">kSyzygyReportGsFailure</span><span class="p">[];</span>
      <span class="k">static</span> <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">kInvalidUserAddress</span><span class="p">;</span>

      <span class="c1">// BlockGraphTransformInterface implementation.</span>
      <span class="kt">bool</span> <span class="nf">TransformBlockGraph</span><span class="p">(</span><span class="k">const</span> <span class="n">TransformPolicyInterface</span><span class="o">*</span> <span class="n">policy</span><span class="p">,</span>
                               <span class="n">BlockGraph</span><span class="o">*</span> <span class="n">block_graph</span><span class="p">,</span>
                               <span class="n">BlockGraph</span><span class="o">::</span><span class="n">Block</span><span class="o">*</span> <span class="n">header_block</span><span class="p">)</span> <span class="k">final</span><span class="p">;</span>
    <span class="p">};</span>
</pre></div>


<p>As I explained a bit earlier, the BlockGraph is the top level container of Blocks. This is what I walk through in order to find our Block of interest. The Block of interest for us has the name <code>__report_gsfailure</code>:</p>
<div class="highlight"><pre><span></span>    <span class="n">BlockGraph</span><span class="o">::</span><span class="n">Block</span><span class="o">*</span> <span class="n">report_gsfailure</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">BlockGraph</span><span class="o">::</span><span class="n">BlockMap</span><span class="o">&amp;</span> <span class="n">blocks</span> <span class="o">=</span> <span class="n">block_graph</span><span class="o">-&gt;</span><span class="n">blocks_mutable</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">block</span> <span class="p">:</span> <span class="n">blocks</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">name</span><span class="p">());</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">kReportGsFailure</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">report_gsfailure</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">report_gsfailure</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">LOG</span><span class="p">(</span><span class="n">ERROR</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Could not find &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">kReportGsFailure</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;.&quot;</span><span class="p">;</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p>The transform tries to be careful by checking that the Block only has a single referrer: which should be the <code>__security_cookie_check</code> Block. If not, I gracefully exit and don't apply the transformation as I am not sure with what I am dealing with.</p>
<div class="highlight"><pre><span></span>    <span class="k">if</span> <span class="p">(</span><span class="n">report_gsfailure</span><span class="o">-&gt;</span><span class="n">referrers</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// We bail out if we don&#39;t have a single referrer as the only</span>
      <span class="c1">// expected referrer is supposed to be __security_cookie_check.</span>
      <span class="c1">// If there is more than one, we would rather bail out than take</span>
      <span class="c1">// a chance at modifying the behavior of the PE image.</span>
      <span class="n">LOG</span><span class="p">(</span><span class="n">ERROR</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Only a single referrer to &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">kReportGsFailure</span>
                 <span class="o">&lt;&lt;</span> <span class="s">&quot; is expected.&quot;</span><span class="p">;</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p>At this point, I create a new Block that has only a single instruction designed to trigger a fault every time; to do so I can even use the basic Intel assembler integrated in syzygy. After this, I place this new Block inside the <code>.text</code> section the image (tracked by the BlockGraph as mentioned earlier).</p>
<div class="highlight"><pre><span></span>    <span class="n">BlockGraph</span><span class="o">::</span><span class="n">Section</span><span class="o">*</span> <span class="n">section_text</span> <span class="o">=</span> <span class="n">block_graph</span><span class="o">-&gt;</span><span class="n">FindOrAddSection</span><span class="p">(</span>
        <span class="n">pe</span><span class="o">::</span><span class="n">kCodeSectionName</span><span class="p">,</span> <span class="n">pe</span><span class="o">::</span><span class="n">kCodeCharacteristics</span><span class="p">);</span>

    <span class="c1">// All of the below is needed to build the instrumentation via the assembler.</span>
    <span class="n">BasicBlockSubGraph</span> <span class="n">bbsg</span><span class="p">;</span>
    <span class="n">BasicBlockSubGraph</span><span class="o">::</span><span class="n">BlockDescription</span><span class="o">*</span> <span class="n">block_desc</span> <span class="o">=</span> <span class="n">bbsg</span><span class="p">.</span><span class="n">AddBlockDescription</span><span class="p">(</span>
        <span class="n">kSyzygyReportGsFailure</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="n">BlockGraph</span><span class="o">::</span><span class="n">CODE_BLOCK</span><span class="p">,</span>
        <span class="n">section_text</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">BasicCodeBlock</span><span class="o">*</span> <span class="n">bb</span> <span class="o">=</span> <span class="n">bbsg</span><span class="p">.</span><span class="n">AddBasicCodeBlock</span><span class="p">(</span><span class="n">kSyzygyReportGsFailure</span><span class="p">);</span>
    <span class="n">block_desc</span><span class="o">-&gt;</span><span class="n">basic_block_order</span><span class="p">.</span><span class="n">pushf_back</span><span class="p">(</span><span class="n">bb</span><span class="p">);</span>
    <span class="n">BasicBlockAssembler</span> <span class="nf">assm</span><span class="p">(</span><span class="n">bb</span><span class="o">-&gt;</span><span class="n">instructions</span><span class="p">().</span><span class="n">begin</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">bb</span><span class="o">-&gt;</span><span class="n">instructions</span><span class="p">());</span>
    <span class="n">assm</span><span class="p">.</span><span class="n">mov</span><span class="p">(</span><span class="n">Operand</span><span class="p">(</span><span class="n">Displacement</span><span class="p">(</span><span class="n">kInvalidUserAddress</span><span class="p">)),</span> <span class="n">assm</span><span class="o">::</span><span class="n">eax</span><span class="p">);</span>

    <span class="c1">// Condense into a block.</span>
    <span class="n">BlockBuilder</span> <span class="nf">block_builder</span><span class="p">(</span><span class="n">block_graph</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block_builder</span><span class="p">.</span><span class="n">Merge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bbsg</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">LOG</span><span class="p">(</span><span class="n">ERROR</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Failed to build &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">kSyzygyReportGsFailure</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; block.&quot;</span><span class="p">;</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">DCHECK_EQ</span><span class="p">(</span><span class="mi">1u</span><span class="p">,</span> <span class="n">block_builder</span><span class="p">.</span><span class="n">new_blocks</span><span class="p">().</span><span class="n">size</span><span class="p">());</span>
</pre></div>


<p>Finally, I update all the referrers to point to our new Block, and remove the <code>__report_gsfailure</code> Block as it is effectively now dead-code:</p>
<div class="highlight"><pre><span></span>    <span class="c1">// Transfer the referrers to the new block, and delete the old one.</span>
    <span class="n">BlockGraph</span><span class="o">::</span><span class="n">Block</span><span class="o">*</span> <span class="n">syzygy_report_gsfailure</span> <span class="o">=</span>
        <span class="n">block_builder</span><span class="p">.</span><span class="n">new_blocks</span><span class="p">().</span><span class="n">front</span><span class="p">();</span>
    <span class="n">report_gsfailure</span><span class="o">-&gt;</span><span class="n">TransferReferrers</span><span class="p">(</span>
        <span class="mi">0</span><span class="p">,</span> <span class="n">syzygy_report_gsfailure</span><span class="p">,</span>
        <span class="n">BlockGraph</span><span class="o">::</span><span class="n">Block</span><span class="o">::</span><span class="n">kTransferInternalReferences</span><span class="p">);</span>

    <span class="n">report_gsfailure</span><span class="o">-&gt;</span><span class="n">RemoveAllReferences</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block_graph</span><span class="o">-&gt;</span><span class="n">RemoveBlock</span><span class="p">(</span><span class="n">report_gsfailure</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">LOG</span><span class="p">(</span><span class="n">ERROR</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Removing &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">kReportGsFailure</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; failed.&quot;</span><span class="p">;</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p>Here is what it looks like after our transformation:</p>
<div class="highlight"><pre><span></span>    ; void __fastcall __security_check_cookie(unsigned int cookie)
    @__security_check_cookie@4 proc near
    cookie = ecx
                    cmp     cookie, ___security_cookie
                    repne jnz short failure
                    repne retn
    failure:
                    repne jmp loc_426EE6 &lt;- our new __report_gsfailure block

    loc_426EE6:
                    mov     ds:0DEADBEEFh, eax
</pre></div>


<h3 id="one-does-not-simply-binary-rewrite">One does not simply binary rewrite</h3>
<p>It may look like an easy problem without any pitfall, but before settling down on the solution above I actually first tried to rewrite the <code>__security_check_cookie</code> function. I thought it would be cleaner and it was also very easy to do with syzygy. I had to create a new Block, and transfer the referrers to my new block and.. that was it!</p>
<p>Now it was working fine on a bunch of targets on various OSs: Windows 7, Windows 8, Windows 8.1, Windows 10. Until I started notice some instrumented binaries that would not even execute; the loader would not load the binary and I was left with some message box telling me the binary could not be loaded in memory: <code>STATUS_INVALID_IMAGE_FORMAT</code> or <code>0xc000007b</code>. This was pretty mysterious at first as the instrumented binary would run fine on Windows 7 but not on Windows 10. The instrumented binary also looked instrumented fine - the way I wanted it to be instrumented: all the callers of <code>__security_check_cookie</code> were now calling into my new function and nothing seemed off.</p>
<p>At this point, the only thing I knew was that the PE loader was not happy with the file; so that is where I started my investigation. After hours of back and forth between ntdll and the kernel I found that the CFG [LoadConfigDirectory.GuardCFFunctionTable](https://msdn.microsoft.com/en-us/library/windows/desktop/ms680547(v=vs.85).aspx) table (where the compiler puts all the valid indirect-call targets) embedded in binaries is expected to be <em>ordered</em> from low to high RVAs. I have also realized at this point that one of the referrer of my block was this CFG table, that would get fixed-up with the RVA of wherever the new block was placed by the binary rewriting framework. And of course, in some cases this RVA would end up being greater than the RVA right after in the table... upsetting the loader.</p>
<p><center><img alt="security_cookie_GuardCFFunctionTable.png" src="/images/binary_rewriting_with_syzygy/security_cookie_GuardCFFunctionTable.png"></center>
All of this to say that even though the framework is robust, binary rewriting can be hard when instrumenting unknown target that may make assumptions on the way their functions look, or how some part of the code / data is laid out, etc. So keep that in mind while playing :).</p>
<h1 id="last-words">Last words</h1>
<p>In this post I have introduced the syzygy framework, presented some of its strengths as well as limitations, and illustrated what can you do with it on two simple examples. I am hoping to be able to write a second post where I can talk a bit more of two other transforms I have designed to built the <a href="https://github.com/ivanfratric/winafl#statically-instrument-a-binary-via-syzygy">static instrumentation</a> mode of <a href="https://github.com/ivanfratric/winafl">WinAFL</a> and how every pieces work together. I would also like to try to see if I can't cook some obfuscation or something of the sort.</p>
<p>As usual you can find the codes on my github here: <a href="https://github.com/0vercl0k/stuffz/blob/master/syzygy/binary_rewriting_with_syzygy_pt._i.diff">stuffz/syzygy</a>.</p>
<p>If you can't wait for the next post, you can have already a look at <a href="https://github.com/google/syzygy/blob/master/syzygy/instrument/transforms/add_implicit_tls_transform.cc">add_implicit_tls_transform.cc</a> and <a href="https://github.com/google/syzygy/blob/master/syzygy/instrument/transforms/afl_transform.cc">afl_transform.cc</a>.</p>
<p>Last but not least, special shout-outs to my proofreader <a href="https://twitter.com/yrp604">yrp</a>.</p>
                </div><!-- /.entry-content -->
        </article>
</section>
        </div><!--/span-->
      </div><!--/row-->
      <hr>

      <footer style='background-color:#00000000'>
        <center>
          <address id="about">
                  Proudly powered by <a href="http://pelican.notmyidea.org/">Pelican <i class="icon-external-link"></i></a>,
                                  which takes great advantage of <a href="http://python.org">Python <i class="icon-external-link"></i></a>.
          </address><!-- /#about -->

          <p>The theme is from <a href="http://twitter.github.com/bootstrap/">Bootstrap from Twitter <i class="icon-external-link"></i></a>,
                     and <a href="http://fortawesome.github.com/Font-Awesome/">Font-Awesome <i class="icon-external-link"></i></a>, thanks!</p>
        </center>
      </footer>

    </div><!--/.fluid-container-->


    <script src="/theme/js/jquery-1.7.2.min.js"></script>
    <script src="/theme/js/bootstrap.min.js"></script>
  </body>
</html>