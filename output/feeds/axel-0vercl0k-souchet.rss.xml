<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Diary of a reverse-engineer - Axel "0vercl0k" Souchet</title><link>/</link><description></description><lastBuildDate>Thu, 17 May 2018 11:52:00 -0700</lastBuildDate><item><title>Breaking ledgerctf's AES white-box challenge</title><link>/blog/2018/05/17/breaking-ledgerctfs-aes-white-box-challenge/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;About a month ago, my mate &lt;a href="https://twitter.com/b0n0n"&gt;b0n0n&lt;/a&gt; was working on the &lt;a href="https://www.ledger.fr/ctf2018/"&gt;ledgerctf&lt;/a&gt; puzzles and challenged me to have a look at the &lt;em&gt;ctf2&lt;/em&gt; binary. I eventually did and this blogpost discusses the protection scheme and how I broke it. Before diving in though, here is a bit of background.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.ledger.fr/"&gt;ledger&lt;/a&gt; is a french security company funded in 2014 that is specialized in cryptography, cryptocurrencies and hardware. They recently put up online three different puzzles to celebrate the official launch of their &lt;a href="https://www.ledger.fr/bounty-program/"&gt;bug bounty program&lt;/a&gt;. The second challenge called &lt;em&gt;ctf2&lt;/em&gt; is the one we will be discussing today. &lt;em&gt;ctf2&lt;/em&gt; is an ELF64 binary that is available &lt;a href="https://drive.google.com/open?id=1UPLe3V5Jt3SMqZe4ZIFcnWydSqUyI4Ao"&gt;here&lt;/a&gt; for download (if you want to follow at home). The binary is about 11MB, written in C++ and even has symbols; great.&lt;/p&gt;
&lt;p&gt;Let's do it!&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Thu, 17 May 2018 11:52:00 -0700</pubDate><guid isPermaLink="false">tag:None,2018-05-17:/blog/2018/05/17/breaking-ledgerctfs-aes-white-box-challenge/</guid><category>reverse-engineering</category><category>ledgerctf</category><category>whitebox</category></item><item><title>beVX challenge on the operation table</title><link>/blog/2018/03/11/bevx-challenge-on-the-operation-table/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;About two weeks ago, my friend &lt;a href="https://twitter.com/mongobug"&gt;mongo&lt;/a&gt; challenged me to solve a reverse-engineering puzzle put up by the &lt;a href="https://blogs.securiteam.com/"&gt;SSD&lt;/a&gt; team for &lt;a href="https://www.offensivecon.org/"&gt;OffensiveCon2018&lt;/a&gt; (which is a security conference that took place in Berlin in February). The challenge binary is available for download &lt;a href="https://www.beyondsecurity.com/bevxcon/bevx-challenge-1"&gt;here&lt;/a&gt; and &lt;a href="https://twitter.com/SecuriTeam_SSD/status/964459126960066560"&gt;here is one of the original tweet&lt;/a&gt; advertising it.&lt;/p&gt;
&lt;p&gt;With this challenge, you are tasked to reverse-engineer a binary providing some sort of encryption service, and there is supposedly a private key (aka the flag) to retrieve. A remote server with the challenge running is also available for you to carry out your attack. This looked pretty interesting as it was different than the usual keygen-me type of reverse-engineering challenge.&lt;/p&gt;
&lt;p&gt;Unfortunately, I didn't get a chance to play with this while the remote server was up (the organizers took it down once they received the solutions of the three winners). However, cool thing is that you can easily manufacture your own server to play at home.. which is what I ended up doing.&lt;/p&gt;
&lt;p&gt;As I thought the challenge was cute enough, and that I would also like to write on a more regular basis, so here is a small write-up describing how I abused the server to get the private key out. Hope you don't find it too boring :-).&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Sun, 11 Mar 2018 17:22:00 -0700</pubDate><guid isPermaLink="false">tag:None,2018-03-11:/blog/2018/03/11/bevx-challenge-on-the-operation-table/</guid><category>reverse-engineering</category><category>beVX</category></item><item><title>Debugger data model, Javascript &amp; x64 exception handling</title><link>/blog/2017/12/01/debugger-data-model/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;The main goal of today's post is to show a bit more of what is now possible with the latest Windbg (currently branded &lt;a href="https://blogs.windows.com/buildingapps/2017/08/28/new-windbg-available-preview/"&gt;"WinDbg Preview"&lt;/a&gt; in the Microsoft store) and the time travel debugging tools that Microsoft released a few months ago. When these finally got released, a bit after &lt;a href="https://cppcon2017.sched.com/"&gt;cppcon2017&lt;/a&gt; this year, I expected a massive pick-up from the security / reverse-engineering industry with a bunch of posts, tools, scripts, etc. To my surprise, this has not happened yet so I have waited patiently for my vacation to write a little something about it myself. So, here goes!&lt;/p&gt;
&lt;p&gt;Obviously, one of the most &lt;em&gt;noticeable&lt;/em&gt; change in this debugger is the new UI.. but this is not something we will talk about. The &lt;em&gt;second&lt;/em&gt; big improvement is .. a decent scripting engine! Until recently, I always had to use &lt;a href="https://pykd.codeplex.com/"&gt;pyKD&lt;/a&gt; to write automation scripts. This has worked &lt;em&gt;fairly&lt;/em&gt; well for years, but I’m glad to move away from it and embrace the new extension model provided by Windbg &amp;amp; Javascript (yes, you read this right). One of the biggest pain point I’ve to deal with with pyKD (aside from the installation process!) is that you had to evaluate many commands and then parse their outputs to extract the bits and pieces you needed. Thankfully, the new &lt;em&gt;debugger data model&lt;/em&gt; solves this (or part of this anyway). The third new change is the integration of the time travel debugging (TTD) features discussed in this presentation: &lt;a href="https://cppcon2017.sched.com/event/Bgsj/time-travel-debugging-root-causing-bugs-in-commercial-scale-software"&gt;Time Travel Debugging: Root Causing Bugs in Commercial Scale Software
&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The goal of this post is to leverage all the nifty stuff we will learn to enumerate x64 &lt;a href="https://docs.microsoft.com/fr-fr/cpp/cpp/try-except-statement"&gt;try/except&lt;/a&gt; handlers in Javascript.&lt;/p&gt;
&lt;p&gt;So grab yourself a cup of fine coffee and read on :).&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Fri, 01 Dec 2017 06:59:00 -0800</pubDate><guid isPermaLink="false">tag:None,2017-12-01:/blog/2017/12/01/debugger-data-model/</guid><category>debugging</category><category>javascript</category><category>windbg</category><category>exception handling</category><category>seh</category><category>time-travel debugging</category><category>ttd</category></item><item><title>Binary rewriting with syzygy, Pt. I</title><link>/blog/2017/08/05/binary-rewriting-with-syzygy/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Binary instrumentation and analysis have been subjects that I have always found fascinating. At compile time via &lt;a href="http://doar-e.github.io/blog/2016/11/27/clang-and-passes/"&gt;clang&lt;/a&gt;, or at runtime with dynamic binary instrumentation frameworks like &lt;a href="https://software.intel.com/en-us/articles/pin-a-dynamic-binary-instrumentation-tool"&gt;Pin&lt;/a&gt; or &lt;a href="http://www.dynamorio.org/"&gt;DynamoRIO&lt;/a&gt;. One thing I have always looked for though, is a framework able to statically instrument a PE image. A framework designed a bit like &lt;a href="https://clang.llvm.org/"&gt;clang&lt;/a&gt; where you can write 'passes' doing various things: transformation of the image, analysis of code blocks, etc. Until a couple of months ago, I wasn't aware of any public and robust projects providing this capability (as in, able to instrument real-world scale programs like Chrome or similar).&lt;/p&gt;
&lt;p&gt;In this post (it's been a while I know!), I'll introduce the &lt;a href="https://github.com/google/syzygy"&gt;syzygy&lt;/a&gt; transformation tool chain with a focus on its &lt;a href="https://github.com/google/syzygy/tree/master/syzygy/instrument"&gt;instrumenter&lt;/a&gt;, and give an overview of the framework, its capabilities, its limitations, and how you can write transformations yourself. As examples, I'll walk through two simple examples: an analysis pass generating a call-graph, and a transformation pass rewriting the function &lt;code&gt;__report_gsfailure&lt;/code&gt; in &lt;a href="https://msdn.microsoft.com/en-us/library/8dbf701c.aspx"&gt;/GS&lt;/a&gt; protected binaries.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Sat, 05 Aug 2017 16:08:00 -0700</pubDate><guid isPermaLink="false">tag:None,2017-08-05:/blog/2017/08/05/binary-rewriting-with-syzygy/</guid><category>binary rewriting</category><category>syzygy</category><category>program analysis</category></item><item><title>Token capture via an llvm-based analysis pass</title><link>/blog/2016/11/27/clang-and-passes/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;About three years ago, the LLVM framework started to pique my interest for a lot of different reasons. This collection of industrial strength compiler technology, as &lt;a href="http://llvm.org/pubs/2008-10-04-ACAT-LLVM-Intro.pdf"&gt;Latner&lt;/a&gt; said in 2008, was designed in a very modular way. It also looked like it had a lot of interesting features that could be used in a lot of (different) domains: code-optimization (think &lt;a href="https://github.com/JonathanSalwan/Tigress_protection"&gt;deobfuscation&lt;/a&gt;), (architecture independent) &lt;a href="https://github.com/0vercl0k/articles/blob/master/Obfuscation%20of%20steel%20meet%20Kryptonite.pdf"&gt;code obfuscation&lt;/a&gt;, static code instrumentation (think &lt;a href="https://github.com/google/sanitizers/wiki"&gt;sanitizers&lt;/a&gt;), &lt;a href="http://clang-analyzer.llvm.org/index.html"&gt;static analysis&lt;/a&gt;, for runtime software exploitation mitigations (think &lt;a href="http://clang.llvm.org/docs/ControlFlowIntegrity.html"&gt;cfi&lt;/a&gt;, &lt;a href="http://clang.llvm.org/docs/SafeStack.html"&gt;safestack&lt;/a&gt;), power a fuzzing framework (think &lt;a href="http://llvm.org/docs/LibFuzzer.html"&gt;libFuzzer&lt;/a&gt;), ..you name it.&lt;/p&gt;
&lt;p&gt;A lot of the power that came with this giant library was partly because it would operate in mainly three stages, and you were free to hook your code in any of those: front-end, mid-end, back-end. Other strengths included: the high number of back-ends, the documentation, the C/C++ APIs, the community, ease of use compared to gcc (see below from kcc's &lt;a href="https://gcc.gnu.org/wiki/cauldron2012?action=AttachFile&amp;amp;do=get&amp;amp;target=kcc.pdf"&gt;presentation&lt;/a&gt;), etc.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="GCC from a newcomer's perspective" src="/images/token_capture_via_llvm_based_static_analysis_pass/llvmvsgcc.png"&gt;&lt;/center&gt;
The front-end part takes as input source code and generates LLVM IL code, the middle part operates on LLVM IL and finally the last one receives LLVM IL in order to output assembly code and or an executable file.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="Major components in a three phase compiler" src="/images/token_capture_via_llvm_based_static_analysis_pass/llvm_architecture.png"&gt;&lt;/center&gt;
In this post we will walk through a simple LLVM pass that does neither optimization, nor obfuscation; but acts more as a token finder for fuzzing purposes. &lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Sun, 27 Nov 2016 20:43:00 -0800</pubDate><guid isPermaLink="false">tag:None,2016-11-27:/blog/2016/11/27/clang-and-passes/</guid><category>fuzzing</category><category>clang</category><category>llvm</category><category>analysis pass</category><category>pass</category></item><item><title>Spotlight on an unprotected AES128 white-box implementation</title><link>/blog/2015/02/08/spotlight-on-an-unprotected-aes128-whitebox-implementation/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;I think it all began when I've worked on the &lt;a href="https://github.com/0vercl0k/stuffz/tree/master/NoSuchCon2013"&gt;NSC2013&lt;/a&gt; crackme made by &lt;a href="https://twitter.com/elvanderb"&gt;@elvanderb&lt;/a&gt;, long story short you had an AES128 heavily obfuscated white-box implementation to break. The thing was you could actually solve the challenge in different ways: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;the first one was the easiest one: you didn't need to know anything about white-box, crypto or even AES ; you could just see the function as a black-box &amp;amp; try to find "design flaws" in its inner-workings&lt;/li&gt;
&lt;li&gt;the elite way: this one involved to understand &amp;amp; recover the entire design of the white-box, then to identify design weaknesses that allows the challenger to directly attack &amp;amp; recover the encryption key. A really nice write-up has been recently written by &lt;a href="https://twitter.com/doegox"&gt;@doegox&lt;/a&gt;, check it out, really :): &lt;a href="http://wiki.yobi.be/wiki/NSC_Writeups"&gt;Oppida/NoSuchCon challenge&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The annoying thing is that you don't have a lot of understandable available C code on the web that implement such things, nevertheless you do have quite some nice academic references ; they are a really good resource to build your own.&lt;/p&gt;
&lt;p&gt;This post aims to present briefly, in a simple way what an AES white-box looks like, and to show how its design is important if you want to not have your encryption key extracted :). The implementation I'm going to talk about today is not my creation at all, I just followed the first part (might do another post talking about the second part? Who knows) of a really &lt;a href="https://github.com/0vercl0k/stuffz/raw/master/wbaes_attack/docs/a_tutorial_on_whitebox_aes.pdf"&gt;nice paper&lt;/a&gt; (even for non-mathematical / crypto guys like me!) written by James A. Muir.&lt;/p&gt;
&lt;p&gt;The idea is simple: we will start from a clean AES128 encryption function in plain C, we will modify it &amp;amp; transform it into a white-box implementation in several steps.
As usual, all the code are available on my github account; you are encourage to break &amp;amp; hack them!&lt;/p&gt;
&lt;p&gt;Of course, we will use this post to briefly present what is the white-box cryptography, what are the goals &amp;amp; why it's kind of cool.&lt;/p&gt;
&lt;p&gt;Before diving deep, here is the table of contents:&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Sun, 08 Feb 2015 22:59:00 -0800</pubDate><guid isPermaLink="false">tag:None,2015-02-08:/blog/2015/02/08/spotlight-on-an-unprotected-aes128-whitebox-implementation/</guid><category>obfuscation</category><category>white-box</category><category>practical cryptography</category><category>aes128</category><category>encryption</category></item><item><title>Dissection of Quarkslab's 2014 security challenge</title><link>/blog/2014/09/06/dissection-of-quarkslabs-2014-security-challenge/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;As the blog was a bit silent for quite some time, I figured it would be cool to put together a post ; so here it is folks, dig in!&lt;/p&gt;
&lt;p&gt;The French company &lt;a href="http://blog.quarkslab.com/you-like-python-security-challenge-and-traveling-win-a-free-ticket-to-hitb-kul.html"&gt;Quarkslab&lt;/a&gt; &lt;a href="https://twitter.com/quarkslab/status/507457671386394624"&gt;recently&lt;/a&gt; &lt;a href="https://twitter.com/HITBSecConf/status/507458788522094592"&gt;released&lt;/a&gt; a security challenge to win a free entrance to attend the upcoming &lt;a href="https://conference.hitb.org/hitbsecconf2014kul/"&gt;HITBSecConf&lt;/a&gt; conference in Kuala Lumpur from the 13th of October until the 16th.&lt;/p&gt;
&lt;p&gt;The challenge has been written by &lt;a href="http://blog.quarkslab.com/author/serge-guelton.html"&gt;Serge Guelton&lt;/a&gt;, a R&amp;amp;D engineer specialized in compilers/parallel computations. At the time of writing, already eight different people manage to solve the challenge, and one of the ticket seems to have been won by &lt;code&gt;hackedd&lt;/code&gt;, so congrats to him!&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="woot.png" src="/images/dissection_of_quarkslab_s_2014_security_challenge/woot.png"&gt;&lt;/center&gt;
According to the description of the challenge Python is heavily involved, which is a good thing for at least two reasons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;first because I already had &lt;a href="https://doar-e.github.io/blog/2014/04/17/deep-dive-into-pythons-vm-story-of-load_const-bug/"&gt;the occasion&lt;/a&gt; to look at its source code in the past,&lt;/li&gt;
&lt;li&gt;and because I so am a &lt;a href="https://github.com/0vercl0k/stuffz/tree/master/Python's%20internals"&gt;big fan of Python&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In this post I will describe how I tackled this problem, how I managed to solve it. And to make up for me being slow at solving it I tried to make it fairly detailed. &lt;/p&gt;
&lt;p&gt;At first it was supposed to be quite short though, but well..I decided to analyze fully the challenge even if it wasn't needed to find the key unfortunately, so it is a bit longer than expected :-).&lt;/p&gt;
&lt;p&gt;Anyway, sit down, make yourself at home and let me pour you a cup of tea before we begin :-).&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Sat, 06 Sep 2014 20:37:00 -0700</pubDate><guid isPermaLink="false">tag:None,2014-09-06:/blog/2014/09/06/dissection-of-quarkslabs-2014-security-challenge/</guid><category>python</category><category>virtual machine</category><category>reverse-engineering</category></item><item><title>Deep dive into Python's VM: Story of LOAD_CONST bug</title><link>/blog/2014/04/17/deep-dive-into-pythons-vm-story-of-load_const-bug/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;A year ago, I've written a Python script to leverage a bug in Python's virtual machine: the idea was to fully control the Python virtual processor and after that to instrument the VM to execute native codes. The &lt;a href="https://github.com/0vercl0k/stuffz/blob/master/Python's%20internals/python27_abuse_vm_to_execute_x86_code.py"&gt;python27_abuse_vm_to_execute_x86_code.py&lt;/a&gt; script wasn't really self-explanatory, so I believe only a few people actually took some time to understood what happened under the hood. The purpose of this post is to give you an explanation of the bug, how you can control the VM and how you can turn the bug into something that can be more useful. It's also a cool occasion to see how works the Python virtual machine from a low-level perspective: what we love so much right?&lt;/p&gt;
&lt;p&gt;But before going further, I just would like to clarify a couple of things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I haven't found this bug, this is quite old and &lt;strong&gt;known&lt;/strong&gt; by the Python developers (trading safety for performance), so don't panic this is &lt;strong&gt;not&lt;/strong&gt; a 0day or a new bug ; can be a cool CTF trick though&lt;/li&gt;
&lt;li&gt;Obviously, YES I know we can also "escape" the virtual machine with the &lt;a href="http://docs.python.org/2/library/ctypes.html"&gt;ctypes&lt;/a&gt; module ; but this is a feature not a bug. In addition, ctypes is always "removed"  from sandbox implementation in Python&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Also, keep in mind I will focus Python 2.7.5 x86 on Windows ; but obviously this is adaptable for other systems and architectures, so this is left as an exercise to the interested readers.
All right, let's move on to the first part: this one will focus the essentials about the VM, and Python objects.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Thu, 17 Apr 2014 23:22:00 -0700</pubDate><guid isPermaLink="false">tag:None,2014-04-17:/blog/2014/04/17/deep-dive-into-pythons-vm-story-of-load_const-bug/</guid><category>python</category><category>virtual machine</category></item><item><title>Having a look at the Windows' User/Kernel exceptions dispatcher</title><link>/blog/2013/10/12/having-a-look-at-the-windows-userkernel-exceptions-dispatcher/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;The purpose of this little post is to create a piece of code able to monitor exceptions raised in a process (a bit like &lt;a href="http://gynvael.coldwind.pl/"&gt;gynvael&lt;/a&gt;'s &lt;a href="http://gynvael.coldwind.pl/?id=148"&gt;ExcpHook&lt;/a&gt; but in userland), and to generate a report with information related to the exception. The other purpose is to have a look at the internals of course.&lt;/p&gt;
--Exception detected--
ExceptionRecord: 0x0028fa2c Context: 0x0028fa7c
Image Path: D:\Codes\The Sentinel\tests\divzero.exe
Command Line: ..\tests\divzero.exe divzero.exe
PID: 0x00000aac
Exception Code: 0xc0000094 (EXCEPTION_INT_DIVIDE_BY_ZERO)
Exception Address: 0x00401359
EAX: 0x0000000a EDX: 0x00000000 ECX: 0x00000001 EBX: 0x7ffde000
ESI: 0x00000000 EDI: 0x00000000 ESP: 0x0028fee0 EBP: 0x0028ff18
EIP: 0x00401359
EFLAGS: 0x00010246

Stack:
0x767bc265 0x54f3620f 0xfffffffe 0x767a0f5a 
0x767ffc59 0x004018b0 0x0028ff90 0x00000000

Disassembly:
00401359 (04) f77c241c                 IDIV DWORD [ESP+0x1c]
0040135d (04) 89442404                 MOV [ESP+0x4], EAX
00401361 (07) c7042424304000           MOV DWORD [ESP], 0x403024
00401368 (05) e833080000               CALL 0x401ba0
0040136d (05) b800000000               MOV EAX, 0x0
&lt;/pre&gt;


&lt;p&gt;That's why I divided this post in two big parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the first one will talk about Windows internals background required to understand how things work under the hood,&lt;/li&gt;
&lt;li&gt;the last one will talk about &lt;a href="http://research.microsoft.com/en-us/projects/detours/"&gt;&lt;em&gt;Detours&lt;/em&gt;&lt;/a&gt; and how to hook &lt;em&gt;ntdll!KiUserExceptionDispatcher&lt;/em&gt; toward our purpose. Basically, the library gives programmers a set of APIs to easily hook procedures. It also has a clean and readable documentation, so you should use it! It is usually used for that kind of things:&lt;/li&gt;
&lt;li&gt;Hot-patching bugs (no need to reboot),&lt;/li&gt;
&lt;li&gt;Tracing API calls (&lt;a href="http://www.rohitab.com/apimonitor"&gt;API Monitor&lt;/a&gt; like),&lt;/li&gt;
&lt;li&gt;Monitoring (a bit like our example),&lt;/li&gt;
&lt;li&gt;Pseudo-sandboxing (prevent API calls),&lt;/li&gt;
&lt;li&gt;etc.&lt;/li&gt;
&lt;/ul&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Sat, 12 Oct 2013 14:03:00 -0700</pubDate><guid isPermaLink="false">tag:None,2013-10-12:/blog/2013/10/12/having-a-look-at-the-windows-userkernel-exceptions-dispatcher/</guid><category>coding</category><category>hooking</category><category>windows internals</category></item><item><title>Breaking Kryptonite's obfuscation: a static analysis approach relying on symbolic execution</title><link>/blog/2013/09/16/breaking-kryptonites-obfuscation-with-symbolic-execution/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Kryptonite&lt;/em&gt; was a proof-of-concept I built to obfuscate codes at the LLVM intermediate representation level. The idea was to use semantic-preserving transformations in order to not break the original program. One of the main idea was for example to build a home-made 32 bits adder to replace the &lt;em&gt;add&lt;/em&gt; LLVM instruction. Instead of having a single asm instruction generated at the end of the pipeline, you will end up with a ton of assembly codes doing only an addition. If you never read my article, and you are interested in it here it is: &lt;a href="http://0vercl0k.tuxfamily.org/bl0g/?p=260"&gt;Obfuscation of steel: meet my Kryptonite&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="home-made-adder.png" src="/images/breaking_kryptonite_s_obfuscation_with_symbolic_execution/home-made-adder.png"&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;In this post I wanted to show you how we can manage to break that obfuscation with symbolic execution. We are going to write a really tiny symbolic execution engine with IDAPy, and we will use Z3Py to simplify all our equations. Note that a friend of mine &lt;a href="https://twitter.com/elvanderb"&gt;@elvanderb&lt;/a&gt; used a similar approach (more generic though) to simplify some parts of the &lt;a href="http://download.tuxfamily.org/overclokblog/Obfuscation%20of%20steel%3a%20meet%20my%20Kryptonite/binaries/"&gt;crackme&lt;/a&gt; ; but he didn't wanted to publish it, so here is my blog post about it!&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Mon, 16 Sep 2013 11:47:00 -0700</pubDate><guid isPermaLink="false">tag:None,2013-09-16:/blog/2013/09/16/breaking-kryptonites-obfuscation-with-symbolic-execution/</guid><category>reverse-engineering</category></item><item><title>Pinpointing heap-related issues: OllyDbg2 off-by-one story</title><link>/blog/2013/09/09/pinpointing-heap-related-issues-ollydbg2-off-by-one-story/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Yesterday afternoon, I was peacefully coding some stuff you know but I couldn't make my code working.
As usual, in those type of situations you fire up your debugger in order to understand what is going on under the hood.
That was a bit weird, to give you a bit of context I was doing some inline x86 assembly, and I've put on purpose an &lt;em&gt;int3&lt;/em&gt; just
before the piece of assembly code I thought was buggy. Once my file loaded in &lt;a href="http://ollydbg.de/version2.html"&gt;OllyDbg2&lt;/a&gt;, I hit &lt;em&gt;F9&lt;/em&gt; in order to reach quickly the &lt;em&gt;int3&lt;/em&gt; I've slipped into the inline assembly code. A bit of single-stepping, and &lt;strong&gt;BOOM&lt;/strong&gt; I got a nasty crash. It happens sometimes, and that's uncool.
Then, I relaunch my binary and try to reproduce the bug: same actions and &lt;strong&gt;BOOM&lt;/strong&gt; again. OK, this time it's cool, I got a reproducible crash in OllyDbg2.&lt;/p&gt;
&lt;p&gt;I like when things like that happens to me (remember the crashes I've found in OllyDbg/IDA here: &lt;a href="http://download.tuxfamily.org/overclokblog/PDB%20ain%27t%20PDD/0vercl0k_pdb_aint_pdd.pdf"&gt;PDB Ain't PDD&lt;/a&gt;), it's always a nice exercise for me where I've to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pinpoint the bug in the application: usually not trivial when it's a real/big application&lt;/li&gt;
&lt;li&gt;reverse-engineer the codes involved in the bug in order to figure out why it's happening (sometimes I got the sources, sometimes I don't like this time)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In this post, I will show you how I've manage to pinpoint where the bug was, using &lt;a href="http://msdn.microsoft.com/en-us/library/windows/hardware/ff549561(v=vs.85).aspx"&gt;GFlags, PageHeap&lt;/a&gt; and &lt;a href="http://www.windbg.info/"&gt;WinDbg&lt;/a&gt;. Then, we will reverse-engineer the buggy code in order to understand why the bug is happening, and how we can code a clean trigger.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Mon, 09 Sep 2013 09:53:00 -0700</pubDate><guid isPermaLink="false">tag:None,2013-09-09:/blog/2013/09/09/pinpointing-heap-related-issues-ollydbg2-off-by-one-story/</guid><category>reverse-engineering</category><category>debugging</category></item><item><title>Some thoughts about code-coverage measurement with Pin</title><link>/blog/2013/08/31/some-thoughts-about-code-coverage-measurement-with-pin/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Sometimes, when you are reverse-engineering binaries you need somehow to measure, or just to have an idea about how much "that" execution is covering the code of your target. It can be for fuzzing purpose, maybe you have a huge set of inputs (it can be files, network traffic, anything) and you want to have the same coverage with only a subset of them. Or maybe, you are not really interested in the measure, but only with the coverage differences between two executions of your target: to locate where your program is handling a specific feature for example.&lt;/p&gt;
&lt;p&gt;But it's not a trivial problem, usually you don't have the source-code of the target, and you want it to be quick. The other thing, is that you don't have an input that covers the whole code base, you don't even know if it's possible ; so you can't compare your analysis to that "ideal one". Long story short, you can't say to the user "OK, this input covers 10% of your binary". But you can clearly register what your program is doing with input A, what it is doing with input B and then analyzing the differences. With that way you can have a (more precise?) idea about which input seems to have better coverage than another.&lt;/p&gt;
&lt;p&gt;Note also, this is a perfect occasion to play with Pin :-)).&lt;/p&gt;
&lt;p&gt;In this post, I will explain briefly how you can build that kind of tool using Pin, and how it can be used for reverse-engineer purposes.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Sat, 31 Aug 2013 18:57:00 -0700</pubDate><guid isPermaLink="false">tag:None,2013-08-31:/blog/2013/08/31/some-thoughts-about-code-coverage-measurement-with-pin/</guid><category>reverse-engineering</category><category>dynamic-binary-instrumentation</category></item><item><title>Regular expressions obfuscation under the microscope</title><link>/blog/2013/08/24/regular-expressions-obfuscation-under-the-microscope/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Some months ago I came across a strange couple of functions that was kind of playing with a &lt;a href="http://en.wikipedia.org/wiki/Finite-state_machine"&gt;finite-state automaton&lt;/a&gt; to validate an input. At first glance, I didn't really notice it was in fact a regex being processed, that's exactly why I spent quite some time to understand those routines. You are right to ask yourself: "Hmm but the regex string representation should be in the binary shouldn't it?", the thing is it wasn't. The purpose of this post is to focus on those kind of "compiled" regex, like when the author transform somehow the regex in a FSM directly usable in its program (for the sake of efficiency I guess). And to extract that handy string representation, you have to study the automaton.&lt;/p&gt;
&lt;p&gt;In this short post, we are going to see how a regular expression looks like in assembly/C, and how you can hide/obfuscate it. I hope you will enjoy the read, and you will both be able to recognize a regular expression compiled in your future reverse-engineering tasks and to obfuscate heavily your regex!&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Sat, 24 Aug 2013 12:35:00 -0700</pubDate><guid isPermaLink="false">tag:None,2013-08-24:/blog/2013/08/24/regular-expressions-obfuscation-under-the-microscope/</guid><category>reverse-engineering</category><category>obfuscation</category></item></channel></rss>