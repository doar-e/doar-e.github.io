<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Diary of a reverse-engineer</title><link>https://doar-e.github.io/</link><description></description><lastBuildDate>Thu, 15 Apr 2021 08:00:00 -0700</lastBuildDate><item><title>Reverse-engineering tcpip.sys: mechanics of a packet of the death (CVE-2021-24086)</title><link>https://doar-e.github.io/blog/2021/04/15/reverse-engineering-tcpipsys-mechanics-of-a-packet-of-the-death-cve-2021-24086/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Since the beginning of my journey in computer security I have always been amazed and fascinated by &lt;em&gt;true&lt;/em&gt; remote vulnerabilities. By &lt;em&gt;true&lt;/em&gt; remotes, I mean bugs that are triggerable remotely without any user interaction. Not even a single click. As a result  I am always on the lookout for …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Thu, 15 Apr 2021 08:00:00 -0700</pubDate><guid isPermaLink="false">tag:doar-e.github.io,2021-04-15:/blog/2021/04/15/reverse-engineering-tcpipsys-mechanics-of-a-packet-of-the-death-cve-2021-24086/</guid><category>reverse-engineering</category><category>tcpip.sys</category><category>CVE-2021-24086</category><category>Ipv6pReassembleDatagram</category><category>fragmentation</category><category>recursive-fragmentation</category></item><item><title>Modern attacks on the Chrome browser : optimizations and deoptimizations</title><link>https://doar-e.github.io/blog/2020/11/17/modern-attacks-on-the-chrome-browser-optimizations-and-deoptimizations/</link><description>&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;


&lt;p&gt;Late 2019, I presented at an internal Azimuth Security conference some work on hacking Chrome through it's JavaScript engine. &lt;/p&gt;
&lt;p&gt;One of the topics I've been playing with at that time was deoptimization and so I discussed, among others, vulnerabilities in the deoptimizer. For my talk at &lt;a href="https://www.infiltratecon.com/conference/briefings/attacking-chrome-in-2020-a-journey-through-v8s-optimizing-compiler.html"&gt;InfiltrateCon 2020&lt;/a&gt; in …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeremy "@__x86" Fetiveau</dc:creator><pubDate>Tue, 17 Nov 2020 00:00:00 -0800</pubDate><guid isPermaLink="false">tag:doar-e.github.io,2020-11-17:/blog/2020/11/17/modern-attacks-on-the-chrome-browser-optimizations-and-deoptimizations/</guid><category>exploitation</category><category>chrome</category><category>v8</category><category>turbofan</category><category>exploitation</category></item><item><title>A journey into IonMonkey: root-causing CVE-2019-9810.</title><link>https://doar-e.github.io/blog/2019/06/17/a-journey-into-ionmonkey-root-causing-cve-2019-9810/</link><description>&lt;h1 id="a-journey-into-ionmonkey-root-causing-cve-2019-9810"&gt;A journey into IonMonkey: root-causing CVE-2019-9810.&lt;/h1&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;In May, I wanted to play with &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt"&gt;BigInt&lt;/a&gt; and evaluate how I could use them for browser exploitation. The exploit I wrote for the &lt;a href="https://github.com/0vercl0k/blazefox"&gt;blazefox&lt;/a&gt; relied on a Javascript library developed by &lt;a href="https://twitter.com/5aelo"&gt;@5aelo&lt;/a&gt; that allows code to manipulate 64-bit integers. Around the same …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Mon, 17 Jun 2019 08:00:00 -0700</pubDate><guid isPermaLink="false">tag:doar-e.github.io,2019-06-17:/blog/2019/06/17/a-journey-into-ionmonkey-root-causing-cve-2019-9810/</guid><category>exploitation</category><category>ion</category><category>ionmonkey</category><category>spidermonkey</category><category>exploitation</category><category>firefox</category></item><item><title>Circumventing Chrome's hardening of typer bugs</title><link>https://doar-e.github.io/blog/2019/05/09/circumventing-chromes-hardening-of-typer-bugs/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Some &lt;a href="http://eternalsakura13.com/2018/11/19/justintime/"&gt;recent&lt;/a&gt; &lt;a href="https://abiondo.me/2019/01/02/exploiting-math-expm1-v8"&gt;Chrome&lt;/a&gt; &lt;a href="https://www.jaybosamiya.com/blog/2019/01/02/krautflare/"&gt;exploits&lt;/a&gt; were taking advantage of &lt;a href="https://en.wikipedia.org/wiki/Bounds-checking_elimination"&gt;Bounds-Check-Elimination&lt;/a&gt; in order to get a R/W primitive from a TurboFan's typer bug (a bug that incorrectly computes type information during code optimization). Indeed during the simplified lowering phase when visiting a CheckBounds node if the engine can guarantee that …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeremy "__x86" Fetiveau</dc:creator><pubDate>Thu, 09 May 2019 08:00:00 -0700</pubDate><guid isPermaLink="false">tag:doar-e.github.io,2019-05-09:/blog/2019/05/09/circumventing-chromes-hardening-of-typer-bugs/</guid><category>exploitation</category><category>v8</category><category>turbofan</category><category>chrome</category><category>exploitation</category></item><item><title>Introduction to TurboFan</title><link>https://doar-e.github.io/blog/2019/01/28/introduction-to-turbofan/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Ages ago I wrote a blog post here called &lt;a href="https://doar-e.github.io/blog/2014/03/11/first-dip-into-the-kernel-pool-ms10-058/"&gt;first dip in the kernel pool&lt;/a&gt;, this year we're going to swim in a sea of nodes!&lt;/p&gt;
&lt;p&gt;The current trend is to attack JavaScript engines and more specifically, optimizing JIT compilers such as &lt;a href="https://v8.dev/"&gt;V8&lt;/a&gt;'s &lt;a href="https://v8.dev/docs/turbofan"&gt;TurboFan&lt;/a&gt;, SpiderMonkey's IonMonkey, JavaScriptCore's Data …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeremy "__x86" Fetiveau</dc:creator><pubDate>Mon, 28 Jan 2019 08:00:00 -0800</pubDate><guid isPermaLink="false">tag:doar-e.github.io,2019-01-28:/blog/2019/01/28/introduction-to-turbofan/</guid><category>exploitation</category><category>v8</category><category>turbofan</category><category>exploitation</category></item><item><title>Introduction to SpiderMonkey exploitation.</title><link>https://doar-e.github.io/blog/2018/11/19/introduction-to-spidermonkey-exploitation/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;This blogpost covers the development of three exploits targeting SpiderMonkey JavaScript Shell interpreter and Mozilla Firefox on Windows 10 RS5 64-bit from the perspective of somebody that has never written a browser exploit nor looked closely at any JavaScript engine codebase.&lt;/p&gt;
&lt;p&gt;As you have probably noticed, there has been …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Mon, 19 Nov 2018 08:25:00 -0800</pubDate><guid isPermaLink="false">tag:doar-e.github.io,2018-11-19:/blog/2018/11/19/introduction-to-spidermonkey-exploitation/</guid><category>exploitation</category><category>spidermonkey</category><category>blazefox</category><category>exploitation</category><category>windows</category><category>ttd</category></item><item><title>CVE-2017-2446 or JSC::JSGlobalObject::isHavingABadTime.</title><link>https://doar-e.github.io/blog/2018/07/14/cve-2017-2446-or-jscjsglobalobjectishavingabadtime/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;This post will cover the development of an exploit for JavaScriptCore (JSC) from the perspective of someone with no background in browser exploitation.&lt;/p&gt;
&lt;p&gt;Around the start of the year, I was pretty burnt out on CTF problems and was interested in writing an exploit for something more complicated and …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">yrp</dc:creator><pubDate>Sat, 14 Jul 2018 18:49:00 -0700</pubDate><guid isPermaLink="false">tag:doar-e.github.io,2018-07-14:/blog/2018/07/14/cve-2017-2446-or-jscjsglobalobjectishavingabadtime/</guid><category>exploitation</category><category>JavascriptCore</category><category>jsc</category><category>cve-2017-2446</category><category>exploitation</category></item><item><title>Breaking ledgerctf's AES white-box challenge</title><link>https://doar-e.github.io/blog/2018/05/17/breaking-ledgerctfs-aes-white-box-challenge/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;About a month ago, my mate &lt;a href="https://twitter.com/b0n0n"&gt;b0n0n&lt;/a&gt; was working on the &lt;a href="https://www.ledger.fr/ctf2018/"&gt;ledgerctf&lt;/a&gt; puzzles and challenged me to have a look at the &lt;em&gt;ctf2&lt;/em&gt; binary. I eventually did and this blogpost discusses the protection scheme and how I broke it. Before diving in though, here is a bit of background …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Thu, 17 May 2018 11:52:00 -0700</pubDate><guid isPermaLink="false">tag:doar-e.github.io,2018-05-17:/blog/2018/05/17/breaking-ledgerctfs-aes-white-box-challenge/</guid><category>reverse-engineering</category><category>reverse-engineering</category><category>ledgerctf</category><category>whitebox</category></item><item><title>beVX challenge on the operation table</title><link>https://doar-e.github.io/blog/2018/03/11/bevx-challenge-on-the-operation-table/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;About two weeks ago, my friend &lt;a href="https://twitter.com/mongobug"&gt;mongo&lt;/a&gt; challenged me to solve a reverse-engineering puzzle put up by the &lt;a href="https://blogs.securiteam.com/"&gt;SSD&lt;/a&gt; team for &lt;a href="https://www.offensivecon.org/"&gt;OffensiveCon2018&lt;/a&gt; (which is a security conference that took place in Berlin in February). The challenge binary is available for download &lt;a href="https://www.beyondsecurity.com/bevxcon/bevx-challenge-1"&gt;here&lt;/a&gt; and &lt;a href="https://twitter.com/SecuriTeam_SSD/status/964459126960066560"&gt;here is one of the original …&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Sun, 11 Mar 2018 17:22:00 -0700</pubDate><guid isPermaLink="false">tag:doar-e.github.io,2018-03-11:/blog/2018/03/11/bevx-challenge-on-the-operation-table/</guid><category>reverse-engineering</category><category>reverse-engineering</category><category>beVX</category></item><item><title>Debugger data model, Javascript &amp; x64 exception handling</title><link>https://doar-e.github.io/blog/2017/12/01/debugger-data-model/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;The main goal of today's post is to show a bit more of what is now possible with the latest Windbg (currently branded &lt;a href="https://blogs.windows.com/buildingapps/2017/08/28/new-windbg-available-preview/"&gt;"WinDbg Preview"&lt;/a&gt; in the Microsoft store) and the time travel debugging tools that Microsoft released a few months ago. When these finally got released, a bit …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Fri, 01 Dec 2017 06:59:00 -0800</pubDate><guid isPermaLink="false">tag:doar-e.github.io,2017-12-01:/blog/2017/12/01/debugger-data-model/</guid><category>debugging</category><category>debugging</category><category>javascript</category><category>windbg</category><category>exception handling</category><category>seh</category><category>time-travel debugging</category><category>ttd</category></item><item><title>Binary rewriting with syzygy, Pt. I</title><link>https://doar-e.github.io/blog/2017/08/05/binary-rewriting-with-syzygy/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Binary instrumentation and analysis have been subjects that I have always found fascinating. At compile time via &lt;a href="http://doar-e.github.io/blog/2016/11/27/clang-and-passes/"&gt;clang&lt;/a&gt;, or at runtime with dynamic binary instrumentation frameworks like &lt;a href="https://software.intel.com/en-us/articles/pin-a-dynamic-binary-instrumentation-tool"&gt;Pin&lt;/a&gt; or &lt;a href="http://www.dynamorio.org/"&gt;DynamoRIO&lt;/a&gt;. One thing I have always looked for though, is a framework able to statically instrument a PE image. A …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Sat, 05 Aug 2017 16:08:00 -0700</pubDate><guid isPermaLink="false">tag:doar-e.github.io,2017-08-05:/blog/2017/08/05/binary-rewriting-with-syzygy/</guid><category>misc</category><category>binary rewriting</category><category>syzygy</category><category>program analysis</category></item><item><title>happy unikernels</title><link>https://doar-e.github.io/blog/2016/12/21/happy-unikernels/</link><description>&lt;h1 id="intro"&gt;Intro&lt;/h1&gt;
&lt;p&gt;Below is a collection of notes regarding unikernels. I had originally prepared this stuff to submit to EkoParty’s CFP, but ended up not wanting to devote time to stabilizing PHP7’s heap structures and I lost interest in the rest of the project before it was complete. However …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">yrp</dc:creator><pubDate>Wed, 21 Dec 2016 18:59:00 -0800</pubDate><guid isPermaLink="false">tag:doar-e.github.io,2016-12-21:/blog/2016/12/21/happy-unikernels/</guid><category>exploitation</category><category>unikernel</category><category>rumpkernel</category><category>exploitation</category></item><item><title>Token capture via an llvm-based analysis pass</title><link>https://doar-e.github.io/blog/2016/11/27/clang-and-passes/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;About three years ago, the LLVM framework started to pique my interest for a lot of different reasons. This collection of industrial strength compiler technology, as &lt;a href="http://llvm.org/pubs/2008-10-04-ACAT-LLVM-Intro.pdf"&gt;Latner&lt;/a&gt; said in 2008, was designed in a very modular way. It also looked like it had a lot of interesting features that …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Sun, 27 Nov 2016 20:43:00 -0800</pubDate><guid isPermaLink="false">tag:doar-e.github.io,2016-11-27:/blog/2016/11/27/clang-and-passes/</guid><category>misc</category><category>fuzzing</category><category>clang</category><category>llvm</category><category>analysis pass</category><category>pass</category></item><item><title>Keygenning with KLEE</title><link>https://doar-e.github.io/blog/2015/08/18/keygenning-with-klee/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;In the past weeks I enjoyed working on reversing a piece of software (don't ask me the name), to study how serial numbers are validated. The story the user has to follow is pretty common: download the trial, pay, get the serial number, use it in the annoying nag …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Michele "brt_device" Bertasi</dc:creator><pubDate>Tue, 18 Aug 2015 22:12:00 -0700</pubDate><guid isPermaLink="false">tag:doar-e.github.io,2015-08-18:/blog/2015/08/18/keygenning-with-klee/</guid><category>reverse-engineering</category><category>reverse-engineering</category><category>symbolic execution</category></item><item><title>Spotlight on an unprotected AES128 white-box implementation</title><link>https://doar-e.github.io/blog/2015/02/08/spotlight-on-an-unprotected-aes128-whitebox-implementation/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;I think it all began when I've worked on the &lt;a href="https://github.com/0vercl0k/stuffz/tree/master/NoSuchCon2013"&gt;NSC2013&lt;/a&gt; crackme made by &lt;a href="https://twitter.com/elvanderb"&gt;@elvanderb&lt;/a&gt;, long story short you had an AES128 heavily obfuscated white-box implementation to break. The thing was you could actually solve the challenge in different ways: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;the first one was the easiest one: you didn't …&lt;/li&gt;&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Sun, 08 Feb 2015 22:59:00 -0800</pubDate><guid isPermaLink="false">tag:doar-e.github.io,2015-02-08:/blog/2015/02/08/spotlight-on-an-unprotected-aes128-whitebox-implementation/</guid><category>obfuscation</category><category>obfuscation</category><category>white-box</category><category>practical cryptography</category><category>aes128</category><category>encryption</category></item><item><title>Taming a wild nanomite-protected MIPS binary with symbolic execution: No Such Crackme</title><link>https://doar-e.github.io/blog/2014/10/11/taiming-a-wild-nanomite-protected-mips-binary-with-symbolic-execution-no-such-crackme/</link><description>&lt;p&gt;As last year, the French conference &lt;a href="http://www.nosuchcon.org/#challenge"&gt;No Such Con&lt;/a&gt; returns for its second edition in Paris from the 19th of November until the 21th of November. And again, the brilliant &lt;a href="https://twitter.com/elvanderb"&gt;Eloi Vanderbeken&lt;/a&gt; &amp;amp; his mates at &lt;a href="http://synacktiv.fr/en/index.html"&gt;Synacktiv&lt;/a&gt; put together a series of three security challenges especially for this occasion.
Apparently, the …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet &amp; Emilien "tr4nce" Girault</dc:creator><pubDate>Sat, 11 Oct 2014 21:35:00 -0700</pubDate><guid isPermaLink="false">tag:doar-e.github.io,2014-10-11:/blog/2014/10/11/taiming-a-wild-nanomite-protected-mips-binary-with-symbolic-execution-no-such-crackme/</guid><category>reverse-engineering</category><category>reverse-engineering</category><category>z3py</category><category>z3</category><category>symbolic execution</category><category>MIPS</category><category>NoSuchCon</category></item><item><title>Dissection of Quarkslab's 2014 security challenge</title><link>https://doar-e.github.io/blog/2014/09/06/dissection-of-quarkslabs-2014-security-challenge/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;As the blog was a bit silent for quite some time, I figured it would be cool to put together a post ; so here it is folks, dig in!&lt;/p&gt;
&lt;p&gt;The French company &lt;a href="http://blog.quarkslab.com/you-like-python-security-challenge-and-traveling-win-a-free-ticket-to-hitb-kul.html"&gt;Quarkslab&lt;/a&gt; &lt;a href="https://twitter.com/quarkslab/status/507457671386394624"&gt;recently&lt;/a&gt; &lt;a href="https://twitter.com/HITBSecConf/status/507458788522094592"&gt;released&lt;/a&gt; a security challenge to win a free entrance to attend the upcoming &lt;a href="https://conference.hitb.org/hitbsecconf2014kul/"&gt;HITBSecConf&lt;/a&gt; conference …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Sat, 06 Sep 2014 20:37:00 -0700</pubDate><guid isPermaLink="false">tag:doar-e.github.io,2014-09-06:/blog/2014/09/06/dissection-of-quarkslabs-2014-security-challenge/</guid><category>reverse-engineering</category><category>python</category><category>virtual machine</category><category>reverse-engineering</category></item><item><title>Corrupting the ARM Exception Vector Table</title><link>https://doar-e.github.io/blog/2014/04/30/corrupting-arm-evt/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;A few months ago, I was writing a Linux kernel exploitation challenge on ARM in an attempt to learn about kernel exploitation and I thought I'd explore things a little. I chose the ARM architecture mainly because I thought it would be fun to look at. This article is …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Amat "acez" Cama</dc:creator><pubDate>Wed, 30 Apr 2014 21:01:00 -0700</pubDate><guid isPermaLink="false">tag:doar-e.github.io,2014-04-30:/blog/2014/04/30/corrupting-arm-evt/</guid><category>exploitation</category><category>exploitation</category><category>kernel</category></item><item><title>Deep dive into Python's VM: Story of LOAD_CONST bug</title><link>https://doar-e.github.io/blog/2014/04/17/deep-dive-into-pythons-vm-story-of-load_const-bug/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;A year ago, I've written a Python script to leverage a bug in Python's virtual machine: the idea was to fully control the Python virtual processor and after that to instrument the VM to execute native codes. The &lt;a href="https://github.com/0vercl0k/stuffz/blob/master/Python's%20internals/python27_abuse_vm_to_execute_x86_code.py"&gt;python27_abuse_vm_to_execute_x86_code.py&lt;/a&gt; script wasn't really self-explanatory, so I believe only a …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Thu, 17 Apr 2014 23:22:00 -0700</pubDate><guid isPermaLink="false">tag:doar-e.github.io,2014-04-17:/blog/2014/04/17/deep-dive-into-pythons-vm-story-of-load_const-bug/</guid><category>exploitation</category><category>python</category><category>virtual machine</category></item><item><title>First dip into the kernel pool : MS10-058</title><link>https://doar-e.github.io/blog/2014/03/11/first-dip-into-the-kernel-pool-ms10-058/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;I am currently playing with pool-based memory corruption vulnerabilities. That’s why I wanted to program a PoC exploit for the vulnerability presented by Tarjei Mandt during his first talk “Kernel Pool Exploitation on Windows 7” &lt;a href="http://www.mista.nu/research/MANDT-kernelpool-PAPER.pdf"&gt;[3]&lt;/a&gt;. I think it's a good exercise to start learning about pool overflows …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeremy "__x86" Fetiveau</dc:creator><pubDate>Tue, 11 Mar 2014 10:52:37 +0100</pubDate><guid isPermaLink="false">tag:doar-e.github.io,2014-03-11:/blog/2014/03/11/first-dip-into-the-kernel-pool-ms10-058/</guid><category>exploitation</category><category>reverse-engineering</category><category>exploitation</category><category>kernel pool</category><category>ms10-058</category><category>tcpip.sys</category></item><item><title>Having a look at the Windows' User/Kernel exceptions dispatcher</title><link>https://doar-e.github.io/blog/2013/10/12/having-a-look-at-the-windows-userkernel-exceptions-dispatcher/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;The purpose of this little post is to create a piece of code able to monitor exceptions raised in a process (a bit like &lt;a href="http://gynvael.coldwind.pl/"&gt;gynvael&lt;/a&gt;'s &lt;a href="http://gynvael.coldwind.pl/?id=148"&gt;ExcpHook&lt;/a&gt; but in userland), and to generate a report with information related to the exception. The other purpose is to have a look …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Sat, 12 Oct 2013 14:03:00 -0700</pubDate><guid isPermaLink="false">tag:doar-e.github.io,2013-10-12:/blog/2013/10/12/having-a-look-at-the-windows-userkernel-exceptions-dispatcher/</guid><category>reverse-engineering</category><category>coding</category><category>hooking</category><category>windows internals</category></item><item><title>Breaking Kryptonite's obfuscation: a static analysis approach relying on symbolic execution</title><link>https://doar-e.github.io/blog/2013/09/16/breaking-kryptonites-obfuscation-with-symbolic-execution/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Kryptonite&lt;/em&gt; was a proof-of-concept I built to obfuscate codes at the LLVM intermediate representation level. The idea was to use semantic-preserving transformations in order to not break the original program. One of the main idea was for example to build a home-made 32 bits adder to replace the &lt;em&gt;add …&lt;/em&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Mon, 16 Sep 2013 11:47:00 -0700</pubDate><guid isPermaLink="false">tag:doar-e.github.io,2013-09-16:/blog/2013/09/16/breaking-kryptonites-obfuscation-with-symbolic-execution/</guid><category>reverse-engineering</category><category>reverse-engineering</category></item><item><title>Pinpointing heap-related issues: OllyDbg2 off-by-one story</title><link>https://doar-e.github.io/blog/2013/09/09/pinpointing-heap-related-issues-ollydbg2-off-by-one-story/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Yesterday afternoon, I was peacefully coding some stuff you know but I couldn't make my code working.
As usual, in those type of situations you fire up your debugger in order to understand what is going on under the hood.
That was a bit weird, to give you a …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Mon, 09 Sep 2013 09:53:00 -0700</pubDate><guid isPermaLink="false">tag:doar-e.github.io,2013-09-09:/blog/2013/09/09/pinpointing-heap-related-issues-ollydbg2-off-by-one-story/</guid><category>debugging</category><category>reverse-engineering</category><category>debugging</category></item><item><title>Some thoughts about code-coverage measurement with Pin</title><link>https://doar-e.github.io/blog/2013/08/31/some-thoughts-about-code-coverage-measurement-with-pin/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Sometimes, when you are reverse-engineering binaries you need somehow to measure, or just to have an idea about how much "that" execution is covering the code of your target. It can be for fuzzing purpose, maybe you have a huge set of inputs (it can be files, network traffic …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Sat, 31 Aug 2013 18:57:00 -0700</pubDate><guid isPermaLink="false">tag:doar-e.github.io,2013-08-31:/blog/2013/08/31/some-thoughts-about-code-coverage-measurement-with-pin/</guid><category>misc</category><category>reverse-engineering</category><category>dynamic-binary-instrumentation</category></item><item><title>Regular expressions obfuscation under the microscope</title><link>https://doar-e.github.io/blog/2013/08/24/regular-expressions-obfuscation-under-the-microscope/</link><description>&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Some months ago I came across a strange couple of functions that was kind of playing with a &lt;a href="http://en.wikipedia.org/wiki/Finite-state_machine"&gt;finite-state automaton&lt;/a&gt; to validate an input. At first glance, I didn't really notice it was in fact a regex being processed, that's exactly why I spent quite some time to understand …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Axel "0vercl0k" Souchet</dc:creator><pubDate>Sat, 24 Aug 2013 12:35:00 -0700</pubDate><guid isPermaLink="false">tag:doar-e.github.io,2013-08-24:/blog/2013/08/24/regular-expressions-obfuscation-under-the-microscope/</guid><category>obfuscation</category><category>reverse-engineering</category><category>obfuscation</category></item></channel></rss>